[
  
  {
    "title": "读书笔记 —— Github + Jekyll",
    "url": "/posts/Github+Jekyll/",
    "categories": "other",
    "tags": "jekyll",
    "date": "2023-07-19 15:34:00 +0800",
    





    
    "snippet": "jekyll  如何使用jekyll和GitHub搭建一个免费博客。创建github账号和仓库      创建github账号        建立一个仓库，仓库名是访问地址，一般格式为: XXX.github.io  安装ruby环境  下载ruby+Devkit (www.ruby-lang.org)  安装 Ruby+Devkit 3.2.2-1(x86).exe安装RubyGems  ...",
    "content": "jekyll  如何使用jekyll和GitHub搭建一个免费博客。创建github账号和仓库      创建github账号        建立一个仓库，仓库名是访问地址，一般格式为: XXX.github.io  安装ruby环境  下载ruby+Devkit (www.ruby-lang.org)  安装 Ruby+Devkit 3.2.2-1(x86).exe安装RubyGems  下载RubyGems (www.ruby-lang.org)  解压  运行命令# 进入你解压的文件夹cd D:\\rubyGems\\rubygems-3.4.17ruby setup.rbgem install jekyll创建博客  创建博客模板cd XXX # 进入你放置博客文件的位置jekyll new testblogcd testblogjekyll server # 测试博客是否能创建  选择主题默认创建的博客模板比较简单，可以挑选一个自己喜欢的博客模板。主题官网：http://jekyllthemes.org/  下载主题源码  解压下载的文件，该目录就是一个博客模板(之前创建的博客模板不要了)  运行模板jekyll build --incremental# 启动jekyll serve# jekyll serve -H 0.0.0.0 -P 18888 --detach --incremental# 关闭pkill -f jekyll执行的时候可能会报错，比如：[!] There was an error parsing `Gemfile`:[!] There was an error while loading `jekyll-theme-chirpy.gemspec`: No such file or directory - git ls-files -z. Bundler cannot continue. #  from E:/笔记/myblog/jekyll-theme-chirpy.gemspec:13 #  ------------------------------------------- # &gt;  end #  # frozen_string_literal: true #  -------------------------------------------. Bundler cannot continue. #  from E:/笔记/myblog/Gemfile:5 #  ------------------------------------------- #  # Jekyll &lt;= 4.2.0 compatibility with Ruby 3.0 &gt;  gem \"webrick\", \"~&gt; 1.7\" #  # frozen_string_literal: true #  -------------------------------------------因为windows上不支持git命令，所以报错了，建议通过git bash来执行这些命令。然后打开网址 127.0.0.1:4000 就可以访问博客了上传到github  进入_site目录该目录保存所有生成的网站，所以只需要把_site目录上的所有文件上传到github就可以了。  删除模板的git信息rm -rf .git  初始化本地git仓库git init  添加git仓库的远程信息git remote add origin https://xxxx.git  将当前目录文件添加到git本地仓库git add .  将当前目录文件提交到本git地仓库git commit -m \"first commit\"  推送到远程仓库git push -u origin \"master\"如果出现“fatal: Could not read from remote repository.”的错误，参考以下解决方法：Git问题 “fatal: Could not read from remote repository.”创建github pages  打开github仓库地址  选择setting选项卡-&gt;pages  找到Branch，选择master，然后点save  可以在actions选项卡查看页面构建进度。  构建完成就可以通过 https://username.github.io 访问了Jekyll 目录结构_posts 博客内容_pages 其他需要生成的网页，如About页_layouts 网页排版模板_includes 被模板包含的HTML片段，可在_config.yml中修改位置assets 辅助资源 css布局 js脚本 图片等_data 动态数据_sites 最终生成的静态网页_config.yml 网站的一些配置信息index.html 网站的入口Reference[1] Github+Jekyll 搭建个人网站详细教程[2] 【Git】本地项目代码上传到git仓库[3] Git问题 “fatal: Could not read from remote repository.”"
  },
  
  {
    "title": "读书笔记 —— 最大文件描述符数",
    "url": "/posts/%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%95%B0/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, File Descriptor",
    "date": "2023-07-19 14:35:00 +0800",
    





    
    "snippet": "进程池概述  本节介绍了Linux的最大文件描述符数的限制，分为用户级限制和系统级限制两种，前者是一个用户能打开的文件描述符数，后者是所有用户能打开的文件描述符数。因为系统分配给应用程序的文件描述符是有限制的，所以我们通常关闭那些不需要的文件描述符，避免占用资源。最大文件描述符数系统分配给应用程序的文件描述符是有限制的，所以我们总是关闭那些不需要的文件描述符，释放它们占用的资源。比如作为守护...",
    "content": "进程池概述  本节介绍了Linux的最大文件描述符数的限制，分为用户级限制和系统级限制两种，前者是一个用户能打开的文件描述符数，后者是所有用户能打开的文件描述符数。因为系统分配给应用程序的文件描述符是有限制的，所以我们通常关闭那些不需要的文件描述符，避免占用资源。最大文件描述符数系统分配给应用程序的文件描述符是有限制的，所以我们总是关闭那些不需要的文件描述符，释放它们占用的资源。比如作为守护进程运行的服务器程序就总是关闭标准输入、标准输出和标准错误这3个文件描述符。Linux中，应用程序能打开的文件描述符数量有两个层次的限制：  用户级限制  系统级限制用户级限制用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数。我们可以通过以下命令查看用户级文件描述符数限制：ulimit -n我们可以通过以下命令将用户级文件描述符数限制设定为max-file-number：ulimit -SHn max-file-number不过通过ulimit命令修改的文件描述符数限制是临时的，只对当前的session有效。如果需要永久修改用户级文件描述符数的限制，可以在/etc/security/limits.conf文件中加入以下两行：hard nofile max-file-number     # 系统硬限制soft nofile max-file-number     # 系统软限制系统级限制系统级的限制是指所有用户总共能打开的文件描述符数。我们可以通过以下命令修改系统级文件描述符数的限制：sysctl -w fs.file-max=max-file-number不过上述命令也是临时更改系统限制，如果需要永久修改系统级文件描述符数的限制，可以在/etc/sysctl.conf文件中加入以下行：fs.file-max=max-file-number然后执行以下命令使之生效：sysctl -p总结      用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数    系统级的限制是指所有用户总共能打开的文件描述符数  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 进程池和线程池_2",
    "url": "/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread Poll, Process Pool",
    "date": "2023-07-19 09:34:00 +0800",
    





    
    "snippet": "线程池的实现  本节我们实现了简单的两种线程池模型：基于半同步/半异步模式的线程池、基于半同步/半反应堆模式的线程池。前者可以保证同一个客户连接的所有任务都由一个子进程来处理，后者通过工作队列解除了主线程和工作线程的耦合关系，通用性更高。半同步/半异步线程池的实现综合前面的讨论，我们实现一个半同步/半异步模式的线程池。该线程池可以避免父、子进程之间传递文件描述符，还保证同一个客户连接的所有任...",
    "content": "线程池的实现  本节我们实现了简单的两种线程池模型：基于半同步/半异步模式的线程池、基于半同步/半反应堆模式的线程池。前者可以保证同一个客户连接的所有任务都由一个子进程来处理，后者通过工作队列解除了主线程和工作线程的耦合关系，通用性更高。半同步/半异步线程池的实现综合前面的讨论，我们实现一个半同步/半异步模式的线程池。该线程池可以避免父、子进程之间传递文件描述符，还保证同一个客户连接的所有任务都由一个子进程来处理。//  filename: processpool.h#ifndef PROCESSPOOL.H#define PROCESSPOOL.H#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;//  描述一个子进程的类class process{public:    process() : m_pid(-1) { }public:    pid_t m_pid;        //  目标子进程的pid    int m_pipefd[2];    //  父子进程通信的管道};//  进程池类，为了代码复用定义为模板类，其模板参数是处理逻辑任务的类template &lt;typename T&gt;class processpool{private:    //  该类是单例模式，所以构造函数定义为私有的    processpool(int listenfd, int process_number = 8);public:    static processpool&lt;T&gt;* create(int listenfd, int process_number = 8)    {        if(!m_instance){            m_instance = new processpool&lt;T&gt;(listenfd, process_number);        }        return m_instance;    }    ~processpool()    {        delete[] m_sub_process;    }    void run();     //  启动进程池private:    void setup_sig_pipe();    void run_parent();    void run_child();private:    static const int MAX_PROCESS_NUMBER = 16;   //  进程池允许的最大进程数量    static const int USER_PER_PROCESS = 65536;  //  每个子进程最多能处理的客户数量    static const int MAX_EVENT_NUMBER = 10000;  //  epoll最多能处理的事件数    int m_process_number;                       //  进程池中的进程总数    int m_idx;                                  //  子进程在池中的序号，从0开始    int m_epollfd;                              //  每个子进程都由一个epoll内核事件表，用m_epollfd标识    int m_listenfd;                             //  监听socket    int m_stop;                                 //  子进程通过m_stop来决定是否停止运行    process *m_sub_process;                     //  存储所有子进程的描述信息    static processpool&lt;T&gt; *m_instance;          //  进程池静态实例};template &lt;typename T&gt;processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = NULL;//  用于处理信号的管道，以实现统一事件源，后面称为信号管道static int sig_pipefd[2];static int setnonblocking(int fd){    int old_option = fcntl(fd, F_GETFL);    int new_option = old_option | O_NONBLOCK;    fcntl(fd, F_SETFL, new_option);    return old_option;}static void addfd(int epollfd, int fd){    epoll_event event;    event.data.fd = fd;    event.events = EPOLLIN | EPOLLET;    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);    setnonblocking(fd);}//  从epollfd标识的epoll内核事件表中删除fd上的所有注册事件static void removefd(int epollfd, int fd){    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);    close(fd);}static void sig_handler(int sig){    int save_errno = errno;    int msg = sig;    send(sig_pipefd[1], (char *)&amp;msg, 1, 0);    errno = save_errno;}static void addsig(int sig, void(handler)(int), bool restart = true){    struct sigaction sa;    memset(&amp;sa, '\\0', sizeof(sa));    sa.sa_handler = handler;    if(restart){        sa.sa_flags |= SA_RESTART;    }    sigfillset(&amp;sa.sa_mask);    assert(sigaction(sig, &amp;sa, NULL) != -1);}//  进程池类构造函数template &lt;typename T&gt;processpool&lt;T&gt;::processpool(int listenfd, int process_number):m_listenfd(listenfd), m_process_number(process_number), m_idx(-1), m_stop(false){    assert((process_number &gt; 0) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));    m_sub_process = new process[process_number];    assert(m_sub_process);    //  创建process_number个子进程，并建立它们和父进程之间的管道    for(int i = 0 ; i &lt; process_number ; i++){        int ret = socketpair(PF_UNIX, SOCK_STREAM, 0, m_sub_process[i].m_pipefd);        assert(ret == 0);        m_sub_process[i].m_pid = fork();        assert(m_sub_process[i].m_pid &gt;= 0);        if(m_sub_process[i].m_pid &gt; 0){            close(m_sub_process[i].pipefd[1]);            continue;        }else{            close(m_sub_process[i].pipefd[0]);            m_idx = i;            break;        }    }}   //  统一事件源template &lt;typename T&gt;void processpool&lt;T&gt;::setup_sig_pipe(){    //  创建epoll事件监听表和信号管道    m_epollfd = epoll_create(5);    assert(m_epollfd != -1);    int ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sig_pipefd);    assert(ret != -1);    setnonblocking(sig_pipefd[1]);    addfd(m_epollfd, sig_pipefd[0]);    //  设置信号处理函数    addsig(SIGCHLD, sig_handler);   //  子进程停止或退出    addsig(SIGTERM, sig_handler);   //  kill    addsig(SIGINT, sig_handler);    //  中断进程    addsig(SIGPIPE, SIG_IGN);}//  父进程中m_idx为-1，子进程m_idx大于等于0，我们根据m_idx来判断接下来执行的是父进程代码还是子进程代码template &lt;typename T&gt;void process&lt;T&gt;::run(){    if(m_idx != -1){        run_child();        return;    }    run_parent();}template &lt;typename T&gt;void processpool&lt;T&gt;::run_child(){    setup_sig_pipe();    //  每个子进程都通过其在线程池中的序号m_idx找到与父进程通信的管道    int pipefd = m_sub_process[m_idx].m_pipefd[1];    //  子进程需要监听管道文件描述符pipefd, 因为父进程将通过它来通知子进程accept新连接    addfd(m_epollfd, pipefd);    epoll_event events[MAX_EVENT_NUMBER];    T *users = new T[USER_PER_PROCESS];    assert(users);    int number = 0;    int ret = -1;    while(!m_stop){        number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);        if((number &lt; 0) &amp;&amp; (errno != EINTR)){            printf(\"epoll failure\\n\");            break;        }        for(int i = 0 ; i &lt; number ; i++){            int sockfd = events[i].data.fd;            if((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)){                int client = 0;                //  从父子进程之间的管道读取数据，将结果存储在client中。如果读取成功，表示由新客户连接到来                ret = recv(sockfd, (char*)&amp;client, sizeof(client), 0);                if(((ret &lt; 0) &amp;&amp; (errno != EAGAIN)) || ret == 0){                    continue;                }else{                    struct sockaddr_in client_address;                    socklen_t client_addrlength = sizeof(client_address);                    int connfd = accept(m_listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);                    if(connfd &lt; 0){                        printf(\"errno is %d\\n\", errno);                        continue;                    }                    addfd(m_epollfd, connfd);                    //  模板类T必须实现init方法，以初始化一个客户连接，我们直接使用connfd作为索引处理对象，以提高效率                    users[connfd].init(m_epollfd, connfd, client_address);                }            }            //  子进程接收到信号            else if((sockfd == sig_pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)){                int sig;                char signasl[1024];                ret = recv(sig_pipefd[0], signals, sizeof(signals), 0);                if(ret &lt;= 0){                    continue;                }else{                    for(int i = 0 ; i &lt; ret ; i++){                        switch(signals[i]){                            case SIGCHLD:                            {                                pid_t pid;                                int stat;                                while((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0){                                    continue;                                }                                break;                            }                            case SIGTERM:                            case SIGINT:                            {                                m_stop = true;                                break;                            }                            default:                            {                                break;                            }                        }                    }                }            }            //  如果是其他可读数据，必然是客户请求到来，调用逻辑处理对象的process方法处理            else if(events[i].events &amp; EPOLLIN){                users[sockfd].process();            }            else{                continue;            }        }    }    delete[] users;    users = NULL;    close(pipefd);    close(m_epollfd);}template &lt;typename T&gt;void processpool&lt;T&gt;::run_parent(){    setup_sig_pipe();    //  父进程监听m_listenfd    addfd(m_epollfd, m_listenfd);    epoll_event events[MAX_EVENT_NUMBER];    int sub_process_counter = 0;    int new_conn = 1;    int number = 0;    int ret = -1;    while(!m_stop){        number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);        if((number &lt; 0) &amp;&amp; (errno != EINTR)){            printf(\"epoll failure\\n\");            break;        }        for(int i = 0 ; i &lt; number ; i++){            int sockfd = events[i].data.fd;            if(sockfd == m_listenfd){                //  如果有新连接到来，采用Round Robin方式分配给一个子进程处理                int i = sub_process_counter;                do{                    if(m_sub_process[i].m_pid != -1){                        break;                    }                    i = (i + 1) % m_process_number;                }while(i != sub_process_counter);                if(m_sub_process[i].m_pid == -1){   //  轮转了一圈，没有可用的子进程                    m_stop = true;                    break;                }                sub_process_counter = (i + 1) % m_process_number;                send(m_sub_process[i].m_pipefd[0], (char*)&amp;new_conn, sizeof(new_conn), 0);                printf(\"send request to child %d\\n\", i);            }            //  处理父进程接收到的信号            else if((sockfd == sig_pipefd[0]) &amp;&amp; (events[i].event &amp; EPOLLIN)){                int sig;                char signasl[1024];                ret = recv(sig_pipefd[0], signals, sizeof(signals), 0);                if(ret &lt;= 0){                    continue;                }else{                    for(int i = 0 ; i &lt; ret ; i++){                        switch(signals[i]){                            case SIGCHLD:                            {                                pid_t pid;                                int stat;                                while((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0){                                    for(int i = 0 ; i &lt; m_process_number ; i++){                                        //  如果进程池第i个子进程退出了，则主进程关闭相应的通信管道，并设置相应的m_pid为-1，以标记该子进程已退出                                        if(m_sub_process[i].m_pid == pid){                                            printf(\"child %d join\\n\", i);                                            close(m_sub_process[i].m_pipefd[0]);                                            m_sub_process[i].m_pid = -1;                                        }                                    }                                }                                //  如果所有子进程都已退出，父进程也退出                                m_stop = true;                                for(int i = 0 ; i &lt; m_process_number ; i++){                                    if(m_sub_process[i].m_pid != -1){                                        m_stop = false;                                    }                                }                                break;                            }                            case SIGTERM:                            case SIGINT:                            {                                //  父进程接受到终止信号，先杀死所有子进程                                printf(\"kill all the child now\\n\");                                for(int i = 0 ; i &lt; m_process_number ; i++){                                    int pid = m_sub_process[i].m_pid;                                    if(pid != -1){                                        kill(pid, SIGTERM);                                    }                                }                                m_stop = true;                                break;                            }                            default:                            {                                break;                            }                        }                    }                }            }            else{                continue;            }        }    }    close(m_epollfd);}#endif半同步/半反应堆模式基于半同步/半反应堆模式的线程池通用性要高得多，因为它通过工作队列解除了主线程和工作线程的耦合关系。主线程将工作线程插入任务，工作线程通过竞争来获取任务并执行。但是基于半同步/半反应堆模式的线程池也有缺陷：因为同一个连接的不同请求插入任务队列后，可能会被不同的工作线程处理，所以所有客户请求必须是无状态的。//  filename: threadpool.h#ifndef THREADPOOL_H#define THREADPOOL_H#include &lt;list&gt;#include &lt;cstdio&gt;#include &lt;exception&gt;#include &lt;pthread.h&gt;#include \"locker.h\"     //  线程同步机制的包装类template &lt;typename T&gt;class threadpool{public:    threadpool(int thread_number = 8, int max_requests = 10000);    ~threadpool();    bool append(T *request);private:    static void *work(void *arg);    void run();private:    int m_thread_number;        //  线程池中的线程数量    int m_max_requests;         //  请求队列中允许的最大请求数    pthread_t *m_threads;       //  描述线程池的数组，其大小为m_thread_number    std::list&lt;T*&gt; m_workqueue;  //  请求队列    locker m_queuelocker;       //  保护请求队列的互斥锁    sem m_queuestat;            //  是否有任务需要处理    bool m_stop;                //  是否结束线程}；template &lt;typename T&gt;threadpool&lt;T&gt;::threadpool(int thread_number, int max_requests): m_thread_number(thread_number), m_max_requests(max_requests), m_stop(false), m_threads(NULL){    if((thread_number &lt;= 0) || (max_requests &lt;= 0)){        throw std::exception();    }    m_threads = new pthread_t[m_thread_number];    if(!m_threads){        throw std::exception();    }    //  创建thread_number个线程，并将它们设置为脱离线程    for(int i = 0 ; i &lt; thread_number ; i++){        printf(\"create the %dth thread\\n\");        if(pthread_create(m_threads + i, NULL, worker, this) != 0){            delete[] m_threads;            throw std::exception();        }        if(pthread_detach(m_threads[i])){            delete[] m_threads;            throw std::exception();        }    } }template &lt;typename T&gt;threadpool&lt;T&gt;::~threadpool(){    delete[] m_threads;    m_stop = true;}template &lt;typename T&gt;bool threadpool&lt;T&gt;::append(T *request){    //  操作工作队列是一定要加锁，因为它被所有线程共享    m_queuelocker.lock();    if(m_workqueue.size() &gt; m_max_requests){        m_queuelocker.unlock();        return false;    }    m_workqueue.push_back(request);    m_queuelocker.unlock();    m_queuestat.post();    return true;}template &lt;typename T&gt;void *threadpool&lt;T&gt;::worker(void *arg){    threadpool *pool = (threadpool*)arg;    pool-&gt;run();    return pool;}template &lt;typename T&gt;void threadpool&lt;T&gt;::run(void *arg){    while(!m_stop){        m_queuestat.wait();        m_queuelocker.lock();        if(m_workqueue.empty()){            m_queuelocker.unlock();            continue;        }        T *request = m_workqueue.front();        m_workqueue.pop_front();        m_queuelocker.unlock();        if(!request){            continue;        }        request-&gt;process();    }}#endif  pthread_create函数传入执行函数时，必须传入一个静态函数。如果要在静态函数中使用类的动态成员，有以下两种方法：      通过类的静态对象调用(比如单例模式)    将类的对象作为参数传递给该静态函数  总结      基于半同步/半异步模式的线程池。该线程池可以避免父、子进程之间传递文件描述符，还保证同一个客户连接的所有任务都由一个子进程来处理    基于半同步/半反应堆模式的线程池通用性要高得多，因为它通过工作队列解除了主线程和工作线程的耦合关系  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 进程池和线程池_1",
    "url": "/posts/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread Poll, Process Pool",
    "date": "2023-07-18 19:16:00 +0800",
    





    
    "snippet": "进程池概述  本节探讨了进程池(线程池)的一些概念，已经它们解决了什么问题。由于进程池和线程池在模型上类似，所以我们只讨论进程池。进程池是为了解决动态创建进程耗费时间、占用不必要的内核资源，且创建的子进程只能为一个客户服务等问题。所以我们预先在服务器创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性。进程池处理多客户任务时，需要注意两个问题：1.监听socket和连接socket...",
    "content": "进程池概述  本节探讨了进程池(线程池)的一些概念，已经它们解决了什么问题。由于进程池和线程池在模型上类似，所以我们只讨论进程池。进程池是为了解决动态创建进程耗费时间、占用不必要的内核资源，且创建的子进程只能为一个客户服务等问题。所以我们预先在服务器创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性。进程池处理多客户任务时，需要注意两个问题：1.监听socket和连接socket是否都由主进程统一管理？这个问题涉及到服务器并发模型的确立。2.一个客户连接的所有任务是否始终由一个子进程来处理？这个问题涉及到服务器的是有状态的还是无状态的。进程池(线程池)概述动态创建子进程(子线程)的缺点：  耗费时间，导致客户响应慢  创建的子进程(子线程)只能为一个客户服务，如果客户较多，过多的进程(线程)切换会耗费大量CPU时间  动态创建的子进程是当前进程的完整映像，必须谨慎管理分配的文件描述符、堆内存等系统资源，否则会导致系统可用资源下降，影响服务器性能为了解决动态创建进程(线程)的问题，我们提出了进程池(线程池)的概念：进程池是由服务器预先创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性(比如优先级、PGID等)。由于进程池在服务器启动初始化时就创建，所以每个子进程没有打开不必要的文件描述符和堆内存(从父进程继承或复制而来)。当新的任务到来时，主进程以某种方式选择进程池中的一个子进程来执行任务，这比动态创建子进程的代价小很多。主进程选择线程池中子进程的方式，主要有以下两种：  主进程通过某种算法来主动选择子进程(比如随机算法、Round Robin轮流选取算法)。  主进程和所有子进程通过一个共享的工作队列来同步，所有子进程睡眠在该工作队列上。当新的任务到来时，主进程将任务添加到工作队列中，这将唤醒等待任务的子进程，该子进程执行新任务，而其他子进程继续睡眠(通过条件变量实现)。当选择好子进程后，还需要通过某种通信机制来通知目标子进程，同时传递必要的数据。可以通过管道或其他全局共享数据结构实现。线程池的一般模型如下图所示：处理多客户用进程池处理多个客户的连接时，可能会存在以下两个问题：  问题1：使用进程池处理多客户任务时，监听socket和连接socket是否都由主进程统一管理？不同的并发模式，管理这两种socket的方式不同：  半同步/半反应堆模式: 主进程统一管理这两种socket。  半同步/半异步模式: 主进程管理所有监听socket，子进程分别管理属于自己的连接socket。  领导者/追随者模式: 主进程管理所有监听socket，子进程分别管理属于自己的连接socket。第一种情况中，主进程管理所有监听socket，然后传递给子进程。后两种情况中，子进程自身调用accept调用来接受新的连接，这样父进程不需要向子进程传递socket，只需要发送一个通知：新的连接事件到达。  问题2：一个客户连接的所有任务是否始终由一个子进程来处理？这个问题同样分情况讨论：  如果客户任务是无状态的，我们可以使用不同的子进程处理同一客户的不同请求。  如果客户任务是存在上下文关系的，我们应该一直用同一个子进程来服务，否则我们需要在各个子进程之间传递上下文(可以通过epoll的EPOLLONESHOT来确保同一个客户的连接被同一个进程处理)。总结      进程池是由服务器预先创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_7",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_7/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-17 14:23:00 +0800",
    





    
    "snippet": "多线程环境  本节探讨了多线程环境中容易遇到的一些问题。首先，Linux有些库函数是线程安全的，而有些库函数不是线程安全的。多线程环境中调用线程不安全的库函数会导致不可预期的后果。不过线程不安全的库函数占比少，而且大部分由线程安全版本。其次，线程执行fork调用后会复制父进程，但只会创建一个子线程。我们需要注意复制的子进程会继承父进程的互斥锁，这容易导致子进程死锁。线程库中提供了pthrea...",
    "content": "多线程环境  本节探讨了多线程环境中容易遇到的一些问题。首先，Linux有些库函数是线程安全的，而有些库函数不是线程安全的。多线程环境中调用线程不安全的库函数会导致不可预期的后果。不过线程不安全的库函数占比少，而且大部分由线程安全版本。其次，线程执行fork调用后会复制父进程，但只会创建一个子线程。我们需要注意复制的子进程会继承父进程的互斥锁，这容易导致子进程死锁。线程库中提供了pthread_atfork函数来保证fork调用后互斥锁处于解锁状态。最后，在我们探讨了多线程环境下的信号问题，每个线程都可以设置信号掩码，但是容易出现逻辑混乱、共享信号处理函数等问题，所以需要一个专门的线程处理信号。线程安全如果一个函数能被多个线程同时调用而且不发生竞态条件，我们称它是线程安全的(thread safe)，或者说它是可重入函数。Linux中只有一小部分函数是不可重入的，比如inet_ntoa、getservbyname、getservbyport。这些库函数不可重入的原因是内部使用了静态变量。不过Linux为很多不可重入的库函数提供了可重入版本，这些可重入版本的函数名是在原函数名的尾部加上_r。比如localtime的可重入版本是localtime_r。在多线程程序中调用库函数，一定要使用其可重入版本，否则可能导致不可预估的结果。线程和进程场景：如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程会拥有多少个线程？答案是一个，而且子进程的线程复制于调用fork的那个线程。这里会产生一个问题，如果原来的父进程中已经加锁，复制后的子进程也会加锁。也就是说，子进程会自动继承父进程中的互斥锁状态(条件变量同理)。这会带来一些问题：  子进程可能不清楚继承的互斥锁的具体状态(加锁状态还是解锁状态)，因为这个锁可能不是调用fork的子线程锁住的，而是其他线程锁住的  如果子进程对该互斥锁执行加锁，可能会导致死锁我们通过一段代码模拟这个过程：#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;pthread_mutex_t mutex;//  子线程运行的函数，先获得互斥锁，再暂停5s，然后释放互斥锁void *anthor(void *arg){    printf(\"in child thread, lock the mutex\\n\");    pthread_mutex_lock(&amp;mutex);    sleep(5);    pthread_mutex_unlock(&amp;mutex);    printf(\"unlock the mutex\\n\");}int main(){    pthread_mutex_init(&amp;mutex, NULL);    pthread_t id;    pthread_create(&amp;id, NULL, another, NULL);    //  父进程中的主线程暂停1s，确保执行fork之前，子线程已经开始运行并获得了互斥锁    sleep(1);    int pid = fork();    if(pid &lt; 0)    {        pthread_join(id, NULL);        pthread_mutex_destroy(&amp;mutex);        return 1;    }    else if(pid == 0)   //  子进程    {        printf(\"I am in the child, want to get the lock\\n\");        /*  子进程从父进程继承了互斥锁的状态，该互斥锁目前处于被锁住的状态        因此，下面这句加锁操作会一直阻塞，接管逻辑上来说它是不应该阻塞的*/        pthread_mutex_lock(&amp;mutex);        printf(\"I can not run to here, oop...\\n\");        pthread_mutex_unlock(&amp;mutex);        exit(0);    }    else    //  父进程    {        wait(NULL);    }    pthread_join(id, NULL);    pthread_mutex_destroy(&amp;mutex);    return 0;}pthread提供了一个专门的函数pthread_atfork，确保fork调用后父进程和子进程都拥有一个清除的锁状态。下面是pthread_atfork函数，功能是在fork调用后使父进程和子进程的互斥锁都处于解锁状态，其定义如下：#include &lt;pthread.h&gt;int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));参数和返回值：  prepare: prepare句柄在fork调用创建出子进程前被执行，用来锁住所有父进程中的互斥锁  parent: parent句柄在fork调用创建出子进程后，且fork返回前被执行，由父进程执行，用来释放被锁住的互斥锁  child: child句柄在fork调用创建出子进程后，且fork返回前被执行，由子进程执行，用来释放被锁住的互斥锁  返回值: 成功返回0，失败返回错误码该函数放在fork调用之前，其用法如下：void prepare(){    pthread_mutex_lock(&amp;mutex);}void infork(){    pthread_mutex_unlock(&amp;mutex);}pthread_atfork(prepare, infork);线程和信号每个线程都可以独立地设置信号掩码。进程设置信号掩码的函数是sigprocmask，但多线程环境下pthread库提供了线程版本的设置信号掩码函数。下面是pthread_sigmask函数，功能是为线程设置信号掩码，其定义如下：#include &lt;pthread.h&gt;#include &lt;signal.h&gt;int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);参数和返回值：  how: 指定设置进程信号掩码的方式  newmask: 新的信号掩码。如果_set为NULL，则进程信号掩码不变，可以用来获取进程当前的信号掩码  oldmask: 输出原来的信号掩码  返回值: 成功返回0，失败返回错误码线程中的信号处理容易出现以下问题：  由于所有线程都共享该进程收到的信号，线程库会根据线程掩码决定把信号发送给哪些具体的线程，如果我们为每个子线程单独设置了信号掩码，容易导致逻辑错误  所有线程共享信号处理函数，我们设置的信号处理函数会覆盖其他线程同一信号的信号处理函数解决这些问题最好是定义一个专门的线程来处理所有信号，步骤如下：  在主线程创建出其他子线程之前，先调用pthread_sigmask来设置信号掩码，所有新创建的子线程都会自动继承这个信号掩码  在某个线程中调用sigwait等待信号并处理之下面是sigwait函数，功能是等待目标信号集中的信号，其定义如下#include &lt;signal.h&gt;int sigwait(const sigset_t *set, int *sig);参数和返回值：  set: 需要等待的信号集合，我们设置为被信号掩码屏蔽的信号集，表示在该线程中等待所有被屏蔽的信号  sig: 存储该函数返回的信号值  返回值: 成功返回0，失败返回错误码一旦sigwait正确返回，我们可以根据接收到的信号作相应处理，而且不需要再设置信号处理函数了。下面我们通过man手册的例子来展示如何实现在一个线程统一处理所有信号：#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#define handle_error_en(en, msg) do {errno = en; perror(msg); exit(EXIT_FAILURE); } while(0)static void *sig_thread(void *arg){    sigset_t *set = (sigset_t *)arg;    int s, sig;    for( ; ; )    {        //  第二个步骤，调用sigwait等待信号        s = sigwait(set, &amp;sig);        if(s != 0)            handle_error_en(s, \"sigwait\");        printf(\"Signal handling thread got signal %d\\n\", sig);    }}int main(int argc, char *argv[]){    pthread_t thread;    sigset_t set;    int s;    //  第一个步骤，在主线程中设置信号掩码    sigemptyset(&amp;set);    sigaddset(&amp;set, SIGQUIT);   //  ctrl+\\ 触发    sigaddset(&amp;set, SIGUSR1);   //  kill -10 进程号 触发    s = pthread_sigmask(SIG_BLOCK, &amp;set, NULL);    if(s != 0)        handle_error_en(s, \"pthread_sigmask\");    s = pthread_create(&amp;thread, NULL, &amp;sig_thread, (void*)&amp;set);    if(s != 0)        handle_error_en(s, \"pthread_create\");    pause();}最后，pthread还提供了将信号发送给指定线程的函数。下面是pthread_kill函数，功能是将一个信号发送给指定的线程，其定义如下：#include &lt;signal.h&gt;int pthread_kill(pthread_t thread, int sig);参数和返回值：  thread: 目标线程  sig: 待发送的信号，如果值为0，pthread_kill不发送信号，但会执行错误检查，可以用来检查目标线程是否存在  返回值: 成功返回0，失败返回错误码总结      如果一个函数能被多个线程同时调用而且不发生竞态条件，我们称它是线程安全的(thread safe)，或者说它是可重入函数    Linux为很多不可重入的库函数提供了可重入版本，这些可重入版本的函数名是在原函数名的尾部加上_r    子进程会自动继承父进程中的互斥锁状态(条件变量同理)    线程库中提供了pthread_atfork函数，功能是在fork调用后使父进程和子进程的互斥锁都处于解锁状态    线程库中提供了pthread_sigmask函数，功能是为线程设置信号掩码    线程库中提供了sigwait函数，功能是等待目标信号集中的信号    线程库中提供了pthread_kill函数，功能是将一个信号发送给指定的线程  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_6",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_6/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-17 11:14:00 +0800",
    





    
    "snippet": "条件变量  本节介绍了条件变量的相关API，包括初始化条件变量、销毁条件变量、唤醒一个或全部等待条件变量的线程、等待条件变量。条件变量条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。对比互斥锁，互斥锁是同步线程对共享数据的访问，而条件变量同步的是线程之间的共享数据的值。pthread_cond_init下面是pthread_cond_init函...",
    "content": "条件变量  本节介绍了条件变量的相关API，包括初始化条件变量、销毁条件变量、唤醒一个或全部等待条件变量的线程、等待条件变量。条件变量条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。对比互斥锁，互斥锁是同步线程对共享数据的访问，而条件变量同步的是线程之间的共享数据的值。pthread_cond_init下面是pthread_cond_init函数，功能是初始化条件变量，其定义如下：#include &lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);参数和返回值：  cond: 目标条件变量  cond_attr: 指定条件变量的属性，如果传入NULL表示使用默认属性，条件变量的属性不多，而且与互斥锁属性类似  返回值: 成功返回0，失败返回错误码此外，我们还可以通过宏来创建并初始化一个条件变量。PTHREAD_COND_INITIALIZER实际上将条件变量的各个字段初始化为0。pthread_cond_t cond = PTHREAD_COND_INITIALIZER;pthread_cond_destroy下面是pthread_cond_destroy函数，功能是销毁条件变量，并释放其占用的内核资源，其定义如下：#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);参数和返回值：  cond: 目标条件变量  返回值: 成功返回0，失败返回错误码注意：销毁一个正在被等待的条件变量会失败，并返回EBUSY。pthread_cond_broadcast下面是pthread_cond_broadcast函数，功能是以广播的方式唤醒所有等待目标条件变量的线程，其定义如下：#include &lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond);参数和返回值：  cond: 目标条件变量  返回值: 成功返回0，失败返回错误码pthread_cond_signal下面是pthread_cond_signal函数，功能是唤醒其他一个等待目标条件变量的线程，其定义如下：#include &lt;pthread.h&gt;int pthread_cond_signal(pthread_cond_t *cond);参数和返回值：  cond: 目标条件变量  返回值: 成功返回0，失败返回错误码唤醒哪一个线程取决于线程的优先级和调度策略。如果我们想要唤醒指定线程，很遗憾，pthread库并没有提供相关函数。但我们可以间接实现：定义一个全局变量，表示目标线程。当所有线程被广播唤醒时，先检查该全局变量，判断被唤醒的线程是否是自己，如果是就开始执行代码，如果不是就继续等待。pthread_cond_wait下面是pthread_cond_wait函数，功能是等待目标条件变量，其定义如下：#include &lt;pthread.h&gt;int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);参数和返回值：  cond: 目标条件变量  mutex: 保护条件变量的互斥锁  返回值: 成功返回0，失败返回错误码pthread_cond_wait函数的执行过程：  在调用pthread_cond_wait之前，必须确保互斥锁mutex已经加锁，否则会导致不可预期的后果。  pthread_cond_wait函数执行时，先把调用线程放入该条件变量的等待队列  然后将互斥锁mutex解锁  当thread_cond_wait函数成功返回时，互斥锁mutex会被再次锁上总结      条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程    线程库中提供了pthread_cond_init函数，功能是初始化条件变量    线程库中提供了pthread_cond_destroy函数，功能是销毁条件变量    线程库中提供了pthread_cond_broadcast函数，功能是以广播的方式唤醒所有等待目标条件变量的线程    线程库中提供了pthread_cond_signal函数，功能是唤醒其他一个等待目标条件变量的线程    线程库中提供了pthread_cond_wait函数，功能是等待目标条件变量  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_5",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_5/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-16 17:06:00 +0800",
    





    
    "snippet": "互斥锁  本节介绍了互斥锁的相关API，包括初始化互斥锁、销毁互斥锁、上锁、解锁。接着探讨了互斥锁的属性对象，我们针对pshared和type这两个属性作了具体介绍。最后说明了互斥锁运用不当可能会导致死锁，使程序无法继续往下执行。互斥锁互斥锁(互斥量)用于保护关键代码段，确保线程的独占式访问。进入关键代码段时，我们获得互斥锁并加锁；离开关键代码段时，我们进行解锁，并唤醒其他等待该互斥锁的线程...",
    "content": "互斥锁  本节介绍了互斥锁的相关API，包括初始化互斥锁、销毁互斥锁、上锁、解锁。接着探讨了互斥锁的属性对象，我们针对pshared和type这两个属性作了具体介绍。最后说明了互斥锁运用不当可能会导致死锁，使程序无法继续往下执行。互斥锁互斥锁(互斥量)用于保护关键代码段，确保线程的独占式访问。进入关键代码段时，我们获得互斥锁并加锁；离开关键代码段时，我们进行解锁，并唤醒其他等待该互斥锁的线程。pthread_mutex_init下面是pthread_mutex_init函数，功能是初始化互斥锁，其定义如下：#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);参数和返回值：  mutex: 目标互斥锁  mutexattr: 指定互斥锁的属性，如果传入NULL表示使用默认属性  返回值: 成功返回0，失败返回错误码此外，我们还可以通过宏来创建并初始化一个互斥锁。PTHREAD_MUTEX_INITIALIZER实际上将互斥锁的各个字段初始化为0。pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_destroy下面是pthread_mutex_destroy函数，功能是销毁互斥锁，并释放其占用的内核资源，其定义如下：#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);参数和返回值：  mutex: 目标互斥锁  返回值: 成功返回0，失败返回错误码注意：销毁一个已经加锁的互斥锁会导致不可预期的后果。pthread_mutex_lock下面是pthread_mutex_lock函数，功能是以原子操作的方式给一个互斥锁加锁，其定义如下：#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);参数和返回值：  mutex: 目标互斥锁  返回值: 成功返回0，失败返回错误码如果目标互斥锁已经上锁，则该调用会阻塞，直到该互斥锁的占用者解锁。pthread_mutex_trylock下面是pthread_mutex_trylock函数，功能是以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已上锁，会立即返回，其定义如下：#include &lt;pthread.h&gt;int pthread_mutex_trylock(pthread_mutex_t *mutex);参数和返回值：  mutex: 目标互斥锁  返回值: 成功返回0，失败返回错误码如果目标互斥锁已经上锁，则该调用会立即返回错误码EBUSY。pthread_mutex_unlock下面是pthread_mutex_unlock函数，功能是以原子操作的方式给一个互斥锁解锁，其定义如下：#include &lt;pthread.h&gt;int pthread_mutex_unlock(pthread_mutex_t *mutex);参数和返回值：  mutex: 目标互斥锁  返回值: 成功返回0，失败返回错误码如果有其他线程正在等待这个互斥锁，则等待线程中的某一个会获得该锁。互斥锁属性线程库中提供了一系列函数来操作pthread_mutexaddr_t类型的变量，以下是其中一些主要的函数：#include &lt;pthread.h&gt;//  初始化互斥锁属性对象int pthread_mutexaddr_init(pthread_mutexaddr_t *attr);//  销毁互斥锁属性对象int pthread_mutexaddr_destroy(pthread_mutexaddr_t *attr);//  获取和设置互斥锁的pshared属性int pthread_mutexaddr_getpshared(const pthread_mutexaddr_t *attr, int *pshared);int pthread_mutexaddr_setpshared(pthread_mutexaddr_t *attr, int pshared);//  获取的设置互斥锁的type属性int pthread_mutexaddr_gettype(const pthread_mutexaddr_t *attr, int *type);int pthread_mutexaddr_settype(pthread_mutexaddr_t *attr, int type);这里只讨论互斥锁的两个常用属性：pshared和type  pshared该属性指定是否允许跨进程共享互斥锁，有以下两个可选值：  PTHREAD_PROCESS_SHARED: 互斥锁可以被跨进程共享  PTHREAD_PROCESS_PRIVATE: 互斥锁只能被同一个进程的线程共享，该进程是锁的初始化线程隶属的进程  type指定互斥锁的类型，有以下四个可选值：  PTHREAD_MUTEX_NORMAL: 普通锁(默认类型)一个线程对普通锁加锁后，其余请求该锁的线程将形成一个等待队列，并在该锁解锁后按优先级获得锁。普通锁保证了资源分配的公平性。但有以下缺点：一个线程如果对已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程加锁的普通锁解锁，会导致不可预期的结果；对一个已经解锁的普通锁再次解锁，会导致不可预期的结果。  PTHREAD_MUTEX_ERRORCHECK: 检错锁一个线程如果对一个已经加锁的检错锁再次加锁，加锁操作会返回EDEADLK。一个线程如果对一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错锁解锁，则解锁操作会返回EPERM。  PTHREAD_MUTEX_RECURSIVE: 嵌套锁嵌套锁允许一个线程在解锁之前多次加锁，而不会发生死锁。不过其他线程如果想要获得该锁，则嵌套锁的拥有者必须执行相应次数的解锁操作。对一个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁解锁，则解锁操作会返回EPERM。  PTHREAD_MUTEX_DEFAULT: 默认锁这种锁在实现时可能被映射为上面三种锁之一。所以以下情况可能会导致不可预期的结果：一个线程如果对已经加锁的默认锁再次加锁；对一个已经被其他线程加锁的默认锁解锁；对一个已经解锁的默认锁再次解锁。死锁如果一个线程对一个已经加锁的普通锁再次加锁，将会导致死锁。如果两个线程按照不同的顺序来申请两个互斥锁，也容易产生死锁。死锁会导致一个或多个线程被挂起而无法继续执行。我们通过一个例子来展示死锁的发生：#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int a = 0;int b = 0;pthread_mutex_t mutex_a;pthread_mutex_t mutex_b;void *anthor(void *arg){  pthread_mutex_lock(&amp;mutex_b);  printf(\"in child thread, got mutex b, waiting for mutex a\");  sleep(5);  ++b;  pthread_mutex_lock(&amp;mutex_a);  b += a++;  pthread_mutex_unlock(&amp;mutex_a);  pthread_mutex_unlock(&amp;mutex_b);  pthread_exit(NULL);}int main(){  pthread_t id;  pthread_mutex_init(&amp;mutex_a, NULL);  pthread_mutex_init(&amp;mutex_b, NULL);  pthread_create(&amp;id, NULL, anthor, NULL);  pthread_mutex_lock(&amp;mutex_a);  printf(\"in parent thread, got mutex a, waiting for mutex b\");  sleep(5);  ++a;  pthread_mutex_lock(&amp;mutex_b);  b += a++;  pthread_mutex_unlock(&amp;mutex_b);  pthread_mutex_unlock(&amp;mutex_a);  pthread_join(id, NULL);  pthread_mutex_destroy(&amp;mutex_a);  pthread_mutex_destroy(&amp;mutex_b);  return 0;}主线程先占有互斥锁mutex_a，然后操作被该锁保护的变量a。但操作完毕后，主线程并没有立即释放互斥锁mutex_a，而是申请了互斥锁mutex_b，在两个互斥锁的保护下，修改变量a、b，最后一起释放互斥锁。与此同时，子线程按照相反的顺序先申请了互斥锁mutex_b，再申请互斥锁mutex_a，并在两个互斥锁的保护下，修改变量a、b。上述代码用sleep()函数模拟了两次调用的时间差，以确保每个线程各自占有一个互斥锁，然后等待另一个互斥锁。这样两个线程就僵持住了，谁都不能继续往下执行，构成了死锁。如果去掉sleep()函数，这段代码可能能执行成功，但会为程序留下一个潜在的BUG。总结      互斥锁(互斥量)用于保护关键代码段，确保线程的独占式访问    线程库中提供了pthread_mutex_init函数，功能是初始化互斥锁    线程库中提供了pthread_mutex_destroy函数，功能是销毁互斥锁    线程库中提供了pthread_mutex_lock函数，功能是以原子操作的方式给一个互斥锁加锁    线程库中提供了pthread_mutex_trylock函数，功能是以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已上锁，会立即返回    线程库中提供了pthread_mutex_unlock函数，功能是以原子操作的方式给一个互斥锁解锁    线程库中提供了一系列函数来操作pthread_mutexaddr_t类型的变量    如果一个线程对一个已经加锁的普通锁再次加锁，或者两个线程按照不同的顺序来申请两个互斥锁，可能会产生死锁  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  最小高度树",
    "url": "/posts/%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/",
    "categories": "leetcode",
    "tags": "leetcode, BFS, DFS, Topological Sort",
    "date": "2023-07-13 20:05:00 +0800",
    





    
    "snippet": "BFS/DFS/Topological Sort  该题要求找到以某个结点为根节点时，树高度最小。难点在于如何不超时的情况下，求出所有的可能的根结点。题目树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都...",
    "content": "BFS/DFS/Topological Sort  该题要求找到以某个结点为根节点时，树高度最小。难点在于如何不超时的情况下，求出所有的可能的根结点。题目树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。例子示例1输入：n = 4, edges = [[1,0],[1,2],[1,3]]输出：[1]解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。示例2输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]输出：[3,4]条件  1 &lt;= n &lt;= 2 * 10^4  edges.length == n - 1  0 &lt;= ai, bi &lt; n  ai != bi  所有 (ai, bi) 互不相同  给定的输入 保证 是一棵树，并且 不会有重复的边难点分析该题最简单直观的做法是求每一个结点的高度，然后返回高度最小的那一组结点，时间复杂度是O(n^2)。但是这样做法会超时，所以难点在于如何找出所有可能的根节点，而且不超时。我们总结以下三种方法：  BFSBFS的思想是，树高度最小的根结点一定是在最中间的结点(这样到每一个叶结点的距离是最小的)，而且这个结点一定在整个图的最长路径上(可以通过反证证明)。所以我们首先要求图的最长路径。我们任意一点出发，求距离该点的最远结点x。然后从x出发，求距离x点的最远结点y。最长路径一定是结点x到y的这段路径(同样可以用反证法证明)。所以我们用BFS算法求出结点0和结点x的最远结点，并记录路径，然后我们根据路径返回中间结点。如果路径长度为奇数，则根节点是path[m / 2]；如果路径长度是偶数，则根节点是path[m / 2]，path[(m - 1) / 2 ]。  DFS该方法思想和上述思想类似，区别在于通过DFS的方法求出最远距离。  拓扑排序拓扑排序的思想是，先找出叶子结点(即入度为1的结点)，然后删除叶子结点及其边(将邻居结点的入度减1)，然后以此类推继续删除新的叶子结点。最后图会不断向中心缩小，最后被删除的点(由于树的特性，最后结点数量只可能是1或2)就是高度最小的树的根结点。解法解法1：BFSclass Solution {public:    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        if (n == 1)        {            return {0};        }        vector&lt;int&gt; res;        vector&lt;vector&lt;int&gt;&gt; edgesDict(n, vector&lt;int&gt;());        vector&lt;int&gt; indegree(n, 0);        for(auto &amp;e : edges){            edgesDict[e[0]].emplace_back(e[1]);            edgesDict[e[1]].emplace_back(e[0]);        }        vector&lt;int&gt; parent(n, -1);        //  找到与节点 0 最远的节点        int x = findLongNode(0, parent, edgesDict);        //  找到与节点 x 最远的节点        int y = findLongNode(x, parent, edgesDict);        parent[x] = -1;        vector&lt;int&gt; path;        while(y != -1){            path.emplace_back(y);            y = parent[y];        }        int m = path.size();        if(m % 2 == 0){            return {path[(m - 1) / 2], path[m / 2]};        }else{            return {path[m / 2]};        }    }        int findLongNode(int u, vector&lt;int&gt; &amp;parent, vector&lt;vector&lt;int&gt;&gt; &amp;edgesDict){        int n = edgesDict.size();        vector&lt;bool&gt; visited(n, false);        queue&lt;int&gt; qu;        qu.push(u);        visited[u] = true;        int node = 0;        while(!qu.empty()){            int t = qu.front();            qu.pop();            node = t;            for(auto &amp;e : edgesDict[t]){                if(!visited[e]){                    qu.push(e);                    visited[e] = true;                    parent[e] = t;                }            }        }        return node;    }};解法2：DFSclass Solution {public:    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        if (n == 1)        {            return {0};        }        vector&lt;int&gt; res;        vector&lt;vector&lt;int&gt;&gt; edgesDict(n, vector&lt;int&gt;());        vector&lt;int&gt; indegree(n, 0);        for(auto &amp;e : edges){            edgesDict[e[0]].emplace_back(e[1]);            edgesDict[e[1]].emplace_back(e[0]);        }        vector&lt;int&gt; parent(n, -1);        //  找到与节点 0 最远的节点        int x = findLongNode(0, parent, edgesDict);        //  找到与节点 x 最远的节点        int y = findLongNode(x, parent, edgesDict);        parent[x] = -1;        vector&lt;int&gt; path;        while(y != -1){            path.emplace_back(y);            y = parent[y];        }        int m = path.size();        if(m % 2 == 0){            return {path[(m - 1) / 2], path[m / 2]};        }else{            return {path[m / 2]};        }    }        int findLongNode(int u, vector&lt;int&gt; &amp;parent, vector&lt;vector&lt;int&gt;&gt; &amp;edgesDict){        const int n = edgesDict.size();        vector&lt;int&gt; dict(n, -1);        dict[u] = 0;        dfs(u, dict, parent, edgesDict);        int node = -1;        int maxValue = -1;        for(int i = 0 ; i &lt; n; i++){            // cout&lt;&lt;dict[i]&lt;&lt;endl;            if(dict[i] &gt; maxValue){                maxValue = dict[i];                node = i;            }        }        return node;    }    void dfs(int u, vector&lt;int&gt; &amp;dict, vector&lt;int&gt; &amp;parent, vector&lt;vector&lt;int&gt;&gt; &amp;edgesDict){        for(auto &amp;e : edgesDict[u]){            if(dict[e] &lt; 0){                dict[e] = dict[u] + 1;                parent[e] = u;                dfs(e, dict, parent, edgesDict);            }        }    }};解法3：拓扑排序class Solution {public:    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        if (n == 1)        {            return {0};        }        vector&lt;int&gt; res;        vector&lt;vector&lt;int&gt;&gt; edgesDict(n, vector&lt;int&gt;());        vector&lt;int&gt; indegree(n, 0);        for(auto &amp;e : edges){            edgesDict[e[0]].emplace_back(e[1]);            edgesDict[e[1]].emplace_back(e[0]);            indegree[e[0]]++;            indegree[e[1]]++;        }        queue&lt;int&gt; qu;        for(int i = 0 ; i &lt; n ; i++){            if(indegree[i] == 1){                qu.push(i);            }        }                while(!qu.empty()){            res.clear();            int k = qu.size();            n -= k;            while(k--){                int t = qu.front();                qu.pop();                res.emplace_back(t);                indegree[t] = 0;                for(auto &amp;e : edgesDict[t]){                    if(indegree[e] != 0){                        indegree[e]--;                        if(indegree[e] == 1){                            qu.push(e);                        }                    }                }            }        }        return res;    }};Reference[1] 最小高度树"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_4",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_4/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-13 11:21:00 +0800",
    





    
    "snippet": "POSIX信号量  本节介绍了POSIX信号量的相关API，包括初始化信号量、销毁信号量、等待信号量、请求信号量。POSIX信号量在Linux中，信号量API有两组：一组是System V IPC信号量，另一组是POSIX信号量。这两组信号量接口相似，语义也相同。sem_init下面是sem_init函数，功能是初始化一个未命名的信号量，其定义如下：#include &lt;semaphor...",
    "content": "POSIX信号量  本节介绍了POSIX信号量的相关API，包括初始化信号量、销毁信号量、等待信号量、请求信号量。POSIX信号量在Linux中，信号量API有两组：一组是System V IPC信号量，另一组是POSIX信号量。这两组信号量接口相似，语义也相同。sem_init下面是sem_init函数，功能是初始化一个未命名的信号量，其定义如下：#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);参数和返回值：  sem: 信号量标识符  pshared: 指定信号量的类型          如果值为0，表示这个信号量是当前线程的局部信号量      如果值非0，表示这个信号量可以在多个进程之间共享        value: 指定信号量的初始值  返回值: 成功返回0，失败返回-1并设置errno注意：初始化一个已经初始化的信号量会导致不可预期的结果。sem_destroy下面是sem_destroy函数，功能是销毁信号量，释放其占用的内核资源，其定义如下：#include &lt;semaphore.h&gt;int sem_destroy(sem_t *sem);参数和返回值：  sem: 信号量标识符  返回值: 成功返回0，失败返回-1并设置errno注意：如果销毁了一个正在被其他线程等待的信号量，会导致不可预期的结果。sem_wait下面是sem_wait函数，功能是以原子操作的方式将信号量的值减1，其定义如下：#include &lt;semaphore.h&gt;int sem_wait(sem_t *sem);参数和返回值：  sem: 信号量标识符  返回值: 成功返回0，失败返回-1并设置errno如果信号量的值为0，则sem_wait会被阻塞，直到这个信号量具有非0值。sem_trywait下面是sem_trywait函数，功能是以原子操作的方式将信号量的值减1，如果信号量为0会立即返回，其定义如下：#include &lt;semaphore.h&gt;int sem_trywait(sem_t *sem);参数和返回值：  sem: 信号量标识符  返回值: 成功返回0，失败返回-1并设置errno当信号量的值为0，则sem_trywait不会被阻塞，而是返回-1并设置errno为EAGAIN。当信号量的值非0，则执行减1操作。sem_post下面是sem_post函数，功能是以原子操作的方式将信号量的值加1，其定义如下：#include &lt;semaphore.h&gt;int sem_post(sem_t *sem);参数和返回值：  sem: 信号量标识符  返回值: 成功返回0，失败返回-1并设置errno当信号量的值大于0时，其他正在调用sem_wait等待信号量的线程会被唤醒。总结      Linux中提供了sem_init函数，功能是初始化一个未命名的信号量    Linux中提供了sem_destroy函数，功能是销毁信号量，释放其占用的内核资源    Linux中提供了sem_wait函数，功能是以原子操作的方式将信号量的值减1    Linux中提供了sem_trywait函数，功能是以原子操作的方式将信号量的值减1，如果信号量为0会立即返回    Linux中提供了sem_post函数，功能是以原子操作的方式将信号量的值加1  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_3",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-13 10:09:00 +0800",
    





    
    "snippet": "线程属性  本节探讨了线程属性，线程的属性通过pthread_attr_t结构体来表示，其内部通过一个字符数组来存储线程属性。此外，线程库还定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程。最后我们探讨了每个线程属性的具体含义。线程属性pthread_attr_t结构体定义了一套完整的线程属性，定义如下：#include &lt;bits/pthread...",
    "content": "线程属性  本节探讨了线程属性，线程的属性通过pthread_attr_t结构体来表示，其内部通过一个字符数组来存储线程属性。此外，线程库还定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程。最后我们探讨了每个线程属性的具体含义。线程属性pthread_attr_t结构体定义了一套完整的线程属性，定义如下：#include &lt;bits/pthreadtypes.h&gt;#define __SIZEOF_PTHREAD_ATTR_T 36typedef union{  char __size[__SIZEOF_PTHREAD_ATTR_T];  long int __align;} pthread_attr_t;所有线程属性都包含在字符数组__size中。此外，线程库还定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程。这些函数包括：#include &lt;pthread.h&gt;//  初始化线程属性对象int pthread_attr_init(pthread_attr_t *attr);//  销毁线程属性对象，被销毁的线程属性对象只有再次初始化后才能继续使用int pthread_attr_destroy(pthread_attr_t *attr);//  获取和设置线程属性对象的某个属性int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);int pthread_atte_setdetachstate(pthread_attr_t *attr, int detachstate);int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr);int pthread_atte_setstackaddr(pthread_attr_t *attr, void *stackaddr);int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);int pthread_atte_setstacksize(pthread_attr_t *attr, size_t stacksize);int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize);int pthread_atte_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);int pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize);int pthread_atte_setguardsize(pthread_attr_t *attr, size_t guardsize);int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *schedparam);int pthread_atte_setschedparam(pthread_attr_t *attr, const struct sched_param *schedparam);int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);int pthread_atte_setschedpolicy(pthread_attr_t *attr, int policy);int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit);int pthread_atte_setinheritsched(pthread_attr_t *attr, int inherit);int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);int pthread_atte_setscope(pthread_attr_t *attr, int scope);下面是每个线程属性的具体含义：  detachstate该属性描述线程的脱离状态，有两个可选值：  THREAD_CREATE_JOINABLE: 设置线程是可被回收的(默认值)  THREAD_CREATE_DETACH: 设置线程脱离(与pthread_detach函数作用相同)脱离了其他线程同步的线程称为脱离线程，脱离线程在退出时会自行释放其占用的系统资源。  stackaddr和stacksize该属性描述线程堆栈的起始地址和大小。一般而言，Linux默认为每个线程分配了足够的堆栈空间(一般是8MB，可以通过ulimit -s命令查看或修改)，所以不需要我们手动管理线程堆栈。  guardsize该属性描述线程的保护区域大小。  如果guardsize大于0，则系统创建线程的时候会在其堆栈的尾部额外分配guardsize字节的空间，作为保护堆栈不被错误地覆盖的区域。  如果guardsize等于0，则系统不会为新创建的线程设置堆栈保护区。  如果使用者通过pthread_attr_setstackaddr和pthread_attr_setstack函数手动设置堆栈线程，则guardsize属性会被忽略。  schedparam该属性描述线程调度参数，其类型是sched_param结构体，该结构体目前只有一个整型类型的成员：sched_priority，表示线程的允许优先级。  schedpolicy该属性描述线程调度策略，有三个可选值：  SCHED_OTHER: 默认值  SCHED_RR: 表示采用轮转算法(round-robin)调度  SCHED_FIFO: 表示采用先进先出算法调度其中，SCHED_RR和SCHED_FIFO调度方法具备实时调度功能，但只能用于以超级用户身份运行的进程。  inheritsched该属性描述是否继承调用线程的调度属性，有两个可选值：  PTHREAD_INHERIT_SCHED: 表示新线程沿用其创建者的线程调度参数，这种情况下再设置新线程的调度参数属性将没有任何效果  PTHREAD_EXPLICIT_SCHED: 表示调用者要明确地指定新线程的调度参数  scope该属性描述线程间竞争CPU的范围，即线程优先级的有效范围。POSIX标准定义了该属性有两个可选值：  PTHREAD_SCOPE_SYSTEM: 目标线程和系统中所有的线程一起竞争CPU的使用  PTHREAD_SCOPE_PROCESS: 目标线程仅与其他隶属于同一进程的线程竞争CPU的使用目前Linux只支持PTHREAD_SCOPE_SYSTEM这一种取值。总结      pthread_attr_t结构体定义了一套完整的线程属性    线程库还定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_2",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-12 15:59:00 +0800",
    





    
    "snippet": "pthread_create/pthread_exit/pthread_join/pthread_cancel  本节介绍了关于线程创建和结束的一些函数。pthread_create函数可以创建一个线程，pthread_exit函数可以主动退出当前线程，pthread_join函数等待并回收目标线程，pthread_cancel函数可以取消目标线程，pthread_setcancelstat...",
    "content": "pthread_create/pthread_exit/pthread_join/pthread_cancel  本节介绍了关于线程创建和结束的一些函数。pthread_create函数可以创建一个线程，pthread_exit函数可以主动退出当前线程，pthread_join函数等待并回收目标线程，pthread_cancel函数可以取消目标线程，pthread_setcancelstate和pthread_setcanceltype的函数可以设置目标线程是否允许被取消以及被如何取消。pthread_createLinux中提供了pthread_create函数来创建一个线程，该函数定义在pthread.h头文件中。下面是pthread_create的函数，功能是创建一个线程，其定义如下：#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void*(*start_routine)(void*), void*arg);参数和返回值：  thread: 新线程的标识符  attr: 用于设置新线程的属性，如果设NULL则表示使用默认线程属性  start_routine: 指定新线程将执行的函数  arg: 指定新线程执行函数的参数  返回值: 成功返回0，失败返回错误码线程标识符thread的类型结构pthread_t的定义如下：#include &lt;bits/pthreadtypes.h&gt;//\tpthread_t是一个整型，实际上Linux中几乎所有的资源标识符都是整型，比如socket、System V IPC标识符等typedef unsigned long int pthread_t;  一个用户可以打开的线程数量不能超过RLIMIT_NPROC软件资源限制。所有用户能创建的线程总数也不能超过/proc/sys/kernel/threads-max内核参数定义的值。pthread_exit线程一旦创建好，就会执行start_routine函数指针锁指向的函数。线程函数在结束时最好调用pthread_exit函数来安全、干净地退出。下面是pthread_exit的函数，功能是退出工作线程，其定义如下：#include &lt;pthread.h&gt;void pthread_exit(void *retval);参数和返回值：  retval: 像线程的回收者传递其退出信息pthread_exit函数没有返回值，它执行完后也不会返回到调用者，而且永远不会失败。pthread_join一个进程中的所有线程都可以调用pthread_join函数来回收其他线程(前提是目标线程可回收)，即等待其他线程结束。下面是pthread_join的函数，功能是等待目标线程结束并回收目标线程，其定义如下：#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);参数和返回值：  thread: 目标线程的标识符  retval: 接受目标线程返回的退出信息  返回值: 成功返回0，失败返回错误码pthread_join函数会一直阻塞，直到被回收的线程结束为止。pthread_join返回值可能引发的错误码如下表所示：            错误码      描述                  EDEADLK      可能引起死锁，比如两个线程互相针对对方调用pthread_join，活线程对自身调用pthread_join              EINVAL      目标线程是不可回收的，或者已经有其他线程在回收该目标线程              ESRCH      目标线程不存在      pthread_cancel有时候我们希望异常终止一个线程，我们可以通过pthread_cancel函数实现。下面是pthread_cancel的函数，功能是异常终止目标线程，其定义如下：#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);参数和返回值：  thread: 目标线程的标识符  返回值: 成功返回0，失败返回错误码不过，接收到终止请求的目标线程可以决定是否允许被取消以及如何取消。下面是pthread_setcancelstate和pthread_setcanceltype的函数，功能是设置目标线程是否允许被取消以及被如何取消，其定义如下：#include &lt;pthread.h&gt;int pthread_setcancelstate(int state, int *oldstate);int pthread_setcanceltype(int type, int *oldtype);参数和返回值：  state: 设置线程的取消状态(是否允许取消)，有以下可选值：          PTHREAD_CANCEL_ENABLE: 允许线程被取消，默认值      PTHREAD_CNACEL_DISABLE: 禁止线程被取消。当线程收到取消请求，该请求会被挂起，直到线程允许被取消为止        oldstate: 记录原来的取消状态  type: 设置线程的取消类型(如何取消)，有以下可选值：          PTHREAD_CANCEL_ASYNCHRONOUS: 线程随时可以被取消，收到取消请求的目标线程会立即采取行动      PTHREAD_CANCEL_DEFERRED: 允许目标线程推迟行动，直到它调用了取消点函数(pthread_join、thread_testcancel、pthread_cond_wait、pthread_cond_timedwait、sem_wait、sigwait)。根据POSIX标准，其他可能阻塞的系统调用read、wait也可能称为取消点。不过为了安全起见，一般在可能被取消的函数调用pthread_testcancel函数以设置取消点        oldtype:记录原来的取消类型  返回值: 成功返回0，失败返回错误码总结      Linux中提供了pthread_create的函数，功能是创建一个线程    Linux中提供了pthread_exit的函数，功能是退出工作线程    Linux中提供了pthread_join的函数，功能是等待目标线程结束并回收目标线程    Linux中提供了pthread_cancel的函数，功能是异常终止目标线程    Linux中提供了pthread_setcancelstate和pthread_setcanceltype的函数，功能是指定设置是否允许被取消以及被如何取消  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多线程编程_1",
    "url": "/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pthread",
    "date": "2023-07-12 10:25:00 +0800",
    





    
    "snippet": "线程模型/线程库  本节简单介绍了关于线程的一些知识。线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体。线程分为内核线程和用户线程，内核线程是内核调度的，用户线程是运行在用户空间，由线程库调度的。早期内核对线程的支持还不完备，所以早期的线程库LinuxPthreads通过进程模拟线程的方式来实现，并且引入管理线程机制来对工作线程进行管理，但这种方式容易引起语义问题，也不能利用多处...",
    "content": "线程模型/线程库  本节简单介绍了关于线程的一些知识。线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体。线程分为内核线程和用户线程，内核线程是内核调度的，用户线程是运行在用户空间，由线程库调度的。早期内核对线程的支持还不完备，所以早期的线程库LinuxPthreads通过进程模拟线程的方式来实现，并且引入管理线程机制来对工作线程进行管理，但这种方式容易引起语义问题，也不能利用多处理器的优势。随着内核完善，NPTL线程库应运而生，由内核负责线程的创建、结束、调度以及堆栈回收，效率更高，而且能有效利用多处理器的资源。线程模型线程：线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境和调度者身份，可以分为内核线程和用户线程。  内核线程: 运行在内核空间，由内核调度，在某些系统上也称为LWP(Light Weight Process, 轻量级进程)  用户线程: 运行在用户空间，由线程库调度当一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。所以，内核线程相对于用户线程运行的容器。一个进程可以拥有M个内核线程和N个用户线程，其中M &lt;= N。在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可以分为三种：  完全在用户空间实现这种实现方式无须内核的支持，由线程库来管理所有的执行线程(包括线程的优先级、时间片)。线程库利用longjmp来切换线程的执行，使他们看起来像“并发执行”。但本质上是内核把整个进程作为最小单位来调度。因此，这种实现方式满足N=1，即M个用户空间线程对应1个内核线程，该内核线程就是进程本身。早期的伯克利UNIX线程就是采用这种方法实现的。  优点: 创建和调度线程无须内核干预，速度快，不占用额外的内核资源，所以即使一个进程创建了很多线程也不会对系统性能造成明显影响。  缺点: 对于多处理器系统，因为内核是按照最小调度单位进程来分配CPU的，所以多个线程无法运行在多个CPU上。此外，线程的优先级只对同一个进程中的线程有效，不同进程的线程之间无法比较优先级。  完全由内核调度这种实现方式将创建、调度线程的任务都交给了内核，运行在用户空间的线程无须执行管理任务。这种实现方式满足M:N = 1:1，即一个用户空间线程被映射为一个内核线程。  优点: 多个线程可以运行在多个CPU上，而且不同进程的线程之间可以设置优先级。  缺点: 创建和调度线程需要内核干预，速度较慢，需要占用额外的内核资源，所以创建了过多的线程会影响系统性能。  双层调度(two level scheduler)前两种实现模式的混合：内核调度M个内核线程，线程库调度N个用户线程。  优点: 综合了两者的优点，不但不会过多消耗内核资源，而且线程切换速度也较快，同时还能充分利用多处理器的优势。Linux线程库Linux上有两个最出名的线程库：LinuxThreads和NPTL。它们都是采用M:N = 1:1的方式实现的。LinuxThreadsLinuxThreads在开发时，Linux内核对线程的支持非常有限，所以其可用性、稳定性以及对POSIX兼容性都远不如NPTL。LinuxThreads的线程库内核线程是通过子进程来实现的，LinuxThreads通过clone系统调用(和fork功能类似)，创建子进程，并且为clone系统调用指定CLONE_THREAD标志。这种情况下，clone创建的子进程与调用进程共享相同的虚拟地址空间、文件描述符和信号处理函数，这些都是线程的特点。不过用进程来模拟线程也会导致很多语义问题：  每个线程拥有不同的PID，不符合POSIX规范  Linux信号处理是基于进程的，但是现在每个线程都必须处理信号  同个进程创建的线程的用户ID、组ID来说可能不一样  程序产生和核心转储文件不会包含所有线程的信息，只包含产生该核心转储文件的线程的信息  每个线程都是一个进程，因此系统允许的最大线程数会变成最大进程数LinuxThreads中有一个著名的特性：管理线程。管理线程是专门管理其他工作线程的线程，其作用包括：  系统发送给进程的终止信号先由管理线程接收，管理线程再给其他工作线程发送同样的信号以终止它们  当终止工作线程或者工作线程主动退出时，管理线程必须等待它们结束，以避免僵尸进程  如果主线程先于其他工作线程退出，则管理线程将阻塞它，直到所有工作线程都结束之后裁唤醒它  回收每个线程堆栈使用的内存管理线程的引入，增加了额外的系统开销，并且由于它只能运行在一个CPU上，所以LinuxThreads线程库不能充分发挥多处理器系统的优势。NPTLNPTL是现代Linux默认使用的线程库。用户可以通过如下命令来查看当前系统所使用的线程库：$ getconf GNU_LIBPTHREAD_VERSIONNPTL 2.27随着软硬件发展，内核提供了更完善的线程支持。自Linux内核2.6开始，提供了真正的内核线程。新的NPTL也因此应运而生。相比LinuxThreads，NPTL的优势在于：  内核线程不再是一个进程，避免了很多语义问题  摒弃了管理线程，终止线程、回收堆栈等工作都可以由内核来完成  一个进程的线程可以运行在不同的CPU上，充分发挥多处理器系统的优势  线程的同步由内核完成。不同进程的线程之间也可以共享互斥锁，实现跨进程的线程同步总结      线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体    根据运行环境和调度者身份，可以分为内核线程和用户线程    内核线程是运行在内核空间，由内核调度的线程    用户线程是运行在用户空间，由线程库调度的线程    一个进程可以拥有M个内核线程和N个用户线程，按照M:N的取值，线程的实现方式可以分为三种：完全在用户空间实现、完全由内核调度、双层调度    Linux上有两个最出名的线程库：LinuxThreads和NPTL  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  序列化和反序列化二叉搜索树",
    "url": "/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2/",
    "categories": "leetcode",
    "tags": "leetcode, BFS, DFS, Binary Search Tree",
    "date": "2023-07-11 15:16:00 +0800",
    





    
    "snippet": "BFS/DFS  该题要求对二叉搜索树序列化，难点在于序列化后的字符串要求尽量紧凑，这需要运用二叉搜索树的性质，同时反序列化的过程中同样运用二叉搜索树的性质进行还原。题目序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作...",
    "content": "BFS/DFS  该题要求对二叉搜索树序列化，难点在于序列化后的字符串要求尽量紧凑，这需要运用二叉搜索树的性质，同时反序列化的过程中同样运用二叉搜索树的性质进行还原。题目序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。编码的字符串应尽可能紧凑。例子示例1输入：root = [2,1,3]输出：[2,1,3]示例2输入：root = []输出：[]条件  树中节点数范围是 [0, 10^4]  0 &lt;= Node.val &lt;= 10^4  题目数据 保证 输入的树是一棵二叉搜索树。难点分析该题做法很多，我们总结以下几种解法：  BFSBFS即对二叉搜索树进行层序遍历，得到层序序列。得到字符串后，反过来通过层序遍历进行还原。但该方法适配所有二叉树，但没有运用二叉搜索树的特性。  DFSDFS即对二叉搜索树进行中序遍历(也可以使用前序和后序遍历)，得到中序序列。得到字符串后，反过来通过递归进行还原。但该方法适配所有二叉树，但没有运用二叉搜索树的特性。  DFS + 二分查找我们同样采用DFS的方式对二叉搜索树进行序列化，由于二叉搜索树的特性，我们只要中序序列就能还原一颗完整的树，即不需要存储空结点。反序列的过程中，我们将第一结点作为根节点root，然后找出小于root值的结点集合以及大于root值的结点集合，然后递归构造二叉搜索树。  DFS + 队列我们同样采用DFS的方式对二叉搜索树进行序列化，且不存储空结点。反序列的过程中，我们先解析所有的结点值，然后存储在队列中。接着同样递归构造二叉搜索树，相比上一种方法，我们不需要划分为两部分，只需要判断左子树是否小于父结点的值或右子树是否大于父节点的值，如果不满足二叉搜索树条件，则返回NULL，否则递归构造二叉搜索树。  DFS + 数组第五种方法是用数组和指针来代替队列的实现。解法解法1：BFSclass Codec {public:    int slen;    // Encodes a tree to a single string.    string serialize(TreeNode* root) {        if(root == NULL){ return \"#\"; }        queue&lt;TreeNode*&gt; qu;        qu.push(root);        string s = \"\";        while(!qu.empty()){            TreeNode *t = qu.front();            qu.pop();            s += \"#\";            if(t != NULL){                s += to_string(t-&gt;val);                qu.push(t-&gt;left);                qu.push(t-&gt;right);            }        }        return s;    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) {        if(data == \"#\"){return NULL;}        queue&lt;TreeNode *&gt; qu;        TreeNode* res = NULL;        const int n = data.size();        for(int i = 1 ; i &lt; n ; ){                        TreeNode *t = NULL;            if(!qu.empty()){                t = qu.front();                qu.pop();            }                        if(t == NULL){                res = getNode(data, i, n);                qu.push(res);            }else{                t-&gt;left = getNode(data, i, n);                t-&gt;right = getNode(data, i, n);                if(t-&gt;left) qu.push(t-&gt;left);                if(t-&gt;right) qu.push(t-&gt;right);            }        }        return res;    }    TreeNode *getNode(string &amp;data, int &amp;i, int n){        //  得到数字        int end = i;        while(end &lt; n &amp;&amp; data[end] != '#'){            end++;        }        if(end == i){            i = end + 1;            return NULL;        }else{            TreeNode * t = new TreeNode(std::atoi(data.substr(i, end - i).c_str()));            i = end + 1;            return t;        }    }};解法2：DFSclass Codec {public:    // Encodes a tree to a single string.    string serialize(TreeNode* root) {        string s;        dfs(root, s);        return s;    }    void dfs(TreeNode* root, string &amp;s){        if(root == NULL){            s += \"#\";            return;        }        s += to_string(root-&gt;val) + \"#\";        dfs(root-&gt;left, s);        dfs(root-&gt;right, s);    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) {        const int slen = data.size();        int idx = 0;        return dedfs(data, idx, slen);    }    TreeNode *dedfs(string &amp;data, int &amp;idx, const int slen){        if(idx &gt;= slen){            return NULL;        }        int end = idx;        while(data[end] != '#'){            end++;        }        if(idx == end){            idx++;            return NULL;        }        TreeNode *root = new TreeNode(std::atoi(data.substr(idx, end - idx).c_str()));        idx = end + 1;        root-&gt;left = dedfs(data, idx, slen);        root-&gt;right = dedfs(data, idx, slen);        return root;    }};解法3：DFS + 二分查找class Codec {public:    // Encodes a tree to a single string.    string serialize(TreeNode* root) {        string s;        dfs(root, s);        cout&lt;&lt;s&lt;&lt;endl;        return s;    }    void dfs(TreeNode* root, string &amp;s){        if(root == NULL){            return;        }        s += \"#\" + to_string(root-&gt;val);        dfs(root-&gt;left, s);        dfs(root-&gt;right, s);    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) {        if(data.size()==0){return NULL;}        vector&lt;int&gt; node;        const int n = data.size();        for(int i = 1 ; i &lt; n ; ){            int end = i;            while(end &lt; n &amp;&amp; data[end] != '#'){                end++;            }            node.emplace_back(std::atoi(data.substr(i, end - i).data()));            i = end + 1;            cout&lt;&lt;node.back()&lt;&lt;endl;        }        return deDfs(node, 0, node.size() - 1);    }    TreeNode *deDfs(vector&lt;int&gt; &amp;node, int l, int r){        TreeNode *t = new TreeNode(node[l]);        if(l &lt; r){            if(node[l + 1] &gt; node[l]){                //  t没有左结点                t-&gt;right = deDfs(node, l + 1, r);            }            else if(node[l] &gt; node[r]){                //  t没有右结点                t-&gt;left = deDfs(node, l + 1, r);            }else{                //  找出t的左右结点                int lt = l + 1, rt = r;                while(lt &lt; rt){                    int mid = (lt + rt) / 2;                    if(node[l] &gt; node[mid]){                        lt = mid + 1;                    }else{                        rt = mid;                    }                    if(lt == rt- 1){                        if(node[lt] &gt; node[l]){                            rt = lt;                            break;                        }                    }                }                t-&gt;left = deDfs(node, l + 1, rt - 1);                t-&gt;right = deDfs(node, rt, r);            }        }        return t;    }};解法4：DFS + 队列class Codec {public:    // Encodes a tree to a single string.    string serialize(TreeNode* root) {        string s;        dfs(root, s);        return s;    }    void dfs(TreeNode* root, string &amp;s){        if(root == NULL){            return;        }        s += \"#\" + to_string(root-&gt;val);        dfs(root-&gt;left, s);        dfs(root-&gt;right, s);    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) {        if(data.size()==0){return NULL;}        queue&lt;int&gt; node;        const int n = data.size();        for(int i = 1 ; i &lt; n ; ){            int end = i;            while(end &lt; n &amp;&amp; data[end] != '#'){                end++;            }            node.push(std::atoi(data.substr(i, end - i).data()));            i = end + 1;        }        return deDfs(node, -1, (int)1e5);    }    TreeNode *deDfs(queue&lt;int&gt; &amp;qu, int min, int max){        if(qu.empty() || qu.front() &gt;= max || qu.front() &lt;= min){            return NULL;        }        int val = qu.front();        qu.pop();        return new TreeNode(val, deDfs(qu, min, val), deDfs(qu, val, max));    }};解法5：DFS + 数组class Codec {public:    // Encodes a tree to a single string.    string serialize(TreeNode* root) {        string s;        dfs(root, s);        cout&lt;&lt;s&lt;&lt;endl;        return s;    }    void dfs(TreeNode* root, string &amp;s){        if(root == NULL){            return;        }        s += \"#\" + to_string(root-&gt;val);        dfs(root-&gt;left, s);        dfs(root-&gt;right, s);    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) {        if(data.size()==0){return NULL;}        vector&lt;int&gt; node;        const int n = data.size();        for(int i = 1 ; i &lt; n ; ){            int end = i;            while(end &lt; n &amp;&amp; data[end] != '#'){                end++;            }            node.emplace_back(std::atoi(data.substr(i, end - i).data()));            i = end + 1;            cout&lt;&lt;node.back()&lt;&lt;endl;        }        int idx = 0;        return deDfs(node, -1, (int)1e5, idx);    }    TreeNode *deDfs(vector&lt;int&gt; &amp;node, int min, int max, int &amp;idx){        if(idx == node.size() || node[idx] &gt;= max || node[idx] &lt;= min){            return NULL;        }        int val = node[idx++];        return new TreeNode(val, deDfs(node, min, val, idx), deDfs(node, val, max, idx));    }};Reference[1] 序列化和反序列化二叉搜索树"
  },
  
  {
    "title": "读书笔记 —— Libevent源码分析_5",
    "url": "/posts/Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_5/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Libevent",
    "date": "2023-07-09 17:09:00 +0800",
    





    
    "snippet": "event_base_loop  本节探究了Libevent中事件循环的源码，事件循环是指对一个就绪事件调用对应的事件处理器中的回调函数。Libevent中实现事件循环的函数是event_base_loop。event_base_loop事件循环是指对一个就绪事件调用对应的事件处理器中的回调函数。Libevent中实现事件循环的函数是event_base_loop。event_base_lo...",
    "content": "event_base_loop  本节探究了Libevent中事件循环的源码，事件循环是指对一个就绪事件调用对应的事件处理器中的回调函数。Libevent中实现事件循环的函数是event_base_loop。event_base_loop事件循环是指对一个就绪事件调用对应的事件处理器中的回调函数。Libevent中实现事件循环的函数是event_base_loop。event_base_loop函数的源码如下：int event_base_loop(struct event_base *base, int flags){\tconst struct eventop *evsel = base-&gt;evsel;\tstruct timeval tv;\tstruct timeval *tv_p;\tint res, done, retval = 0;\t//\t一个event_base仅允许运行一个事件循环，避免存在某些资源的竞争\tEVBASE_ACQUIRE_LOCK(base, th_base_lock); //\t获得锁\tif(base-&gt;running_loop){\t\tevent_warnx(\"%s: reentrant invocation. Only one event_base_loop can run on each event_base at once.\", __func__);\t\tEVBASE_RELEASE_LOCK(base, th_base_lock); //\t释放锁\t\treturn -1;\t}\tbase-&gt;running_loop = 1;\t//\t标记该event_base已经开始运行\tclear_time_cache(base);\t//\t清除event_base的系统时间缓存\t//\t设置信号事件的event_base实例\tif(base-&gt;sig.ev_signal_added &amp;&amp; base-&gt;sig.ev_n_signals_added)\t\tevsig_set_base(base);\tdone = 0;#ifndef _EVENT_DISABLE_THREAD_SUPPORT\tbase-&gt;th_owner_id = EVTHREAD_GET_ID();#endif\tbase-&gt;event_gotterm = base-&gt;event_break = 0;\twhile(!done){\t\tbase-&gt;event_continue = 0;\t\tif(base-&gt;event_gotterm){\t\t\tbreak;\t\t}\t\tif(base-&gt;event_break){\t\t\tbreak;\t\t}\t\ttimeout_correct(base, &amp;tv);\t//\t校准系统时间\t\ttv_p = &amp;tv;\t\tif(!N_ACTIVE_CALLBACKS(base) &amp;&amp; \t\t\t!(flags &amp; EVLOOP_NONBLOCK)){\t\t\t//\t获取时间堆上的堆顶元素的超时值，即IO复用系统调用本次应该设置的超时值\t\t\ttimeout_next(base, &amp;tv_p);\t\t}else{\t\t\t//\t如果有就绪时间尚未处理，则将IO复用系统调用的超时值置0\t\t\t//\t这样IO复用系统调用直接返回，程序也就可以立即处理就绪事件了\t\t\tevutil_timerclear(&amp;tv);\t\t}\t\t//\t如果event_base中没有任何注册事件，则直接退出事件循环\t\tif(!event_haveevents(base) &amp;&amp; !N_ACTIVE_CALLBACKS(base)){\t\t\tevent_debug((\"%s: no events registered.\", __func__));\t\t\tretval = 1;\t\t\tgoto done;\t\t}\t\t//\t更新系统事件，并清空时间缓存\t\tgettime(base, &amp;base-&gt;event_tv);\t\tclear_time_cache(base);\t\t//\t调用事件多路分发器的dispatch方法等待事件，将就绪事件插入活动队列\t\tres = evsel-&gt;dispatch(base, tv_p);\t\tif(res == -1){\t\t\tevent_debug((\"%s: dispatch return ed unsuccessfully.\", __func__));\t\t\tretval = -1;\t\t\tgoto done;\t\t}\t\tupdate_time_cache(base);\t//\t将时间缓存更新为当前系统时间\t\t//\t检查时间堆上的到期事件并依次执行\t\ttimeout_process(base);\t\tif(N_ACTIVE_CALLBACKS(base)){\t\t\t//\t调用event_process_active函数依次处理就绪的信号事件和IO事件\t\t\tint n = event_process_active(base);\t\t\tif((flags &amp; EVLOOP_ONCE) &amp;&amp;\t\t\t\tN_ACTIVE_CALLBACKS(base) == 0 &amp;&amp;\t\t\t\tn != 0)\t\t\t\tdone = 1;\t\t}else if(flags &amp; EVLOOP_NONBLOCK)\t\t\tdone = 1;\t}\tevent_debug((\"%s: asked to terminate loop.\", __func__));done:\t//\t事件循环结束，清空时间缓存，并设置停止循环标志\tclear_time_cache(base);\tbase-&gt;running_loop = 0;\tEVBASE_RELEASE_LOCK(base, th_base_lock);\treturn retval;};我们总结event_base_loop的过程：  判断当前event_base是否已经运行事件循环，若没有运行则标记当前event_base开始运行事件循环  设置信号处理函数和事件多路分发器之间的通信管道  循环监听等待事件并处理，包括以下步骤          判断是否退出事件循环      检测是否有就绪事件未处理，如果有则修改超时时间使IO复用系统调用直接返回      判断当前event_base是否还有注册任何事件，若没有直接退出循环      调用事件多路分发器的dispatch方法等待事件，将就绪事件插入活动队列      检查时间堆上的到期事件并依次执行      处理就绪的信号事件和IO事件        清空时间缓存，并设置停止循环标志总结      事件循环是指对一个就绪事件调用对应的事件处理器中的回调函数，Libevent中实现事件循环的函数是event_base_loop  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— Libevent源码分析_4",
    "url": "/posts/Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_4/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Libevent",
    "date": "2023-07-09 14:56:00 +0800",
    





    
    "snippet": "eventop/event_base  本节介绍了Libevent中两个重要的结构体。第一个是eventop结构体，它封装了IO复用机制的一些必要操作，目的是为event_base提供统一的IO复用接口。Libevent会检测当前系统支持IO复用机制，如果存在多种支持的IO复用机制，则根据eventops数组中的优先级来选取。第二个是event_base结构体，它是Libevent的Reac...",
    "content": "eventop/event_base  本节介绍了Libevent中两个重要的结构体。第一个是eventop结构体，它封装了IO复用机制的一些必要操作，目的是为event_base提供统一的IO复用接口。Libevent会检测当前系统支持IO复用机制，如果存在多种支持的IO复用机制，则根据eventops数组中的优先级来选取。第二个是event_base结构体，它是Libevent的Reactor，存储各种事件队列、定时器队列、调度等信息。eventopeventop结构体封装了IO复用机制必要的一些操作，比如注册事件、等待事件等。它为event_base支持的所有后端IO复用机制提供一个统一的接口。eventop结构体定义在event-internal.h文件中。eventop结构体的定义如下：struct eventop{\t//\t后端IO复用技术的名称\tconst char *name;\t//\t初始化函数\tvoid *(*init)(struct event_base *);\t//\t注册事件\tint (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\t//\t删除事件\tint (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\t//\t等待事件\tint (*dispatch)(struct event_base *, struct timeval *);\t//\t释放IO复用机制所使用的资源\tvoid (*dealloc)(struct event_base *);\t//\t程序调用fork之后是否需要重新初始化event_base\tint need_reinit;\t/* IO复用技术支持的一些特性，可选如下3个值的按位或：\t\tEV_FEATURE_ET：支持边缘触发事件EV_ET\t\tEV_FEATURE_O1: 事件检测算法的事件复杂度是O(1)\t\tEV_FEATURE_FDS: 不仅能监听socket上的事件，还能监听其他类型的文件描述符上的事件 \t*/\tenum event_method_feature features;\t/* 有的IO复用机制需要为每个IO事件队列和信号事件队列分配额外的内存，以避免同一个文件描述符被重复插入IO复用机制的事件表中。\tevmap_io_add(或evmap_io_del)函数在调用eventop的add(或del)方法时，将这段内存的起始地址作为第五个参数传递给add(或del)方法。\t下面这个成员则指定了这段内存的长度 */\tsize_t fdinfo_len;};前面提到，devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c、epoll.c文件分别使用不同的IO复用技术实现了eventop定义的接口。而在支持多种IO复用技术的系统上，采用哪个IO复用技术取决于优先级。Libevent支持的后端IO复用技术及其优先级定义在event.c文件中，其定义如下：#ifdef _EVENT_HAVE_EVENT_PORTSextern const struct eventop evportops;#endif#ifdef _EVENT_HAVE_SELECTextern const struct eventop selectops;#endif#ifdef _EVENT_HAVE_POLLextern const struct eventop pollops;#endif#ifdef _EVENT_HAVE_EPOLLextern const struct eventop epollops;#endif#ifdef _EVENT_HAVE_WORKING_KQUEUEextern const struct eventop kqops;#endif#ifdef _EVENT_HAVE_DEVPOLLextern const struct eventop devpollops;#endif#ifdef WINextern const struct eventop win32ops;#endifstatic const struct eventop *eventops[] = {#ifdef _EVENT_HAVE_EVENT_PORTS\t&amp;evportops,#endif#ifdef _EVENT_HAVE_WORKING_KQUEUE\t&amp;kqops,#endif#ifdef _EVENT_HAVE_EPOLL\t&amp;epollops,#endif#ifdef _EVENT_HAVE_DEVPOLL\t&amp;devpollops,#endif#ifdef _EVENT_HAVE_POLL\t&amp;pollops,#endif#ifdef _EVENT_HAVE_SELECT\t&amp;selectops,#endif#ifdef WIN32\t&amp;win32ops,#endif\tNULL};Libevent通过遍历evnetops数组来选择后端IO复用技术。所以在Linux中，优先选择的IO复用技术是epoll。event_base结构体结构体event_base是Libevent的Reactor，它定义在event-internal.h文件中。event_base结构体的源码如下：struct event_base {\t//\t记录在初始化Reactor的时候选择的后端IO复用机制\tconst struct eventop *evsel;\t//\t指向IO复用机制真正存储的数据，它通过evsel成员的init函数来初始化\tvoid *evbase;\t//\t事件变化队列，如果一个文件描述符上的注册事件被多次修改，可以使用缓冲来避免重复的系统调用(比如epoll_ctl)。它仅能用于时间复杂度为O(1)的IO复用技术\tstruct event_changelist changelist;\t//\t指向信号的后端处理机制，目前仅在signal.h文件中定义了一种处理方法\tconst struct eventop *evsigsel;\t//\t信号事件处理器使用的数据结构，其中封装了一个由socketpair创建的管道。它用于信号处理函数和事件多路分发器之间的通信(即统一事件源)\tstruct evsig_info sig;\t//\t添加到该event_base的虚拟事件、所有事件和激活事件的数量\tint virtual_event_count;\tint event_count;\tint event_count_active;\t//\t是否执行完成活动事件队列上剩余的任务之后就退出事件循环\tint event_gotterm;\t//\t是否立即退出事件循环，而不管是否还有任务需要处理\tint event_break;\t//\t是否应该启动一个新的事件循环\tint event_continue;\t//\t目前正在处理的活动事件队列的优先级\tint event_running_priority;\t//\t事件循环是否已经启动\tint running_loop;\t//\t活动事件队列数组。索引值越小的队列，优先级越高\tstruct event_list *activequeues;\t//\t活动事件队列数组的大小，即该event_base一共有nactivequeues个不同优先级的活动事件队列\tint nactivequeues;\t//\t下面3个成员用于管理通用定时器队列\tstruct common_timeout_list **common_timeout_queues;\tint n_common_timeouts;\tint n_common_timeouts_allocated;\t//\t存放延迟调用函数的链表。事件循环每次成功处理完一个活动事件队列的所有事件后，就调用一次延迟回调函数\tstruct deffered_cb_queue defer_queue;\t//\t文件描述符和IO事件之间的映射关系表\tstruct event_io_map io;\t//\t信号值和信号事件至今啊的映射关系表\tstruct event_signal_map sigmap;\t//\t注册事件队列，存放IO事件处理器和信号事件处理器\tstruct event_list eventqueue;\t//\t时间堆\tstruct min_heap timeheap;\t//\t管理系统时间的一些成员\tstruct timeval event_tv;\tstruct timeval tv_cache;#if defined(_EVENT_HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)\tstruct timeval tv_clock_diff;\ttime_t last_updated_clock_diff;#endif\t//\t多线程支持#ifndef _EVENT_DISABLE_THREAD_SUPPORT\tunsigned long th_owner_id;\t//\t当前运行该event_base的事件循环的线程\tvoid *th_base_lock;\t\t\t//\t对event_base的独占锁\t//\t当前事件循环正在执行哪个事件处理器的回调函数\tstruct event *current_event;\t//\t条件变量，用于唤醒正在等待某个事件处理完毕的线程\tvoid *current_event_cond;\tint current_event_waiters;\t//\t等待current_event_cond的线程数#endif#ifdef WIN32\tstruct event_iocp_port *iocp;#endif\t//\tevent_base的一些配置参数\tenum event_base_config_flag flags;\t//\t下面这组成员变量给工作线程唤醒主线程提供了方法(使用socketpair创建的管道)\tint is_nofify_pending;\tevutil_socket_t th_notify_fd[2];\tstruct event th_notify;\tint (*th_notify_fn)(struct event_base *base);};总结      eventop结构体封装了IO复用机制必要的一些操作，它为event_base支持的所有后端IO复用机制提供一个统一的接口    Libevent支持的后端IO复用技术及其优先级定义在event.c文件中    Libevent通过遍历evnetops数组来选择后端IO复用技术。在Linux中，优先选择的IO复用技术是epoll    结构体event_base是Libevent的Reactor，它定义在event-internal.h文件中  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— Libevent源码分析_3",
    "url": "/posts/Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Libevent",
    "date": "2023-07-08 14:48:00 +0800",
    





    
    "snippet": "event_add_internal/event_queue_insert/evmap_io_add  本节介绍了Libevent的几个核心函数。首先，event_add函数将event对象添加到注册事件队列中，并将对应的事件注册到事件多路分发器上，主要通过event_add_internal内部函数实现。event_queue_insert函数将事件处理器添加到各种事件队列中。evmap_...",
    "content": "event_add_internal/event_queue_insert/evmap_io_add  本节介绍了Libevent的几个核心函数。首先，event_add函数将event对象添加到注册事件队列中，并将对应的事件注册到事件多路分发器上，主要通过event_add_internal内部函数实现。event_queue_insert函数将事件处理器添加到各种事件队列中。evmap_io_add和evmap_signal_add函数令事件多路分发器监听对应的事件，同时建立文件描述符、信号值与事件处理器之间的映射关系。event_new前面的实例(Libevent源码分析_1)中提到event_new函数的作用的创建一个event对象，该函数位于event.c文件中。event_new函数的实现主要是为event对象分配内存并初始化部分成员，实现相对简单，这里不做讨论。event_add_internalevent对象创建好之后，应用程序需要调用event_add函数将event对象添加到注册事件队列中，并将对应的事件注册到事件多路分发器上。event_add函数同样位于event.c文件中，主要调用另一个内部函数event_add_internal。event_add_internal的源码如下：static inline int event_add_internal(struct event *ev, const struct timeval *tv, int tv_is_absolute){\tstruct event_base *base = ev-&gt;base;\tint res = 0;\tint notify = 0;\t//\t对base和ev进行一些调试检测\tEVENT_BASE_ASSERT_LOCKED(base);\t_event_debug_assert_is_setup(ev);\tevent_debug((\t\t\"event_add: event : %p (fd %d), %s%s%scall %p\",\t\tev, \t\t(int)ev-&gt;ev_fd,\t\tev-&gt;ev_events &amp; EV_READ ? \"EV_READ\" : \" \",\t\tev-&gt;ev_events &amp; EV_WRITE ? \"EV_WRITE\" : \" \",\t\ttv ? \"EV_TIMEOUT\" : \" \",\t\tev-&gt;ev_calllback));\tEVUTIL_ASSERT(!(ev-&gt;ev_flags &amp; ~EVLIST_ALL));\t//\t如果新添加的事件处理器是定时器，且它尚未被添加到通用定时器队列或时间堆中\t//\t则为该定时器在时间堆上预留一个位置(min_heap_reserve函数作用是扩容)\tif(tv != NULL &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)){\t\tif(min_heap_reserve(&amp;base-&gt;timeheap, 1 + min_heap_size(&amp;base-&gt;timeheap)) == -1)\t\t\t\treturn -1;\t}\t\t//\t如果当前调用者不是主线程(执行事件循环的线程)，并且被添加的事件处理器是信号事件处理器，而且主线程正在执行该信号事件处理器的回调函数\t//\t则当前调用者必须等待主线程完成调用，否则将引起竞态条件(考虑event结构体的ev_ncalls和ev_pncalls成员)\t#ifndef _EVENT_DISABLE_THREAD_SUPPORT\t\tif(base-&gt;current_event == ev &amp;&amp; (ev-&gt;ev_events &amp; EV_SIGNAL)\t\t&amp;&amp; !EVBASE_IN_THREAD(base)){\t\t\t++base-&gt;current_event_waiters;\t//\t等待事件+1\t\t\tEVTHREAD_COND_WAIT(base-&gt;current_event_cond, base-&gt;th_base_lock);\t//\t申请条件变量和互斥锁\t\t}\t#endif\t//\tev是IO事件处理器或信号事件处理器，且没有被插入注册事件队列或活动事件队列\t//\t则绑定事件和事件处理器的映射关系，并加入注册事件队列中\tif((ev-&gt;ev_events &amp; (EV_READ | EV_WRITE | EV_SIGNAL)) &amp;&amp;\t\t!ev-&gt;ev_flags &amp; (EVLIST_INSERTED | EVLIST_ACTIVE)){\t\t//\t添加IO事件和IO事件处理器的映射关系\t\tif(ev-&gt;ev_events &amp; (EV_READ | EV_WRITE))\t\t\tres = evmap_io_add(base, ev-&gt;ev_fd, ev);\t\t//\t添加信号事件和信号事件处理器的映射关系\t\telse if(ev-&gt;ev_events &amp; EV_SIGNAL)\t\t\tres = evmap_signal_add(base, (int)ev-&gt;ev_fd, ev);\t\t//\t将事件处理器插入注册队列\t\tif(res != -1)\t\t\tevent_queue_insert(base, ev, EVLIST_INSERTED);\t\t//\t事件多路分发器中添加了新的事件，所以要通知主线程\t\tif(res != -1){\t\t\tnotify = 1;\t\t\tres = 0;\t\t}\t}\t//\t将事件处理器添加到通用定时器队列或时间堆中\t//\t对于信号事件处理器和IO事件处理器，根据evmap_*_add函数的结果决定是否添加(这是为了给事件设置超时)\t//\t对于定时器，始终应该添加之\tif(res != -1 &amp;&amp; tv != NULL){\t\tstruct timeval now;\t\tint common_timeout;\t\t//\t对于永久性事件处理器，如果其超时事件不是绝对时间，则将该事件处理器的超时事件记录在变量ev-&gt;ev_io_timeout中。\t\t//\tev_io_timeout是定义在event-internal.h文件中的宏:\t\t//\t#define ev_io_timeout _ev.ev_io.ev_timeout\t\tif(ev-&gt;ev_closure == EV_CLOSURE_PERSIST &amp;&amp; !tv_is_absolute)\t\t\tev-&gt;ev_io_timeout = *tv;\t\t//\t如果该事件处理器已经被插入通用定时器队列或时间堆中，则先删除它\t\tif(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT){\t\t\tif(min_heap_elt_is_top(ev))\t\t\t\tnotify = 1;\t\t\tevent_queue_remove(base, ev, EVLIST_TIMEOUT);\t\t}\t\t//\t如果待添加的事件处理器被已经被激活，且原因是超时，则从活动事件队列中删除它，避免其回调函数被执行\t\t//\t对于信号事件处理器，必要时还需将其ev_ncalls成员设置为0(注意，ev_pncalls如果不为NULL，它指向ev_ncalls)\t\t//\tev_ncalls指定其回调函数被执行的次数，将ev_ncalls设置0，可以干净地终止信号事件的处理\t\tif((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp; (ev-&gt;ev_res &amp; EV_TIMEOUT)){\t\t\tif(ev-&gt;ev_events &amp; EV_SIGNAL){\t\t\t\tif(ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls){\t\t\t\t\t*ev-&gt;ev_pncalls = 0;\t\t\t\t}\t\t\t}\t\t\tevent_queue_remove(base, ev, EVLIST_ACTIVE);\t\t}\t\tgettime(base, &amp;now);\t\t//\tcommon_timeout用来判断定时器插入通用定时器队列还是时间堆\t\tcommon_timeout = is_common_timeout(tv, base);\t\tif(tv_is_absolute){\t\t\tev-&gt;ev_timeout = *tv;\t\t}\t\t//\t判断应该将定时器插入通用定时器队列还是时间堆\t\telse if(common_timeout){\t\t\tstruct timeval tmp = *tv;\t\t\ttmp.tv_usec &amp;= MICROSECONDS_MASK;\t\t\tevutil_timeradd(&amp;now, &amp;tmp, &amp;ev-&gt;ev_timeout);\t\t\tev-&gt;ev_timeout.tv_usec |= (tv-&gt;tv_usec &amp; ~MICROSECONDS_MASK);\t\t}\t\t//\t加上当前系统事件，取得定时器的超时绝对时间\t\telse{\t\t\tevutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout);\t\t}\t\tevent_debug((\"event_add: timeout in %d seconds, call %p\", (int)tv-&gt;tv_sec, ev-&gt;ev_callback));\t\t//\t插入定时器\t\tevent_queue_insert(base, ev, EVLIST_TIMEOUT);\t\t//\t如果被插入的事件处理器是通用定时器队列钟的第一个元素，则通过调用common_timeout_schedule函数将其转移到时间堆钟\t\t//\t这样通用定时器链表和时间堆钟的定时器就得到了统一的处理\t\tif(common_timeout){\t\t\tstruct common_timeout_list *ctl = \t\t\t\tget_common_timeout_list(base, &amp;ev-&gt;ev_timeout);\t\t\tif(ev == TAILQ_FIRST(&amp;ctl-&gt;events)){\t\t\t\tcommon_timeout_schedule(ctl, &amp;now, ev);\t\t\t}\t\t}else{\t\t\tif(min_heap_elt_is_top(ev))\t\t\t\tnotify = 1;\t\t}\t\t//\t如果必要，唤醒主线程\t\tif(res != -1 &amp;&amp; notify &amp;&amp; EVBASE_NEED_NOTIFY(base))\t\t\tevthread_notify_base(base);\t\t_event_debug_note_add(ev);\t\t\t\treturn res;\t}}我们总结event_add_internal的过程：  如果新添加的事件处理器是定时器，且未在定时器队列中，则为该定时器预留位置  如果新添加的事件处理器是信号事件处理器，且主线程正在执行回调函数，则等待主线程完成调用  如果新添加的事件处理器是IO/信号事件处理器，且没有被插入注册事件队列或活动事件队列，则绑定映射关系，并加入注册事件队列  将事件处理器添加到通用定时器队列或时间堆中event_add_internal函数内部调用了几个重要的函数：  evmap_io_add该函数将IO事件添加到事件多路分发器中，并将对应的事件处理器添加到IO事件队列中，同时建立IO事件和IO事件处理器之间的映射关系。  evmap_signal_add该函数将信号事件添加到事件多路分发器中，并将对应的事件处理器添加到信号事件队列中，同时建立信号事件和信号事件处理器之间的映射关系。  event_queue_insert该函数将事件处理器添加到各种事件队列中：将IO事件处理器和信号事件处理器插入注册事件队列；将定时器插入通用定时器队列或时间堆；将被激活的事件处理器添加到活动事件队列中。event_queue_insert的源码如下：static void event_queue_insert(struct event_base *base, struct event *ev, int queue){\tEVENT_BASE_ASSERT_LOCKED(base);\t//\t避免重复插入\tif(ev-&gt;ev_flags &amp; queue){\t\t//\t事件已经在活动事件队列中，不重复插入\t\tif(queue &amp; EVLIST_ACTIVE)\t\t\treturn;\t\t\t\t//\t事件已经在注册事件队列/通用定时器队列/时间堆中，输出错误信息\t\tevent_errx(1, \"%s: %p(fd %d) already on queue %x\",\t\t\t__func__, ev, ev-&gt;ev_fd, queue);\t\treturn;\t}\tif(~ev-&gt;ev_flags &amp; EVLIST_INTERNAL)\t\tbase-&gt;event_count++;\t//\t将event_base拥有的事件处理器总数+1\tev-&gt;ev_flags |= queue;\t//\t标记该事件已经添加过\tswitch(queue){\t\t//\t将IO事件处理器或信号事件处理器插入注册事件队列\t\tcase EVLIST_INSERTED:\t\t\tTAILQ_INSERT_TAIL(&amp;base-&gt;eventqueue, ev, ev_next);\t\t\tbreak;\t\t//\t将就绪事件处理器插入活动事件队列\t\tcase EVLIST_ACTIVE:\t\t\tbase-&gt;event_count_active++;\t\t\tTAILQ_INSERT_TAIL(&amp;base-&gt;activequeue[ev-&gt;ev_pri], ev, ev_active_next);\t\t\tbreak;\t\t//\t将定时器插入通用定时器队列或时间堆\t\tcase EVLIST_TIMEOUT:{\t\t\tif(is_common_timeout(&amp;ev-&gt;ev_timeout, base)){\t\t\t\tstruct common_timeout_list *ctl = \t\t\t\t\tget_common_timeout_list(base, &amp;ev-&gt;ev_timeout);\t\t\t\t\tinsert_common_timeout_inorder(ctl, ev);\t\t\t}else\t\t\t\tmin_heap_push(&amp;base-&gt;timeheap, ev);\t\t\tbreak;\t\t}\t\tdefault:\t\t\tevent_errx(1, \"%s: unkown queue %x\", __func__, queue);\t}}我们总结event_queue_insert的过程：  判断事件是否已经在队列中，避免重复插入  根据事件处理器的类型，插入到注册事件队列/活动事件队列/通用定时器队列或时间堆evmap.c中的一些数据结构evmap_io_add和evmap_signal_add会让事件多路分发器监听对应的事件，同时建立文件描述符、信号值与事件处理器之间的映射关系。在介绍evmap_io_add和evmap_signal_add方法之前，我们先介绍一些这两个函数用到的一些重要的数据结构：#ifdef MVMAP_USE_HT#include \"ht-internal.h\"struct event_map_entry;/*如果定义了MVMAP_USE_HT，则将event_io_map定义为哈希表，该哈希表存储event_map_entry对象和IO事件队列(相同文件描述符值的IO事件处理器构成IO事件队列)之间的映射关系，实际上也就是存储了文件描述符和IO事件处理器之间的映射关系*/HT_HEAD(event_io_map, event_map_entry);#else\t//\t否则event_io_map的结构和event_signal_map相同#define event_io_map event_signal_map#endif//\t下面这个结构体中的entries数组成员存储信号值和信号事件处理器之间的映射关系(用信号值索引数组entries)struct event_signal_map{\tvoid **entries;\t//\t用于存放evmap_io或evmap_signal数组\tint nentries;\t//\tentries数组的大小};//\t如果定义了EVMAP_USE_HT，则哈希表event_io_map中的成员具有如下类型struct event_map_entry{\tHT_ENTRY(event_map_entry) map_node;\tevutil_socket_t fd;\tunion{\t\tstruct evmap_io evmap_io;\t}ent;};//\tevent_list是由event组成的尾队列TAILQ_HEAD(event_list, event);//\tIO事件队列类struct evmap_io{\tstruct event_list events;\t//\tIO事件队列\tev_uint16_t nread;\tev_uint16_t nwrite;};//\t信号事件队列类struct evmap_signal{\tstruct event_list events;\t//\t信号事件队列};evmap_io_add和evmap_signal_addevmap_io_add和evmap_signal_add的逻辑基本相同，所以我们仅讨论其中一个。evmap_io_add的源码如下：int evmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev){\t//\t获得event_base的后端IO复用机制实例\tconst struct eventop *evsel = base-&gt;evsel;\t//\t获得event_base中文件描述符和IO事件队列的映射表(哈希表或数组)\tstruct event_io_map *io = &amp;base-&gt;io;\t//\tfd参数对应的IO事件队列\tstruct evmap_io *ctx = NULL;\tint nread, nwrite, retval = 0;\tshort res = 0, old = 0;\tstruct event *old_ev;\tEVUTIL_ASSERT(fd == ev-&gt;ev_fd);\tif(fd &lt; 0) return 0;#ifndef EVMAP_USE_HT\t//\tIO事件队列数组io.entries中，每个文件描述符占一项，如果fd大于当前数组的大小，则进行扩容\tif(fd &gt; io-&gt;nentries){\t\tif(evmap_make_space(io, fd, sizeof(struct evmap_io*)) == -1)\t\t\treturn -1;\t}#endif\t//\t下面这个宏根据EVMAP_USE_HT是否被定义而又不同的实现，但目的都是创建ctx，在映射表io中为fd和ctx添加映射关系\tGET_IO_SLOT_AND_CTOR(ctx, io, fd, evmap_io, evmap_io_init, evsel-&gt;fdinfo_len);\tnread = ctx-&gt;nread;\tnwrite = ctx-&gt;nwrite;\tif(nread)\t\told |= EV_READ;\tif(nwrite)\t\told |= EV_WRITE;\t\tif(ev-&gt;ev_events &amp; EV_READ){\t\tif(++nread == 1)\t\t\tres |= EV_READ;\t}\tif(ev-&gt;ev_events &amp; EV_WRITE){\t\tif(++nwrite == 1)\t\t\tres |= EV_WRITE;\t}\tif(EVUTIL_UNLIKELY(nread &gt; 0xffff || nwrite &gt; 0xffff)){\t\tevent_warnx(\"Too many events reading or writing on fd %d\", (int)fd);\t\treturn -1;\t}\tif(EVENT_DEBUG_MODE_IS_ON() &amp;&amp; \t\t(old_ev = TAILQ_FIRST(&amp;ctx-&gt;events)) &amp;&amp;\t\t(old_ev-&gt;ev_events &amp; EV_ET) != (ev-&gt;ev_events &amp; EV_ET)){\t\tevent_warnx(\"Tried to mix edge-triggered and non-edge-triggered events on fd %d\", (int)fd);\t\treturn -1;\t}\tif(res){\t\t//\t获取IO事件队列的内存地址\t\tvoid *extra = ((char *)ctx + sizeof(struct evmap_io));\t\t//\t往事件多路分发器中注册事件\t\t//\tadd是事件多路分发器的接口函数之一。对不同的后端IO复用机制，这些接口函数有不同的实现\t\tif(evsel-&gt;add(base, ev-&gt;ev_fd, old, \t\t\t(ev-&gt;ev_events &amp; EV_ET) | res, extra) == -1)\t\t\treturn -1;\t\tretval = 1;\t}\tctx-&gt;nread = (ev_uint16_t)nread;\tctx-&gt;nwrite = (ev_uint16_t)nwrite;\t//\t将ev插到IO事件队列ctx的尾部，ev_io_next是定义在event-internal.h文件中的宏：\t//\t#define ev_io_next _ev.ev_io.ev_io_next\tTAILQ_INSERT_TAIL(&amp;ctx-&gt;events, ev, ev_io_next);\treturn retval;}我们总结evmap_io_add的过程：  获取IO复用机制的接口  获取IO事件队列的映射表  判断IO事件队列空间是否足够，如果不够则扩容  获得fd对应的IO事件队列，并添加映射关系  添加可读、可写事件类型等属性  注册事件  插入IO事件队列总结      event_new函数的实现主要是为event对象分配内存并初始化部分成员，该函数位于event.c文件中    event_add函数将event对象添加到注册事件队列中，并将对应的事件注册到事件多路分发器上，该函数位于event.c文件中    event_queue_insert函数将事件处理器添加到各种事件队列中：将IO事件处理器和信号事件处理器插入注册事件队列；将定时器插入通用定时器队列或时间堆；将被激活的事件处理器添加到活动事件队列中    evmap_io_add和evmap_signal_add函数令事件多路分发器监听对应的事件，同时建立文件描述符、信号值与事件处理器之间的映射关系  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— Libevent源码分析_2",
    "url": "/posts/Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Libevent",
    "date": "2023-07-07 16:19:00 +0800",
    





    
    "snippet": "Libevent源代码组织结构/event  本节我们继续探究Libevent的源码，在分析具体源码之前，我们先分析了Libevent的组织结构，弄清楚每个目录及文件实现了什么功能。接着我们把重点放在event和event_base这两个结构体及其相关操作上，它们构成了Libevent框架的基础。最后我们分析了event结构体的成员，为之后分析event结构体相关联的操作做准备。源代码组织结...",
    "content": "Libevent源代码组织结构/event  本节我们继续探究Libevent的源码，在分析具体源码之前，我们先分析了Libevent的组织结构，弄清楚每个目录及文件实现了什么功能。接着我们把重点放在event和event_base这两个结构体及其相关操作上，它们构成了Libevent框架的基础。最后我们分析了event结构体的成员，为之后分析event结构体相关联的操作做准备。源代码组织结构  头文件目录include/event2该目录的头文件是Libevent提供应用程序使用的。比如event.h头文件提供核心函数，http.h头文件提供HTTP协议相关服务，rpc.h头文件提供远程过程调用支持。  源码根目录下的头文件这些头文件分为两类：一类是对include/event2目录下部分头文件的包装。另一类是供Libevent内部使用的辅助性头文件，它们的文件名都是*-internal.h的形式。  通用数据结构目录compat/sys该目录下仅有一个文件：queue.h。封装了跨平台的基础数据结构，包括单向链表、双向链表、队列、尾队列和循环队列。  sample目录提供了一些示例程序。  test目录提供了一些测试代码。  WIN32-Code目录提供了Windows平台上的一些专用代码。  event.c文件实现了Libevent的整体框架，主要是event和event_base两个结构体的相关操作。  devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c和epoll.c文件分别封装了如下IO复用机制：/dev/poll、kqueue、event ports、POSIX select、Windows select、poll和epoll。这些文件主要内容相似，都是针对结构体eventop所定义的接口函数的具体实现。  minheap-internal.h文件该文件实现了一个时间堆，以提供堆定时事件的支持。  signal.c文件提供了对信号的支持，其内容也是针对结构体eventop所定义的接口函数的具体实现。  evmap.c文件维护句柄(文件描述符或信号)与事件管理器的映射关系。  event_tagging.c文件它提供往缓冲区中添加标记数据，以及从缓冲区中读取标记数据的函数。  event_iocp.c文件它提供对Windows IOCP(Input/Output Completion Port，输入输出完成接口)的支持。  buffer*.c文件它提供对网络IO缓冲的控制，包括：输入输出数据过滤，传输速率限制，实现SSL协议对应用数据进行保护，以及零拷贝文件传输。  evthread.c文件它提供对多线程的支持。  listener.c文件它封装了监听socket的操作，包括监听连接和接受连接。  logs.c文件它是Libevent的日志系统。  evutil.c、evutil_rand.c、strlcpy.c、和arc4random.c文件它们提供一些基本操作，比如生成随机数、获取socket地址信息、读取文件、设置socket属性等。  evdns.c、http.c和evrpc.c文件它们分别提供了对DNS协议、HTTP协议和RPC协议的支持。  epoll_sub.c文件该文件未见使用。在整个源码中，event_internal.h、include/event2/event_struct.h、event.c和evmap.c这4个文件最重要。这4个文件定义了event和event_base结构体，并实现了这两个结构体的相关操作。event结构体event结构体是Libevent中事件处理器的类型，封装了句柄、事件类型、回调函数以及其他必要的标志和数据。它定义在include/event2/event_struct.h文件中，其定义如下：struct event{\tTAILQ_ENTRY(event) ev_active_next;\tTAILQ_ENTRY(event) ev_next;\tunion{\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;\t\tint min_heap_idx;\t} ev_timeout_pos;\tevutil_socket_t ev_fd;\tstruct event_base *ev_base;\tunion{\t\tstruct{\t\t\tTAILQ_ENTRY(event) ev_io_next;\t\t\tstruct timeval ev_timeout;\t\t} ev_io;\t\tstruct{\t\t\tTAILQ_ENTRY(event) ev_signal_next;\t\t\tshort ev_ncalls;\t\t\tshort *ev_pncalls;\t\t} ev_signal;\t} _ev;\tshort ev_events;\tshort ev_res;\tshort ev_flags;\tev_uint8_t ev_pri;\tev_uint8_t ev_closure;\tstruct timeval ev_timeout;\tvoid (*ev_callback)(evutil_socket_t, short, void *arg);\tvoid *ev_arg;};结构体成员解析：  ev_events: 代表事件类型，可以通过按位或运算赋值  ev_next: 所有已经注册的事件处理器，通过一个尾队列串联起来，称为注册事件队列。宏TAILQ_ENTRY是尾队列的结点类型，定义在compat/sys/queue.h文件中，其定义如下：#define TAILQ_ENTRY(type)struct {\tstruct type *tqe_next;\t//\t下一个元素\t\t\tstruct type **tqe_prev;\t//\t前一个元素的地址}      ev_active_next: 所有被激活的事件处理器。该成员同样通过一个尾队列串联起来，称为活动事件队列。活动事件队列不止一个，不同优先级的事件处理器被激活后会被插入不同的活动事件队列。然后在事件循环中，Reactor按照优先级从高到低的顺序遍历所有活动事件队列，依次处理其中的事件处理器。    ev_timeout_pos: 这是一个联合体，它仅用于定时事件处理器。在老版的Libevent中，定时器都是用时间堆来管理的。但是开发者认为某些情况下采用简单链表来管理定时器效率更高，所以引入了“通用定时器”的概念。一个定时器是否使用通用定时器取决于超时时间的大小。          如果采用通用定时器，定时器存储在尾队列中，称为通用定时器队列。其联合体的ev_next_with_common_timeout成员指出该定时器在通用定时器队列中的位置。      如果采用其他定时器(时间堆)，则联合体的min_heap_idx成员指出该定时器在时间堆中的位置。        _ev: 这是一个联合体。所有具有相同文件描述符值的IO事件处理器通过ev.ev_io.ev_io_next成员串联成一个尾队列，称为IO事件队列；所有具有相同信号值的信号处理器通过ev.ev_signal.ev_signal_next成员串联成一个尾队列，称为信号事件队列。(这样做的好处可以快速地使所有相关的事件处理器添加到活动事件队列中)          ev.ev_signal.ev_ncalls成员指定信号事件发生时，Reactor需要执行多少次该事件对应的回调函数。      ev.ev_signal.ev_pncalls成员要么为NULL，要么指向ev.ev_signal.ev_ncalls。            ev_fd: 对于IO事件处理器，它是文件描述符值；对于信号事件处理器，它是信号值。        ev_base: 该事件处理器从属的event_base实例。        ev_res: 该字段记录当前激活事件的类型。    ev_flags: 该字段是一些事件的标志，可选值定义在include/event2/event_struct.h中，包括：#define EVLIST_TIMEOUT 0x01\t\t//\t事件处理器从属于通用定时器队列或时间堆#define EVLIST_INSERTED 0x02\t//\t事件处理器从属于注册事件队列#define EVLIST_SIGNAL 0x04\t\t//\t没有使用#define EVLIST_ACTIVE 0x08\t\t//\t事件处理器从属于活动事件队列#define EVLIST_INTERNAL 0x10\t//\t内部使用#define EVLIST_INIT 0x80\t\t//\t事件处理器已被初始化#define EVLIST_ALL (0xf000 | 0x9f)\t//\t定义所有标志      ev_pri: 该字段指定事件处理器的优先级，值越小优先级越高。        ev_closure: 该字段指定event_base执行事件处理器的回调函数时的行为。其可选值定义在event-internal.h文件中，包括：  #define EV_CLOSURE_NONE 0\t\t//\t默认行为#define EV_CLOSURE_SIGNAL 1\t\t//\t执行ev.ev_signal.ev_ncalls次信号事件处理器的回调函数#define EV_CLOSURE_PERSIST 2\t//\t执行完回调函数后，再次将事件处理器加入注册事件队列中      ev_timeout: 该字段仅对定时器有效，指定定时器的超时值。        ev_callback: 该字段是事件处理器的回调函数，由event_base调用。回调函数呗调用时，传入事件处理器的三个成员: ev_fd、ev_res和ev_arg。        ev_arg: 回调函数的参数。  总结      Libevent的源码中，event_internal.h、include/event2/event_struct.h、event.c和evmap.c这4个文件最重要，它们定义了event和event_base结构体，并实现了这两个结构体的相关操作    event结构体是Libevent中事件处理器的类型，封装了句柄、事件类型、回调函数以及其他必要的标志和数据  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— Libevent源码分析_1",
    "url": "/posts/Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Libevent",
    "date": "2023-07-07 14:51:00 +0800",
    





    
    "snippet": "Libevent安装/Libevent简单实例  Libevent是一款开源的高性能IO框架库，具有支持跨平台、统一事件源、线程安全、基于Reacotr模式的实现的特点。我们给出了Libevent的安装步骤，通过一个简单的例子来展示Libevent的用法。LibeventLibevent是一款开源的高性能IO框架库，使用Libevent的案例包括：高性能的分布式内存对象缓存软件memcach...",
    "content": "Libevent安装/Libevent简单实例  Libevent是一款开源的高性能IO框架库，具有支持跨平台、统一事件源、线程安全、基于Reacotr模式的实现的特点。我们给出了Libevent的安装步骤，通过一个简单的例子来展示Libevent的用法。LibeventLibevent是一款开源的高性能IO框架库，使用Libevent的案例包括：高性能的分布式内存对象缓存软件memcached，谷歌浏览器的Linux版本。Libevent有以下特点：  跨平台支持。Libevent支持Linux、UNIX和Windows。  统一事件源。Libevent对IO事件、信号和定时事件提供统一的处理。  线程安全。Libevent使用libevent_pthreads库来提供线程安全支持。  基于Reacotr模式的实现。Libevent安装      在官网下载 http://libevent.org        解压  tar -zxvf libevent-2.1.12-stable.tar.gz  安装到/usr目录下./configure --prefix=/usr  编译安装sudo makesudo make install  查看是否安装成功ls -al /usr/lib | grep libeventlrwxrwxrwx  1 root root      21 Jul  7 14:47 libevent-2.1.so.7 -&gt; libevent-2.1.so.7.0.1-rwxr-xr-x  1 root root 1422176 Jul  7 14:47 libevent-2.1.so.7.0.1-rw-r--r--  1 root root 2373894 Jul  7 14:47 libevent.alrwxrwxrwx  1 root root      26 Jul  7 14:47 libevent_core-2.1.so.7 -&gt; libevent_core-2.1.so.7.0.1-rwxr-xr-x  1 root root  922968 Jul  7 14:47 libevent_core-2.1.so.7.0.1-rw-r--r--  1 root root 1572678 Jul  7 14:47 libevent_core.a-rwxr-xr-x  1 root root     988 Jul  7 14:47 libevent_core.lalrwxrwxrwx  1 root root      26 Jul  7 14:47 libevent_core.so -&gt; libevent_core-2.1.so.7.0.1lrwxrwxrwx  1 root root      27 Jul  7 14:47 libevent_extra-2.1.so.7 -&gt; libevent_extra-2.1.so.7.0.1-rwxr-xr-x  1 root root  527416 Jul  7 14:47 libevent_extra-2.1.so.7.0.1-rw-r--r--  1 root root  801290 Jul  7 14:47 libevent_extra.a-rwxr-xr-x  1 root root     995 Jul  7 14:47 libevent_extra.lalrwxrwxrwx  1 root root      27 Jul  7 14:47 libevent_extra.so -&gt; libevent_extra-2.1.so.7.0.1-rwxr-xr-x  1 root root     953 Jul  7 14:47 libevent.lalrwxrwxrwx  1 root root      29 Jul  7 14:47 libevent_openssl-2.1.so.7 -&gt; libevent_openssl-2.1.so.7.0.1-rwxr-xr-x  1 root root  122448 Jul  7 14:47 libevent_openssl-2.1.so.7.0.1-rw-r--r--  1 root root  172698 Jul  7 14:47 libevent_openssl.a-rwxr-xr-x  1 root root    1024 Jul  7 14:47 libevent_openssl.lalrwxrwxrwx  1 root root      29 Jul  7 14:47 libevent_openssl.so -&gt; libevent_openssl-2.1.so.7.0.1lrwxrwxrwx  1 root root      30 Jul  7 14:47 libevent_pthreads-2.1.so.7 -&gt; libevent_pthreads-2.1.so.7.0.1-rwxr-xr-x  1 root root   26888 Jul  7 14:47 libevent_pthreads-2.1.so.7.0.1-rw-r--r--  1 root root   27230 Jul  7 14:47 libevent_pthreads.a-rwxr-xr-x  1 root root    1016 Jul  7 14:47 libevent_pthreads.lalrwxrwxrwx  1 root root      30 Jul  7 14:47 libevent_pthreads.so -&gt; libevent_pthreads-2.1.so.7.0.1lrwxrwxrwx  1 root root      21 Jul  7 14:47 libevent.so -&gt; libevent-2.1.so.7.0.1Libevent简单实例我们给出Libevent实现的最简单的实例：//  编译命令：g++ libevent_example.cpp -o libevent_example -levent#include &lt;sys/signal.h&gt;#include &lt;event.h&gt;void signal_cb(int fd, short event, void *argc){\tstruct event_base *base = (event_base *)argc;\tstruct timeval delay = {2, 0};\tprintf(\"Caught an interrupt siganl; exiting cleanly in two seconds...\\n\");\tevent_base_loopexit(base, &amp;delay);}void timeout_cb(int fd, short event, void *argc){\tprintf(\"timeout\\n\");}int main(){\tstruct event_base *base = event_init();\t\tstruct event *signal_event = evsignal_new(base, SIGINT, signal_cb, base);   //  创建信号事件\tevent_add(signal_event, NULL);  //  添加事件和事件处理器\t\ttimeval tv = {1, 0};\tstruct event * timeout_event = evtimer_new(base, timeout_cb, NULL);   //  创建超时事件\tevent_add(timeout_event, &amp;tv);  //  添加事件和事件处理器\t\tevent_base_dispatch(base);      //  执行事件循环\t\tevent_free(timeout_event);      //  释放资源\tevent_free(signal_event);\tevent_base_free(base);}      main函数中，调用event_init函数创建了一个event_base对象。event_base对象相当于一个Reactor实例。        调用evsignal_new和evtimer_new函数，分别创建了信号事件处理器和定时事件处理器。其中，evsignal_new和evtimer_new函数的具体定义如下：  #define evsignal_new(b, x, cb, arg) event_new((b), (x), EV_SIGNAL | EV_PERSIST (cb), (arg))#define evtimer_new(b, cb, arg) event_new((b), -1, 0, (cb), (arg))从具体定义中可以看出，它们都是通过调用了event_new函数实现的。event_new函数用于创建通用事件处理器，其定义如下：struct event* event_new(struct event_base *base, evutil_socket_t fd, short events, void (*cb)(evutil_socket_t, short, void*), void *arg);其中：  base: 事件处理器所属的Reactor  fd: 该事件处理器关联的句柄          IO事件处理器给fd传递文件描述符      信号事件处理器给fd传递信号值      定时事件处理器给fd传递-1        events：指定事件类型  cb: 目标事件对应的回调函数  arg: 传递给回调函数的参数  返回值: 成功返回一个event类型的对象，即事件处理器(包括句柄、事件类型、回调函数等信息)events参数支持的事件类型#define EV_TIMEOUT 0x01   //  定时事件#define EV_READ 0x02      //  可读事件#define EV_WRITE 0x04     //  可写事件#define EV_SIGNAL 0x08    //  信号事件#define EV_PERSIST 0x10   //  永久事件#define EV_ET 0x20        //  边沿触发事件，需要IO复用系统调用支持，比如epoll  调用event_add函数，完成下列操作：  将事件处理器添加到注册事件列表中  将对应的事件添加到事件多路分发器中      调用event_base_dispatch函数执行事件循环。事件循环指对一个就绪事件执行对应的事件处理器。        调用*_free系列函数来释放系统资源。  总结      Libevent是一款开源的高性能IO框架库  Reference[1] 《深入解析高性能服务器编程》  [2] libevent源码分析-介绍、安装、使用"
  },
  
  {
    "title": "读书笔记 —— 定时器_4",
    "url": "/posts/%E5%AE%9A%E6%97%B6%E5%99%A8_4/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 定时器, 时间轮, 时间堆",
    "date": "2023-07-06 16:18:00 +0800",
    





    
    "snippet": "时间轮/时间堆  上节中我们用升序链表来统一管理定时器，但随着插入定时器的数量的增多，链表的插入效率会越来越低。为了解决这个问题，我们提出了时间轮和时间堆这两种定时器容器。时间轮是基于哈希表的思想，将定时器散列到多个链表中，然后轮询每个槽。而时间堆则是将最小的超时时间作为心搏间隔，以实现更精确的定时。时间轮基于排序链表的定时器使用一条链表来管理所有定时器，所以插入操作的效率会随着定时器数目的...",
    "content": "时间轮/时间堆  上节中我们用升序链表来统一管理定时器，但随着插入定时器的数量的增多，链表的插入效率会越来越低。为了解决这个问题，我们提出了时间轮和时间堆这两种定时器容器。时间轮是基于哈希表的思想，将定时器散列到多个链表中，然后轮询每个槽。而时间堆则是将最小的超时时间作为心搏间隔，以实现更精确的定时。时间轮基于排序链表的定时器使用一条链表来管理所有定时器，所以插入操作的效率会随着定时器数目的增多而降低。我们哈希算法的启发，如果多定义几条链表，将定时器放到不同的链表上，这样每条链表上的定时器数目远小于单条链表上的定时器数目，插入操作受定时器数目的影响会大幅降低。基于这个思想，提出了时间轮的概念，时间轮的构造如下图所示：图中时间轮内的实指针指向时间轮的一个槽(slot)。时间轮以恒定的时间转动，每转动一步指向下一个槽(虚指针所指的槽)。每次转动称为一个滴答(tick)，一个滴答时间称为时间轮的槽间隔si(slot interval)。一个时间轮有N个槽，所以转动一周的时间是Nsi。每个槽指向一条定时器链表，每条链表上的定时器有相同的特征：它们的定时时间相差Nsi的整数倍。也就是说，现在指针指向槽cs，我们需要添加一个定时时间为ti的定时器，则该定时器应该插入槽ts(timer slot)对应的链表种：ts = (cs + (ti / si)) % N如果要提高时间轮的精度，我们可以减小si的值(使时间轮转得更快)；如果要提高执行效率，我们可以增大N的值(使每条链表上的定时器数量更少)。而且我们可以定义多个轮子，每个轮子的槽间隔si和槽数量N都是不同的(可能精度高的轮子转一圈，精度低的轮子仅转了一个槽)。下面给出一个简单的时间轮实现：#ifndef TIME_WHEEL_TIMER#define TIME_WHEEL_TIMER#include &lt;time.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#define BUFFER_SIZE 64class tw_timer;class time_wheel;//  客户数据struct client_data{  sockaddr_in address;  int sockfd;  char buf[BUFFER_SIZE];  tw_timer *timer;};//  定时器类class tw_timer{public:  tw_timer(int rot, int ts):next(NULL), prev(NULL), rotation(rot), time_slot(ts){}public:  int rotation;   //  记录定时器在时间轮转多少圈后才生效  int time_slot;  //  记录定时器属于时间轮上哪个槽  void (*cb_func)(client_data*);  //  定时器回调函数  client_data *user_data;         //  客户数据  tw_timer *next;                 //  指向下一个定时器  tw_timer *prev;                 //  指向前一个定时器};class time_wheel{public:  //  构造函数  time_wheel():cur_slot(0)  {    for(int i = 0 ; i &lt; N ; i++){      slots[i] = NULL;    //  初始化每个槽的头结点    }  }    //  析构函数  ~time_wheel()  {    for(int i = 0 ; i &lt; N ; i++){      tw_timer *tmp = slots[i];      while(tmp){        slots[i] = tmp-&gt;next;        delete tmp;        tmp = slots[i];      }    }  }  //  创建定时值timeout创建一个定时器，并把它插入合适的槽中  tw_timer *add_timer(int timeout)  {    if(timeout &lt; 0){      return NULL;    }    //  根据超时值计算它在时间轮转动多少个滴答后被触发，并将该滴答数存储在变量tick中    int ticks = 0;    //  如果超时值小于槽间隔SI，则ticks向上取整1，否则向下取整timeout/SI    if(timeout &lt; SI){      ticks = 1;    }else{      ticks = timeout / SI;    }    //  计算待插入的定时器在时间轮转动多少圈后被触发    int rotation = ticks / N; //  (N * SI) = N    //  计算待插入的定时器被插入到哪个槽中    int ts = (cur_slot + (ticks % N)) % N;    //  创建新的定时器，他在时间轮转动rotation圈后触发，且位于第ts个槽上    tw_timer *timer = new tw_timer(rotation, ts);    //  如果第ts个槽没有定时器，则插入其中，并作为该槽的头结点    if(!slots[ts]){      printf(\"add timer, rotation is %d, ts is %d, cur_slot is %d\", rotation, ts, cur_slot);      slots[ts] = timer;    }    //  否则插入第ts个槽中    else{      timer-&gt;next = slots[ts];      slots[ts]-&gt;prev = timer;      slots[ts] = timer;    }    return timer;  }    //  延长定时器时间  void adjust_timer(tw_timer *timer,int timeout)  {\tif(timeout &lt; 0 || !timer){      return;    }\t//  根据超时值计算它在时间轮转动多少个滴答后被触发，并将该滴答数存储在变量tick中    int ticks = 0;    //  如果超时值小于槽间隔SI，则ticks向上取整1，否则向下取整timeout/SI    if(timeout &lt; SI){      ticks = 1;    }else{      ticks = timeout / SI;    }\t//  计算待插入的定时器在时间轮转动多少圈后被触发    int rotation = ticks / N; //  (N * SI) = N    //  计算待插入的定时器被插入到哪个槽中    int ts = (cur_slot + (ticks % N)) % N;\ttimer-&gt;rotation = rotation;\ttimer-&gt;time_slot = ts;  }    //  删除目标定时器timer  void del_timer(tw_timer *timer)  {    if(!timer){      return;    }    int ts = timer-&gt;time_slot;    //  如果目标定时器是所在槽的头结点，则重置第ts个槽的头结点    if(timer == slots[ts]){      slots[ts] = slots[ts]-&gt;next;      if(slots[ts]){        slots[ts]-&gt;prev = NULL;      }    }else{      timer-&gt;prev-&gt;next = timer-&gt;next;      if(timer-&gt;next){        timer-&gt;next-&gt;prev = timer-&gt;prev;      }    }    delete timer;  }  //  SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔  void tick()  {    tw_timer *tmp = slots[cur_slot];    printf(\"current slot is %d\\n\", cur_slot);    while(tmp){      printf(\"tick the timer once\\n\");      //  如果定时器的rotation值大于0      if(tmp-&gt;rotation &gt; 0){        tmp-&gt;rotation--;        tmp = tmp-&gt;next;      }      //  否则，说明定时器到期，执行定时任务，然后删除该定时器      else{        tmp-&gt;cb_func(tmp-&gt;user_data);        if(tmp == slots[cur_slot]){          printf(\"delete header in cur_slot\\n\");          slots[cur_slot] = tmp-&gt;next;          delete tmp;          if(slots[cur_slot]){            slots[cur_slot]-&gt;prev = NULL;          }          tmp = slots[cur_slot];        }else{          tmp-&gt;prev-&gt;next = tmp-&gt;next;          if(tmp-&gt;next){            tmp-&gt;next-&gt;prev = tmp-&gt;prev;          }          tw_timer *tmp2 = tmp-&gt;next;          delete tmp;          tmp = tmp2;        }      }    }    cur_slot = ++cur_slot % N;  }private:  static const int N = 60;  //  时间轮上的槽数目  static const int SI = 1;  //  每1s转动一圈，即槽间隔为1s  tw_timer *slots[N];       //  时间轮的槽，每个元素指向一个无序链表  int cur_slot;             //  时间轮的当前槽};#endif在时间轮中，添加一个定时器的时间复杂度是O(1)，删除一个定时器的时间复杂度是O(1)，执行一个定时器的时间复杂度是O(n)。但实际中，执行一个定时器任务的效率要远好于O(n)，因为时间轮将定时器散列到不同的链表上。当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将将近O(1)。时间堆升序链表和时间轮的定时方案都是通过一个固定的频率检测到期的定时任务，而时间堆采用另一种设计思路：将所有定时器中最小的超时时间作为心搏间隔。然后，再从剩余的定时器中找到超时时间最小的一个，作为下一次的心搏间隔。这种方式相比固定频率的检测方式，更加精确。由于获取最小超时时间最适合的数据结构的最小堆，所以我们用堆来实现，下面给出一个简单的时间堆实现：#ifndef MIN_HEAP#define MIN_HEAP#include &lt;iostream&gt;#include &lt;netinet/in.h&gt;#include &lt;time.h&gt;using std::exception;#define BUFFER_SIZE 64class heap_timer;class time_heap;//  客户数据struct client_data{  sockaddr_in address;  int sockfd;  char buf[BUFFER_SIZE];  heap_timer *timer;};//  定时器类class heap_timer{public:  heap_timer(int delay)  {    expire = time(NULL) + delay;  }public:  time_t expire;                  //  定时器生效的绝对时间    void (*cb_func)(client_data*);  //  定时器回调函数  client_data *user_data;         //  客户数据};//  时间堆类class time_heap{public:  //  构造函数  time_heap(int cap) throw (std::exception) : capacity(cap), cur_size(0)  {    array = new heap_timer*[capacity];  //  创建堆数组    if(!array){      throw std::exception();    }    for(int i = 0 ; i &lt; capacity ; i++){      array[i] = NULL;    }  }  //  构造函数  time_heap(heap_timer **init_array, int size, int capacity) throw (std::exception)  : cur_size(size), capacity(capacity)  {    if(capacity &lt; size){      throw std::exception();    }    array = new heap_timer*[capacity];  //  创建堆数组    if(!array){      throw std::exception();    }    for(int i = 0 ; i &lt; capacity ; i++){      array[i] = NULL;    }    if(size != 0){      for(int i = 0 ; i &lt; size ; i++){        array[i] = init_array[i];      }      for(int i = (cur_size - 1) / 2 ; i &gt;= 0 ; i++){        percolate_down(i);    //  对数组第[(cur_size - 1) / 2 ] ~ 0个元素执行调整      }    }  }  //  析构函数  ~time_heap()  {    for(int i = 0 ; i &lt; cur_size ; i++){      delete array[i];    }    delete[] array;  }public:  //  添加目标定时器timer  void add_timer(heap_timer *timer) throw (std::exception)  {    if(!timer){      return;    }    if(cur_size &gt;= capacity){ //  如果当前堆数组容量不够，进行扩容      resize();    }    //  新插入一个元素，当前堆大小加1，hole是空穴的位置    int hole = cur_size++;    int parent = 0;    //  对从空穴到根节点路径上的所有结点执行调整    for(; hole &gt; 0 ; hole = parent){      parent = (hole - 1) / 2;      if(array[parent]-&gt;expire &lt;= timer-&gt;expire){        break;      }      array[hole] = array[parent];    }    array[hole] = timer;  }  //  删除目标定时器timer  void del_timer(heap_timer *timer)  {    if(!timer){      return;    }    //  仅仅将目标定时器的回调函数设置为空，即延迟销毁    //  因为没有记录堆在数组中的位置，而且频繁删除会导致堆频繁调整，延迟销毁可以节省系统资源，但也会导致数组膨胀    timer-&gt;cb_func = NULL;  }  //  获取堆顶的定时器  heap_timer *top() const  {    if(empty()){      return NULL;    }    return array[0];  }  //  删除对顶部的定时器  void pop_timer()  {    if(empty()){      return;    }    if(array[0]){      delete array[0];      array[0] = array[--cur_size]; //  将堆顶元素替换到堆数组最后一个元素的位置      percolate_down(0);            //  调整堆    }  }  //  心搏函数  void tick()  {    heap_timer *tmp = array[0];    time_t cur = time(NULL);    while(!empty()){      if(!tmp){        break;      }      if(tmp-&gt;expire &gt; cur){  //  堆顶定时器没到期        break;      }      //  否则执行堆顶计时器的定时任务      if(array[0]-&gt;cb_func){        array[0]-&gt;cb_func(array[0]-&gt;user_data);      }      //  将堆顶元素删除，同时生成新的堆顶定时器      pop_timer();      tmp = array[0];    }  }  //  判断堆是否为空  bool empty() const  {    return cur_size == 0;  }private:  //  调整堆  void percolate_down(int hole)  {    heap_timer *temp = array[hole];    int child = 0;    for(; ((hole * 2 + 1) &lt;= (cur_size - 1)) ; hole = child){      child = hole * 2 + 1;      //  如果右孩子存在，且右孩子的超时值小于左孩子，则最小值取右孩子，否则保持不变，即取左孩子      if((child &lt; cur_size - 1) &amp;&amp; (array[child + 1]-&gt;expire &lt; array[child]-&gt;expire)){        ++child;      }      //  如果孩子结点超时值更小，则将孩子结点上移      if(array[child]-&gt;expire &lt; temp-&gt;expire){        array[hole] = array[child];      }      else{        break;      }    }    array[hole] = temp;  }  //  扩容  void resize() throw (std::exception)  {    heap_timer **temp = new heap_timer*[2 * capacity];    for(int i = 0 ; i &lt; 2 * capacity ; i++){      temp[i] = NULL;    }    if(!temp){      throw std::exception();    }    capacity = 2 * capacity;    for(int i = 0 ; i &lt; cur_size ; i++){      temp[i] = array[i];    }    delete[] array;    array = temp;  }private:  heap_timer **array; //  堆数组  int capacity;       //  堆数组的容量  int cur_size;       //  堆数组当前包含元素的个数};#endif在时间堆中，添加一个定时器的时间复杂度是O(logn)，删除一个定时器的时间复杂度是O(1)，执行一个定时器的时间复杂度是O(1)。因此时间堆的效率很高。总结      在时间轮中，添加一个定时器的时间复杂度是O(1)，删除一个定时器的时间复杂度是O(1)，执行一个定时器的时间复杂度是O(n)    在时间堆中，添加一个定时器的时间复杂度是O(logn)，删除一个定时器的时间复杂度是O(1)，执行一个定时器的时间复杂度是O(1)  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  恢复二叉搜索树",
    "url": "/posts/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
    "categories": "leetcode",
    "tags": "leetcode, Inorder traversal, Morris Traversal",
    "date": "2023-07-05 21:25:00 +0800",
    





    
    "snippet": "中序遍历/莫里斯遍历  该题要求交换树中的两个结点值，使树成为二叉搜索树。难点在于利用二叉搜索树性质，用尽可能小的辅助空间来实现。题目给你二叉搜索树的根结点 root ，该树中的 恰好 两个结点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。例子示例1输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 的左孩子，因为 ...",
    "content": "中序遍历/莫里斯遍历  该题要求交换树中的两个结点值，使树成为二叉搜索树。难点在于利用二叉搜索树性质，用尽可能小的辅助空间来实现。题目给你二叉搜索树的根结点 root ，该树中的 恰好 两个结点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。例子示例1输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。示例2输入：root = [3,1,4,null,null,2]输出：[2,1,4,null,null,3]解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。条件  树上结点的数目在范围 [2, 1000] 内  -2^31 &lt;= Node.val &lt;= 2^31 - 1难点分析该题的难点在于利用二叉搜索树性质，使用尽可能小的空间复杂度完成计算，我们给出两种解法：  中序遍历我们知道二叉搜索树的中序遍历是一个升序序列，我们可以利用这个特点，中序遍历整个二叉搜索树。然后遍历过程中，找到位置不对的点，交换两个位置不对的点，就能恢复二叉搜索树。由于中序遍历的递归过程需要栈空间，所以该方法的空间复杂度是O(logn)。  莫里斯遍历如果我们想要实现O(1)的空间复杂度，我们可以采用莫里斯遍历。莫里斯遍历的思想其实就是将二叉搜索树线索化，这样我们就可以一次遍历完整棵树，而不需要额外的辅助空间(栈)来记录回退的结点位置。  首先如何线索化：一颗二叉线索树如下图所示：按照中序遍历：  我们先遍历左子树：3，1  左子树为空了，然后遍历右子树2  左、右子树都为空了，这时候应该回退到结点3我们发现2的左、右子树都为空，我们可以利用这个空闲的指针，使2指向3。所以我们得到线索化的实现：当前结点root，我们令root的左结点的最右结点的右指针指向root。线索化后的二叉搜索树就像下图这样：  接着，我们需要去循环我们按照正常的遍历逻辑：先访问结点的左子树，然后访问结点的右子树。但是当我们线索化后，就会出现循环，比如上图中2的右结点指向3，我们访问3。但是3的左结点存在，我们不能又去往左遍历1和2。所以我们遍历的过程中，还需要对线索化的结点去循环。所以当我们再次访问结点3时(这次访问才真正处理结点3的数据)，去循环后的二叉搜索树如下图所示：所以我们给出去循环的判定条件和实现：如果当前结点root的左结点的最右结点的右指针指向root，说明构成了循环，我们将root的左结点的最右结点的右指针置空。  最后，找到位置不对的点4-根据二叉搜索树的特点，因为我们莫里斯遍历是按从小到大的顺序遍历一整棵树，所以遍历过程中，如果当前结点的大小小于前一个结点的大小，说明该结点的位置不对。我们只要找到两个位置不对的结点，再进行交换，就能得到正确的二叉搜索树。比如某个错误的二叉搜索树遍历顺序是：1 2 3 7 5 6 4这里需要注意，第一次出现顺序错误的位置是5(5比前一个结点7小)，我们要取前一个结点的位置。第二次出现顺序错误的位置是4(4比前一个结点6小)，这时我们要取当前结点的位置。找出两个错误位置的结点后的树如下图所示，接下来我们只要交换它们的结点值就能恢复二叉搜索树了。解法解法1：递归class Solution {public:    TreeNode *x = nullptr, *y = nullptr, *pre = nullptr;    void recoverTree(TreeNode* root) {        dfs(root);        swap(x-&gt;val, y-&gt;val);    }    void dfs(TreeNode* root){        if(root == nullptr){            return;        }        dfs(root-&gt;left);        if(pre == nullptr){            pre = root;        }else{            //  找到不是升序顺序的位置            if(pre-&gt;val &gt; root-&gt;val){                y = root;                if(!x){                    x = pre;                }            }            pre = root;        }        dfs(root-&gt;right);    }};解法2：莫里斯遍历class Solution {public:    void recoverTree(TreeNode* root) {        TreeNode *pre = nullptr, *x = nullptr, *y = nullptr;        while(root != nullptr){            TreeNode *t = root-&gt;left;            if(t != nullptr){                while(t-&gt;right != nullptr &amp;&amp; t-&gt;right != root){                    t=t-&gt;right;                }                if(t-&gt;right == nullptr){                    t-&gt;right = root;                    root = root-&gt;left;                }else{                    if(pre != nullptr &amp;&amp; pre-&gt;val &gt; root-&gt;val){                        y = root;                        if(x == nullptr){                            x = pre;                        }                    }                    pre = root;                    t-&gt;right = nullptr;                    root = root-&gt;right;                }            }else{                if(pre != nullptr &amp;&amp; pre-&gt;val &gt; root-&gt;val){                    y = root;                    if(x == nullptr){                        x = pre;                    }                }                pre = root;                root = root-&gt;right;            }        }        swap(x-&gt;val, y-&gt;val);    }};Reference[1] 恢复二叉搜索树 [2] 三种解法+详细图解 99. 恢复二叉搜索树"
  },
  
  {
    "title": "读书笔记 —— 定时器_2",
    "url": "/posts/%E5%AE%9A%E6%97%B6%E5%99%A8_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 定时器, SIGALRM",
    "date": "2023-07-05 10:16:00 +0800",
    





    
    "snippet": "SIGALRM  本节介绍了第二种定时方法：利用SIGALRM信号完成定时任务。它的原理是alarm和setitimer函数设置的实时闹钟一旦超时，将会触发SIGALRM信号，然后我们可以通过SIGALRM的信号处理函数来处理定时任务。我们采用升序链表的数据结构封装了一个简单的定时器，然后通过处理非活动连接来展示该定时器的用法。SIGALRM如果alarm和setitimer函数设置的实时闹...",
    "content": "SIGALRM  本节介绍了第二种定时方法：利用SIGALRM信号完成定时任务。它的原理是alarm和setitimer函数设置的实时闹钟一旦超时，将会触发SIGALRM信号，然后我们可以通过SIGALRM的信号处理函数来处理定时任务。我们采用升序链表的数据结构封装了一个简单的定时器，然后通过处理非活动连接来展示该定时器的用法。SIGALRM如果alarm和setitimer函数设置的实时闹钟一旦超时，将会触发SIGALRM信号。所以我们可以利用该信号的信号处理函数来处理定时任务。注意：如果要处理多个定时任务，我们需要不断触发SIGALRM信号。一般而言，SIGALRM信号按照固定频率生成(由alarm和setitimer函数设置的周期T决定)。如果某个定时任务的超时时间不是T的整数倍，那么该任务的实际执行时间会有偏差。因此定时周期T反映了定时的精度。基于升序链表的定时器定时器必须包含的成员：  超时时间(相对时间或绝对时间)  任务回调函数其他可能包含的成员：  回调函数执行时的传入参数  是否重启定时器等信息  如果用链表管理定时器，还包含指向下一个定时器的指针  …我们给出一种简单的定时器实现：#ifndef LST_TIMER#define LST_TIMER#include &lt;time.h&gt;#define BUFFER_SIZE 64class util_timer;//  用户数据结构struct client_data{  sockaddr_in address;    //  客户端socket地址  int sockfd;             //  socket文件描述符  char buf[BUFFER_SIZE];  //  读缓存  util_timer *timer;      //  定时器};//  定时器类class util_timer{public:  util_timer():prev(NULL),next(NULL){}public:  time_t expire;                //  任务超时时间，这里采用绝对时间  void (*cb_func)(client_data*);//  任务回调函数  client_data *user_data;       //  回调函数传入的客户数据  util_timer *prev;             //  指向前一个定时器  util_timer *next;             //  指向下一个定时器};//  定时器链表:升序、双向链表、双指针class sort_timer_lst{public:  sort_timer_lst():head(NULL),tail(NULL){}  //  析构函数  ~sort_timer_lst()  {    util_timer *tmp = head;    while(tmp){      head = tmp-&gt;next;      delete tmp;      tmp = head;    }  }  //  将定时器timer添加到链表中  void add_timer(util_timer *timer)  {    if(!timer){      return;    }    if(!head){      head = tail = timer;      return;    }    //  如果目标定时器超时时间小于当前链表所有定时器的超时时间，则插入链表头部    if(timer-&gt;expire &lt; head-&gt;expire){      timer-&gt;next = head;      head-&gt;prev = timer;      head = timer;      return;    }    //  否则，调用重载函数add_timer将它插入链表中合适的位置，以保证链表的升序特性    add_timer(timer, head);  }  //  当某个定时任务发生变化，调整定时器在链表中的位置  //  这里只考虑定时器超时时间延长的情况，即定时器向链表尾部移动  void adjust_timer(util_timer *timer)  {    if(!timer){      return;    }    util_timer *tmp = timer-&gt;next;    //  如果被调整的定时器在链表尾部，或调整后仍小于下一个定时器的超时时间，则不用调整    if(!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)){      return;    }    //  如果被调整的定时器是链表头结点，则将该定时器从链表中取出，再重新插入链表    if(timer == head){      head = head-&gt;next;      head-&gt;prev = NULL;      timer-&gt;next = NULL;      add_timer(timer, head);    }    //  如果被调整的定时器不是链表的头结点，则将该定时器从链表中取出，然后插入其原来所在位置之后的部分链表中    else{      timer-&gt;prev-&gt;next = timer-&gt;next;      timer-&gt;next-&gt;prev = timer-&gt;prev;      add_timer(timer, timer-&gt;next);    }  }  //  将目标定时器timer从链表中删除  void del_timer(util_timer *timer)  {    if(!timer){      return;    }    //  链表中只有一个定时器    if((timer == head) &amp;&amp; (timer == tail)){      delete timer;      head = NULL;      tail = NULL;      return;    }    //  如果链表中至少有两个定时器，且目标定时器是链表头结点    if(timer == head){      head = head-&gt;next;      head-&gt;prev = NULL;      delete timer;      return;    }    //  如果链表中至少有两个定时器，且目标定时器是尾结点    if(timer == tail){      tail = tail-&gt;prev;      tail-&gt;next = NULL;      delete timer;      return;    }    //  如果定时器位于链表中间    timer-&gt;prev-&gt;next = timer-&gt;next;    timer-&gt;next-&gt;prev = timer-&gt;prev;    delete timer;  }  //  SIGALRM信号被触发，就在信号处理函数中执行一次tick函数，处理到期任务  void tick()  {    if(!head){      return;    }    printf(\"timer tick\\n\");    time_t cur = time(NULL);  //  获取当前系统时间    util_timer *tmp = head;    //  从头结点依次处理每个定时器    while(tmp){      if(cur &lt; tmp-&gt;expire){        //  当前定时任务未超时        break;      }      //  调用定时器的回调函数，执行定时任务      tmp-&gt;cb_func(tmp-&gt;user_data);      //  执行完毕后，从列表中删除      head = tmp-&gt;next;      if(head){        head-&gt;prev = NULL;      }      delete tmp;      tmp = head;    }  }private:  //  重载函数：将目标定时器timer添加到结点lst_head之后的部分链表中  void add_timer(util_timer *timer, util_timer *lst_head)  {    util_timer *prev = lst_head;    util_timer *tmp = prev-&gt;next;    while(tmp){      if(timer-&gt;expire &lt; tmp-&gt;expire){        prev-&gt;next = timer;        timer-&gt;next = tmp;        tmp-&gt;prev = timer;        timer-&gt;prev = prev;        break;      }      prev = tmp;      tmp = tmp-&gt;next;    }    //  遍历完整个链表仍未找到超时时间大于目标定时器超时时间的结点，则插入链表尾部    if(!tmp){      prev-&gt;next = timer;      timer-&gt;prev = prev;      timer-&gt;next = NULL;      tail = timer;    }  }private:  util_timer *head;  util_timer *tail;};#endifsort_timer_lst是一个升序链表，其核心函数tick每隔一段固定时间执行一次，检测并处理到期的任务。sort_timer_lst添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)，指定定时任务的时间复杂度是O(1)。随着定时器的增加，sort_timer_lst的插入效率会下降。处理非活动连接我们用上面的简单定时器来处理非活动连接。 服务器程序通常要定期处理非活动连接(重连或关闭)，在Linux内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过socket选项的KEEPALIVE激活。不过这种方式会使应用程序对连接的管理变得复杂，因此我们可以考虑在应用层实现类似于KEEPALIVE的机制。#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#include \"lst_timer.h\"#define FD_LIMIT 65535#define MAX_EVENT_NUMBER 1024#define TIMESLOT 5static int pipefd[2];static sort_timer_lst timer_lst;  //  定时器static int epollfd = 0;int setnonblocking(int fd){\tint old_option = fcntl(fd, F_GETFL);\tint new_option = old_option | O_NONBLOCK;\tfcntl(fd, F_SETFL, new_option);\treturn old_option;}void addfd(int epollfd, int fd){\tepoll_event event;\tevent.data.fd = fd;\tevent.events = EPOLLIN | EPOLLET;\tepoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);\tsetnonblocking(fd);}void sig_handler(int sig){  int save_errno = errno;  int msg = sig;  send(pipefd[1], (char *)&amp;msg, 1, 0);  errno = save_errno;}void addsig(int sig){  struct sigaction sa;  memset(&amp;sa, '\\0', sizeof(sa));  sa.sa_handler = sig_handler;  sa.sa_flags |= SA_RESTART;  sigfillset(&amp;sa.sa_mask);  assert(sigaction(sig, &amp;sa, NULL) != -1);}void timer_handler(){  //  定时处理任务  timer_lst.tick();  //  因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时  alarm(TIMESLOT);}//  定时器回调函数void cb_func(client_data *user_data){  //  删除非活动连接在socket上的注册事件  epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, 0);  assert(user_data);  close(user_data-&gt;sockfd);   //  关闭socket  printf(\"close fd %d\\n\", user_data-&gt;sockfd);}int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char* ip = argv[1];  int port = atoi(argv[2]);  int ret = 0;  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int listenfd = socket(PF_INET, SOCK_STREAM, 0);  assert(listenfd &gt;= 0);  ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(listenfd, 5);  assert(ret != -1);  epoll_event events[MAX_EVENT_NUMBER];  int epollfd = epoll_create(5);  assert(epollfd != -1);  addfd(epollfd, listenfd);  ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);  assert(ret != -1);  setnonblocking(pipefd[1]);  addfd(epollfd, pipefd[0]);  //  设置信号处理函数  addsig(SIGALRM);  addsig(SIGTERM);  bool stop_server = false;  bool timeout = false;  client_data *users = new client_data[FD_LIMIT];  alarm(TIMESLOT);  //  定时  while(!stop_server){    int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);    if((number &lt; 0) &amp;&amp; (errno != EINTR)){      printf(\"epoll failure\\n\");      break;    //  这里不能直接return，因为文件描述符和管道还没close    }    for(int i = 0 ; i &lt; number ; i++){      int sockfd = events[i].data.fd;      //  处理新到的客户连接      if(sockfd == listenfd){        struct sockaddr_in client_address;        socklen_t client_addrlength = sizeof(client_address);        int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);        addfd(epollfd, connfd);        users[connfd].address = client_address;        users[connfd].sockfd = connfd;        //  创建定时器，绑定用户数据        util_timer *timer = new util_timer;        timer-&gt;user_data = &amp;users[connfd];        timer-&gt;cb_func = cb_func;   //  超时则删除该连接        time_t cur = time(NULL);        timer-&gt;expire = cur + 3 * TIMESLOT;        users[connfd].timer = timer;        timer_lst.add_timer(timer);      }      //  处理信号      else if((sockfd == pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)){        int sig;        char signals[1024];        ret = recv(pipefd[0], signals, sizeof(signals), 0);        if(ret == -1){          //  handle the error          continue;        }else if(ret == 0){          continue;        }else{          for(int i = 0 ; i &lt; ret ; i++){            switch(signals[i]){              case SIGALRM:{                //  用timeout表示有定时任务需要处理，但不立即处理                //  因为定时任务的优先级不高，我们优先处理其他重要任务                timeout = true;                break;              }              case SIGTERM:{                stop_server = true;              }            }          }        }\t    }      //  处理客户连接上接收到的数据      else if(events[i].events &amp; EPOLLIN){        memset(users[sockfd].buf, '\\0', BUFFER_SIZE);        ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - 1, 0);        printf(\"get %d bytes of client data %s from %d\\n\", ret, users[sockfd].buf, sockfd);        util_timer *timer = users[sockfd].timer;        if(ret &lt; 0){          //  如果发生都错误，则关闭连接，删除对应的定时器          if(errno != EAGAIN){            cb_func(&amp;users[sockfd]);            if(timer){              timer_lst.del_timer(timer);            }          }        }else if(ret == 0){          //  如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器          cb_func(&amp;users[sockfd]);            if(timer){              timer_lst.del_timer(timer);            }        }else{          //  如果某个客户连接上有数据可读，则我们需要调整定时器，延迟该链接被关闭的时间          if(timer){            time_t cur = time(NULL);            timer-&gt;expire = cur + 3 * TIMESLOT;            printf(\"adujst timer once\\n\");            timer_lst.adjust_timer(timer);          }        }      }else{        //  other      }    }    //  最后处理定时任务，因为IO时间优先级更高    if(timeout){      timer_handler();      timeout = false;    }  }  close(listenfd);  close(pipefd[0]);  close(pipefd[1]);  delete[] users;  return 0;}总结      如果alarm和setitimer函数设置的实时闹钟一旦超时，将会触发SIGALRM信号。所以我们可以利用该信号的信号处理函数来处理定时任务  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  不同的二叉搜索树 Ⅱ",
    "url": "/posts/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
    "categories": "leetcode",
    "tags": "leetcode, Recursion, Dynamic Programming",
    "date": "2023-07-04 20:39:00 +0800",
    





    
    "snippet": "递归/动态规划  该题要求给定数字n，求出n个结点能组成多少种结构的二叉搜索树。该题需要利用二叉搜索树的特点，无论递归还是动态规划，都是先求低维的二叉搜索树结果，不断拼接出更高维的结果。题目给你一个整数 n ，请你生成并返回所有由 n 个结点组成且结点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。例子示例1输入：n = 3输出：[[1,null,2,null,3...",
    "content": "递归/动态规划  该题要求给定数字n，求出n个结点能组成多少种结构的二叉搜索树。该题需要利用二叉搜索树的特点，无论递归还是动态规划，都是先求低维的二叉搜索树结果，不断拼接出更高维的结果。题目给你一个整数 n ，请你生成并返回所有由 n 个结点组成且结点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。例子示例1输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]示例2输入：n = 1输出：[[1]]条件  1 &lt;= n &lt;= 8难点分析该题的难点在于利用二叉搜索树性质，找出所有可能的情况。我们提供以下四种思路：  暴力法暴力法就是通过回溯得到所有情况，缺点是效率低，存在重复值，没有有效利用二叉搜索树的性质。算法思路大概如下：递归{    递归出口;    for(int i = 1 ; i &lt;= n ; i++){        向二叉搜索树插入i        判断是否符合条件        移除二叉搜索树中的i    }}  递归我们在上述方法的基础上，利用二叉搜索树的性质。对于1…n的所有可能：  如果1是根结点，左子树为[]，右子树为[2…n]的所有可能情况  如果2是根结点，左子树是[1]，右子树是[3…n]的所有可能情况  …而右子树的诸多情况，我们可以继续递归拆解为左子树和右子树，使问题规模越来越小。算法思路大概如下：递归{    递归出口;    for(int i = start ; i &lt;= end ; i++){        以i为中间结点，拆解为左子树和右子树        左子树为[start...i-1]的所有可能情况        右子树为[i+1...end]的所有可能情况        组合所有可能的情况    }}  动态规划我们按照上面递归的思路，将目标二叉搜索树拆解成左、右子树两部分，我们用一个数组来记录每部分的结构，代替递归栈中存储的结果。比如对于结点数为n的二叉搜索树，某次构造中，以i为中间结点：  左子树为[1…i-1]的所有可能情况  右子树为[i+1…n]的所有可能情况我们把长度为m的所有可能情况存储在数组dp[m]中，这样我们可以直接取出所有可能的左子树进行拼接。对于右子树，长度为m的右子树结构和长度为m的左子树结构是一致的，所以我们同样可以从数组dp[m]中取出右子树结构。但区别是右子树是从i+1开始计数的，而数组dp[m]中存储的是从1开始计数的子树结构。所以我们还需要多进行一步操作：修改右子树结构的值。  动态规划2第四种方法的思想是：我们新增加的数字会大于前面所有的数字，也就是说新增加的数字只能是根结点和右结点。所以，我们保存前一次的结果，然后根据n-1的结果，先将新增加的数字作为根结点，然后将这些结果作为根结点的左子树。接着将新增加的数字插入这些结果中所有可能的右结点的位置。对于下边的解   2 /1然后增加 31.把 3 放到根结点    3   /  2 /12. 把 3 放到根结点的右孩子   2  / \\ 1   3 对于下边的解 1  \\   2然后增加 31.把 3 放到根结点     3    /   1    \\     2       2. 把 3 放到根结点的右孩子，原来的子树作为 3 的左孩子             1        \\         3        /      23. 把 3 放到根结点的右孩子的右孩子  1    \\     2      \\       3解法解法1：递归class Solution {public:    vector&lt;TreeNode*&gt; generateTrees(int n) {        return dfs(1, n);    }    vector&lt;TreeNode*&gt; dfs(int start, int end){        vector&lt;TreeNode*&gt; res;        if(start &gt; end){            res.push_back(nullptr);        }else if(start == end){            res.push_back(new TreeNode(start));        }else{            for(int i = start ; i &lt;= end ; i++){                //  拆解左子树、右子树                vector&lt;TreeNode*&gt; leftTrees = dfs(start, i - 1);                vector&lt;TreeNode*&gt; rightTrees = dfs(i + 1, end);                //  组合所有可能的情况                for(auto &amp;lt : leftTrees){                    for(auto &amp;rt : rightTrees){                        TreeNode *cur = new TreeNode(i);                        cur-&gt;left = lt;                        cur-&gt;right = rt;                        res.push_back(cur);                    }                }            }           }        return res;    }};解法2：动态规划class Solution {public:    vector&lt;TreeNode*&gt; generateTrees(int n) {        vector&lt;vector&lt;TreeNode*&gt;&gt; dp(n + 1, vector&lt;TreeNode*&gt;());        dp[0].push_back(nullptr);        for(int i = 1 ; i &lt;= n ; i++){            for(int j = 1 ; j &lt;= i ; j++){                for(auto &amp;l : dp[j - 1]){   //  左子树结构                    for(auto &amp;r : dp[i - j]){   //  右子树结构                        TreeNode *p = new TreeNode(j);                        p-&gt;left = l;    //  拼接                        TreeNode *c;                        //  dp[i]中存储的是结构，右子树部分结构相同，但是数值不同                        //  所以我们复制一棵树，然后修改它的值                        c = copyTree(r);                         int k = j;                        setValue(c, k); //  修改值                        p-&gt;right = c;   //  拼接                        dp[i].push_back(p);                    }                }            }        }        return dp.back();    }    TreeNode * copyTree(TreeNode *root){        if(root == nullptr){            return nullptr;        }        TreeNode *newTree = new TreeNode(root-&gt;val);        newTree-&gt;left = copyTree(root-&gt;left);        newTree-&gt;right = copyTree(root-&gt;right);        return newTree;    }    void setValue(TreeNode *root, int &amp;i){        if(root == nullptr){            return;        }        setValue(root-&gt;left, i);        root-&gt;val = ++i;        setValue(root-&gt;right, i);    }         /*    // 优化：copyTree和setValue函数可以拼接到一起，在复制树的过程中加上一个偏移值    TreeNode * copyTree(TreeNode *root, int offset){        if(root == nullptr){            return nullptr;        }        TreeNode *newTree = new TreeNode(root-&gt;val + offset);        newTree-&gt;left = copyTree(root-&gt;left, offset);        newTree-&gt;right = copyTree(root-&gt;right, offset);        return newTree;    }    */};解法3：动态规划2class Solution {public:    vector&lt;TreeNode*&gt; generateTrees(int n) {        vector&lt;TreeNode*&gt; pre;        pre.push_back(nullptr);        for(int i = 1 ; i &lt;= n ; i++){            vector&lt;TreeNode*&gt; cur;            for(auto &amp;root : pre){  //  i作为根结点                TreeNode *p = new TreeNode(i);                p-&gt;left = root;                cur.push_back(p);                for(int j = 0 ; j &lt;= n ; j++){  //  i插入各个位置的右结点                    TreeNode *rootCopy = copyTree(root);                    TreeNode *right = rootCopy;                    for(int k = 0 ; k &lt; j ; k++){                        if(right == nullptr){                            break;                        }                        right = right-&gt;right;                    }                    if(right == nullptr){                        break;                    }                    TreeNode *tmp = right-&gt;right;                    p = new TreeNode(i);                    right-&gt;right = p;                    p-&gt;left = tmp;                    cur.push_back(rootCopy);                }            }            pre = cur;        }        return pre;    }    TreeNode * copyTree(TreeNode *root){        if(root == nullptr){            return nullptr;        }        TreeNode *newTree = new TreeNode(root-&gt;val);        newTree-&gt;left = copyTree(root-&gt;left);        newTree-&gt;right = copyTree(root-&gt;right);        return newTree;    }};Reference[1] 不同的二叉搜索树 II [2] 详细通俗的思路分析，多解法"
  },
  
  {
    "title": "读书笔记 —— 定时器_3",
    "url": "/posts/%E5%AE%9A%E6%97%B6%E5%99%A8_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 定时器, IO复用",
    "date": "2023-07-04 16:18:00 +0800",
    





    
    "snippet": "IO复用系统调用定时  本节介绍了最后一种定时方法：利用IO复用系统调用中的超时参数实现定时事件的处理。我们通过一个例子来展示如果统一处理定时事件。IO复用系统调用定时Linux提供了3中IO复用系统调用都有超时参数，所以我们可以利用IO复用技术处理定时事件。接下来我们通过一个简单的例子展示IO复用技术如何处理定时任务：#define TIMEOUT 5000int timeout = TI...",
    "content": "IO复用系统调用定时  本节介绍了最后一种定时方法：利用IO复用系统调用中的超时参数实现定时事件的处理。我们通过一个例子来展示如果统一处理定时事件。IO复用系统调用定时Linux提供了3中IO复用系统调用都有超时参数，所以我们可以利用IO复用技术处理定时事件。接下来我们通过一个简单的例子展示IO复用技术如何处理定时任务：#define TIMEOUT 5000int timeout = TIMEOUT;time_t start = time(NULL);time_t end = time(NULL);while(1){  printf(\"the timeout is now %d mil-seconds\\n\", timeout);  start = time(NULL);  int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);  if((number &lt; 0) &amp;&amp; (errno != EINTR)){    printf(\"epoll failure\\n\");    break;  }  //  如果epoll_wait成功返回0，说明超时时间到  if(number == 0){    //  处理定时任务    timeout = TIMEOUT;  //  重置定时时间    continue;  }  end = time(NULL);  //  如果epoll_wait返回值大于0，本次epoll_wait调用持续时间是(end - start) * 1000  //  所以我们需要减去这段时间，获得下次epoll_wait调用的超时参数  timeout -= (end - start) * 1000;  //  重新计算后的timeout值可能为0，说明本次epoll_wait调用不仅有就绪事件，超时事件也恰好到达  if(timeout &lt; 0){    //  处理定时任务    timeout = TIMEOUT;  //  重置定时时间  }  //  handle connections}总结      Linux提供了3中IO复用系统调用都有超时参数，所以我们可以利用IO复用技术统一处理定时事件  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 定时器_1",
    "url": "/posts/%E5%AE%9A%E6%97%B6%E5%99%A8_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 定时器, SO_RCVTIMEO, SO_SNDTIMEO",
    "date": "2023-07-04 15:40:00 +0800",
    





    
    "snippet": "定时器/SO_RCVTIMEO/SO_SNDTIMEO  本节提到了网络后台通常需要一些定时任务，比如定期检测一个客户连接的活动状态。我们将定时事件封装在一个容器上，便于统一管理，形成了定时器的概念。Linux中提供了三种定时方法: socket的SO_RCVTIMEO和SO_SNDTIMEO选项；SIGALRM信号；IO复用系统调用的超时参数。本节我们先介绍了第一种方法：SO_RCVTIM...",
    "content": "定时器/SO_RCVTIMEO/SO_SNDTIMEO  本节提到了网络后台通常需要一些定时任务，比如定期检测一个客户连接的活动状态。我们将定时事件封装在一个容器上，便于统一管理，形成了定时器的概念。Linux中提供了三种定时方法: socket的SO_RCVTIMEO和SO_SNDTIMEO选项；SIGALRM信号；IO复用系统调用的超时参数。本节我们先介绍了第一种方法：SO_RCVTIMEO和SO_SNDTIMEO。它们分别用来设置socket接收数据和发送数据的超时时间。最后我们通过一个例子展示了如何通过SO_RCVTIMEO和SO_SNDTIMEO设置定时任务。定时器  定时事件：在预期时间点触发，并且不影响服务器的主要逻辑，比如定期检测一个客户连接的活动状态。  Linux中提供了三种定时方法：          socket选项的SO_RCVTIMEO和SO_SNDTIMEO      SIGALRM信号      IO复用系统调用的超时参数        定时器：将每个定时事件封装成定时器，用某种容器类数据结构管理，包括链表、排序链表、时间轮、时间堆等。SO_RCVTIMEO/SO_SNDTIMEOSO_RCVTIMEO和SO_SNDTIMEO是socket的选项，分别用来设置socket接收数据和发送数据的超时时间。这两个选项仅对数据接收和发送相关的socket专用系统调用有效，包括send、sendmsg、recv、recvmsg、accept、connect。我们将SO_RCVTIMEO和SO_SNDTIMEO对这些系统调用的影响总结于下表：            系统调用      有效选项      超时后的行为                  send      SO_SNDTIMEO      返回-1，并设置errno为EAGAIN或EWOULDBLOCK              sendmsg      SO_SNDTIMEO      返回-1，并设置errno为EAGAIN或EWOULDBLOCK              recv      SO_RCVTIMEO      返回-1，并设置errno为EAGAIN或EWOULDBLOCK              recvmsg      SO_RCVTIMEO      返回-1，并设置errno为EAGAIN或EWOULDBLOCK              accept      SO_RCVTIMEO      返回-1，并设置errno为EAGAIN或EWOULDBLOCK              connect      SO_SNDTIMEO      返回-1，并设置errno为EINPROGRESS      我们可以通过这些系统调用的返回值和errno来判断是否超时，进而决定是否开始执行定时任务。我们通过一个例子来展示SO_SNDTIMEO选项如何执行定时任务：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;//  超时连接函数int timeout_connect(const char *ip, int port, int time){  int ret = 0;  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sockfd = socket(PF_INET, SOCK_STREAM, 0);  assert(sockfd &gt;= 0);  //  SO_SNDTIMEO选项设置超时时间的类型的timeval  struct timeval timeout;  timeout.tv_sec = time;  timeout.tv_usec = 0;  socklen_t len = sizeof(timeout);  ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);  assert(ret != -1);  ret = connect(sockfd, (struct sockaddr*)&amp;address, sizeof(address));  if(ret != -1){    //  超时对应的错误号是EINPROGRESS    if(errno == EINPROGRESS){      //  执行超时任务      printf(\"connecting timeout, process timeout logic\\n\");      return -1;    }    printf(\"error occur when connecting to server\\n\");    return -1;  }  return sockfd;}int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char* ip = argv[1];  int port = atoi(argv[2]);  int sockfd = timeout_connect(ip, port, 10);  if(sockfd &lt; 0){    return 1;  }  return 0;}总结      定时事件指在预期时间点触发，并且不影响服务器的主要逻辑    定时器是将每个定时事件封装成定时器，用某种容器类数据结构管理    SO_RCVTIMEO和SO_SNDTIMEO是socket的选项，分别用来设置socket接收数据和发送数据的超时时间  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 信号_3",
    "url": "/posts/%E4%BF%A1%E5%8F%B7_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, SIGHUP, SIGPIPE, SIGURG",
    "date": "2023-07-04 14:44:00 +0800",
    





    
    "snippet": "SIGHUP/SIGPIPE/SIGURG  本节介绍了三个关于网络编程的信号：SIGHUP信号一般是当一个进程的控制终端被挂起时触发，由于网络后台程序没有控制终端，所以常常用来强制服务器重读配置文件。SIGPIPE信号则是往一个读端关闭的管道或关闭的socket连接中写数据时触发，因为该信号的默认处理行为是关闭程序，所以我们必须处理该信号。SIGURG信号的作用是内核通知应用程序带外数据到...",
    "content": "SIGHUP/SIGPIPE/SIGURG  本节介绍了三个关于网络编程的信号：SIGHUP信号一般是当一个进程的控制终端被挂起时触发，由于网络后台程序没有控制终端，所以常常用来强制服务器重读配置文件。SIGPIPE信号则是往一个读端关闭的管道或关闭的socket连接中写数据时触发，因为该信号的默认处理行为是关闭程序，所以我们必须处理该信号。SIGURG信号的作用是内核通知应用程序带外数据到达，我们可以通过该信号来检测带外数据。SIGHUP当一个进程的控制终端被挂起时，SIGHUP信号就会被触发。网络后台程序没有控制终端，但它们通常利用SIGHUP信号来强制服务器重读配置文件。我们以超级服务程序xinetd为例。  xinetd接收到SIGHUP信号  调用hard_reconfig函数，循环读取/etc/xinetd.d/目录下每个子配置文件，并检测配置文件的变化  如果某个正在运行的子服务的配置文件被修改为停止服务，则xinetd主程序将给子服务程序发送SIGTERM信号结束子服务程序  如果某个正在运行的子服务的配置文件被修改为开启服务，则xinetd主程序将创建新的socket并将其绑定到该服务对应的端口上SIGPIPE默认情况下，往一个读端关闭的管道或关闭的socket连接中写数据会引发SIGPIPE信号，我们需要在代码中捕获并处理该信号(至少忽略)，因为程序接收到SIGPIPE信号的默认行为的结束进程。我们不希望因为错误的写操作而导致程序退出。引发SIGPIPE信号时，写操作异常的errno为EPIPE。解决办法：      我们可以用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号。然后我们通过send函数反馈的errno值来判断管道或socket连接的读端是否已经关闭。        我们可以利用IO复用来检测管道和socket连接的读端是否已经关闭。比如poll，当管道的读端关闭时，写端文件描述符上POLLHUP事件会被触发；当socket连接被对方关闭时，socket上的POLLRDHUP事件会被触发。  SIGURG在Linux中，内核通知应用程序带外数据到达的主要方法有两种：  IO复用比如select系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件。  SIGURG信号我们通过一段代码说明SIGURG信号如何实现带外数据的检测#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#define BUF_SIZE 1024static int connfd;//  SIGURG信号的处理函数void sig_urg(int sig){  int save_errno = errno;  char buffer[BUF_SIZE];  memset(buffer, '\\0', BUF_SIZE);  int ret = recv(connfd, buffer, BUF_SIZE - 1, MSG_OOB);  printf(\"got %d bytes of oob data '%s'\\n\", ret, buffer);  errno = save_errno;}void addsig(int sig, void (*sig_handler)(int)){  struct sigaction sa;  memset(&amp;sa, '\\0', sizeof(sa));  sa.sa_handler = sig_handler;  sa.sa_flags |= SA_RESTART;  sigfillset(&amp;sa.sa_mask);  assert(sigaction(sig, &amp;sa, NULL) != -1);}int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char* ip = argv[1];  int port = atoi(argv[2]);  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sock = socket(PF_INET, SOCK_STREAM, 0);  assert(sock &gt;= 0);  int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(sock, 5);  assert(ret != -1);  struct sockaddr_in client;  socklen_t client_addrlength = sizeof(client);  connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);  if(connfd &lt; 0){    printf(\"errno is %d\\n\", errno);  }else{    addsig(SIGURG, sig_urg);    //  使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组    fcntl(connfd, F_SETOWN, getpid());    char buffer[BUF_SIZE];    while(1){ //  循环接收普通数据      memset(buffer, '\\0', BUF_SIZE);      ret = recv(connfd, buffer, BUF_SIZE - 1, 0);      if(ret &lt;= 0){        break;      }      printf(\"got %d bytes of normal data '%s'\\n\", ret, buffer);    }    close(connfd);  }  close(sock);  return 0;}总结      当一个进程的控制终端被挂起时，SIGHUP信号就会被触发    默认情况下，往一个读端关闭的管道或关闭的socket连接中写数据会引发SIGPIPE信号    在Linux中，内核通过SIGURG信号通知应用程序带外数据到达  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 信号_2",
    "url": "/posts/%E4%BF%A1%E5%8F%B7_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, signal, sigaction, sigset_t, sigprocmask, sigpending",
    "date": "2023-07-03 16:39:00 +0800",
    





    
    "snippet": "signal/sigaction/sigset_t/sigprocmask/sigpending  本节继续探讨关于信号的一些内容，Linux中可以通过signal调用和sigaction调用来为信号设置一个处理函数，后者相比前者功能更加强壮且实现更加健壮。此外，sigaction函数其中一个参数sa_mask可以设置信号掩码，它的类型是sigset_t。我们通常采用sigset_t结构体来...",
    "content": "signal/sigaction/sigset_t/sigprocmask/sigpending  本节继续探讨关于信号的一些内容，Linux中可以通过signal调用和sigaction调用来为信号设置一个处理函数，后者相比前者功能更加强壮且实现更加健壮。此外，sigaction函数其中一个参数sa_mask可以设置信号掩码，它的类型是sigset_t。我们通常采用sigset_t结构体来表示一组信号。我们还可以通过sigprocmask相同调用来直接设置信号掩码。设置了信号掩码的信号会被操作系统挂起，而不会被直接接收，当我们取消该信号的屏蔽时，该挂起的信号会被立即接收。我们可以通过sigpending系统调用来获取被挂起的信号集。signal要为一个信号设置处理函数，需要使用signal系统调用。下面是signal的系统调用，功能是为一个信号设置处理函数，其函数定义如下：#include &lt;signal.h&gt;_sighandler_t signal(int sig, _sighandler_t _handler);参数和返回值：  sig: 要捕获的信号类型  _handler: _sighandler_t类型的函数指针，用于指定信号sig的处理函数  返回值: 成功返回一个函数指针，该函数指针类型是_sighandler_t，这个值是前一次调用signal函数传入的函数指针，或者是默认处理函数指针SIG_DEF(第一次调用signal)。失败则返回SIG_ERR，并设置errnosigactionsigaction系统调用也是用来为信号设置处理函数的，但它比signal函数的功能更加强大。下面是sigaction的系统调用，功能是为一个信号设置处理函数，并可以通过参数指定函数处理时的行为，其函数定义如下：#include &lt;signal.h&gt;int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);参数和返回值：  sig: 要捕获的信号类型  act: 指定信号处理方式  oact: 输出前一次调用时的信号处理方式  返回值: 成功返回0，失败返回-1，并设置errnoact和oact参数都是sigaction结构体类型，其结构体具体定义及含义如下：struct sigaction{#ifdef __USE_POSIX199309  union  {    _sighandler_t sa_handler;   //  指定信号处理函数    void (*sa_sigaction) (int, siginfo_t*, void*);  }__sigaction_handler;  #define sa_handler   __sigaction_handler.sa_handler  #define sa_sigaction __sigaction_handler.sa_sigaction#else  _sighandler_t sa_handler;     //  指定信号处理函数#endif  _sigset_t sa_mask;            //  增加进程的信号掩码，即哪些信号不能发给本进程  int sa_flags;                 //  设置程序收到信号时的行为  void (*sa_restorer)(void);    //  已过时};sa_flags参数的选项及其含义：            选项      含义                  SA_NOCLDSTOP      如果sigaction的sig参数是SIGCHLD，则设置该标志表示子进程暂停时不生成SIGCHLD信号              SA_NOCLDWAIT      如果sigaction的sig参数是SIGCHLD，则设置该标志表示子进程结束时不产生僵尸进程              SA_SIGINFO      使用sa_sigaction作为信号处理函数(而不是默认的sa_handler)，它给进程提供更多的相关信息              SA_ONSTACK      调用由sigaltstack函数设置的可选信号栈上的信号处理函数              SA_RESTART      重新调用被该信号终止的系统调用              SA_NODEFER      当接收到信号并进入其信号处理函数时，不屏蔽该信号。默认情况下，我们期望进程在处理一个信号时不再接收到同种信号，否则将引起一些竞态条件              SA_RESETHAND      信号处理函数执行完毕后，恢复信号的默认处理方式              SA_INTERRUPT      中断系统调用              SA_NOMASK      当接收到信号并进入其信号处理函数时，不屏蔽该信号。默认情况下，我们期望进程在处理一个信号时不再接收到同种信号，否则将引起一些竞态条件              SA_ONESHOT      信号处理函数执行完毕后，恢复信号的默认处理方式              SA_STACK      调用由sigaltstack函数设置的可选信号栈上的信号处理函数      信号集函数前面的sigaction结构体中，信号掩码使用sigset_t的数据结构来表示一组信号。所以在Linux中，信号集可以通过sigset_t来表示，其定义如下：#include &lt;bits/sigset.h&gt;#define _SIGSET_NWORDS (1024 / (8 * sizeof(unsigned long int)))typedf struct{  unsigned long int __val[_SIGSET_NWORDS];} __sigset_t;sigset_t实质上是一个长整型数组，数组的每个元素的每一位表示一个信号。Linux提供了一组函数用来设置、修改、删除和查询信号集：#include &lt;signal.h&gt;int sigemptyset(sigset_t *_set);                      //  清空信号集int sigfillset(sigset_t *_set);                       //  在信号集中设置所有信号int sigaddset(sigset_t *_set, int _signo);            //  将信号_signo添加到信号集中int sigdelset(sigset_t *_set, int _signo);            //  将信号_signo从信号集中删除int sigismember(_const sigset_t *_set, int _signo);   //  判断_signo是否在信号集中sigprocmask我们可以利用sigaction结构体的sa_mask成员来设置进程的信号掩码，除此之外，我们还可以通过sigprocmask函数来设置或查看进程的信号掩码。下面是sigprocmask的系统调用，功能是设置和查看进程的信号掩码，其函数定义如下：#include &lt;signal.h&gt;int sigprocmask(int _how, _const sigset_t *_set, sigset_t *_oset);参数和返回值：  _how: 指定设置进程信号掩码的方式，其参数值及含义见下表  _set: 新的信号掩码。如果_set为NULL，则进程信号掩码不变，可以用来获取进程当前的信号掩码  _oset: 输出原来的信号掩码  返回值: 成功返回0，失败返回-1，并设置errno_how参数及含义(_set参数不能为NULL)：            _how参数      含义                  SIG_BLOCK      新的进程信号掩码是当前值和_set指定信号集的并集              SIG_UNBLOCK      新的进程掩码是的当前值和~_set信号集的交集，因此_set指定的信号集将不被屏蔽              SIG_SETMASK      直接将信号掩码设置为_set      sigpending设置信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，操作系统会将该信号设置为进程的一个被挂起的信号。如果我们取消对被挂起信号的屏蔽，它会立即被进程接收。下面是sigpending的系统调用，功能是获取被挂起的信号集，其函数定义如下：#include &lt;signal.h&gt;int sigpending(sigset_t *set);参数和返回值：  set: 保存被挂起的信号集  返回值: 成功返回0，失败返回-1，并设置errno  参数set是根据其内部数组的某个元素的某一位来表示信号的，所以相同的信号只会记录一次。这就导致相同的被挂起的信号sigpending函数只会反映一次。当我们使用sigprocmask取消被挂起信号的屏蔽时，该信号的处理函数也只会触发一次。统一事件源信号是一种异步事件：信号处理函数和程序的主函数是并发执行的。显然，信号处理函数应该尽快执行完毕，以确保该信号不被屏蔽太久。一种经典的解决方案是：  把信号的主要处理逻辑放到函数的主循环中，当信号处理函数被触发时，它只是简单地通知主函数程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常通过管道来传递信号。为了确保主循环知道管道上有数据可读，我们可以采用IO复用函数来监听管道上的可读事件。这样信号事件就能和其他IO事件一起被处理，这就是统一信号源。下面我们通过一个例子来展示统一信号源的一个简单实现：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#define MAX_EVENT_NUMBER 1024static int pipefd[2];int setnonblocking(int fd){\tint old_option = fcntl(fd, F_GETFL);\tint new_option = old_option | O_NONBLOCK;\tfcntl(fd, F_SETFL, new_option);\treturn old_option;}void addfd(int epollfd, int fd){  epoll_event event;  event.data.fd = fd;  event.events = EPOLLIN | EPOLLET;  epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);  setnonblocking(fd);}//  信号处理函数void sig_handler(int sig){  //  保留原来的errno，在函数最后恢复，保证函数的可重入性  int save_errno = errno;  int msg = sig;  //  这里send值发送1个字节的原因是：本例只考虑SIGHUP、SIGCHLD、SIGTERM、SIGINT这四个信号，只看第一个字节就能区分  send(sig_pipefd[1], (char *)&amp;msg, 1, 0);  //  将信号值写入管道  errno = save_errno;}//  设置信号处理函数void addsig(int sig){  struct sigaction sa;  memset(&amp;sa, '\\0', sizeof(sa));  sa.sa_handler = sig_handler;  sa.sa_flags |= SA_RESTART;  sigfillset(&amp;sa.sa_mask);  assert(sigaction(sig, &amp;sa, NULL) != -1);}int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char *ip = argv[1];  int port = atoi(argv[2]);  int ret = 0;  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int listenfd = socket(PF_INET, SOCK_STREAM, 0);  assert(listenfd &gt;= 0);  ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));  if(ret == -1){    printf(\"errno is %d\\n\", errno);    return 1;  }  ret = listen(listenfd, 5);  assert(ret != -1);  epoll_event events[MAX_EVENT_NUMBER];  int epollfd = epoll_create(5);  assert(epollfd != -1);  addfd(epollfd, listenfd);  ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);  //  创建管道  assert(ret != -1);  setnonblocking(pipefd[1]);  addfd(epollfd, pipefd[0]);  //  设置一些信号处理函数  addsig(SIGHUP);  addsig(SIGCHLD);  addsig(SIGTERM);  addsig(SIGINT);  bool stop_server = false;  while(!stop_server){    int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);    if((number &lt; 0) &amp;&amp; (errno != EINTR)){      printf(\"epoll failure\\n\");      break;    }    for(int i = 0 ; i &lt; number ; i++){      int sockfd = events[i].data.fd;      if(sockfd == listenfd){ //  如果就绪文件描述符是listenfd，则处理新的连接        struct sockaddr_in client_address;        socklen_t client_addrlength = sizeof(client_address);        int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);        addfd(epollfd, connfd);      }else if((sockfd == pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)){  //  如果就绪文件描述符是pipefd[0]，则处理信号        int sig;        char signals[1024];        ret = recv(pipefd[0], signals, sizeof(signals), 0);        if(ret == -1){          continue;        }else if(ret == 0){          continue;        }else{  //  因为每个信号值占1字节，所以按字节逐个接收信号，我们以SIGTERM为例，说明如何安全地终止服务器主循环          for(int i = 0 ; i &lt; ret ; i++){            switch(siagnal[i]){              case SIGCHLD:              case SIGHUP:              {                continue;              }              case SIGTERM:              case SIGINT:              {                stop_server = true;              }            }          }        }      }else{}    }  }  printf(\"close fds\\n\");  close(listenfd);  close(pipefd[0]);  close(pipefd[1]);  return 0;}  许多优秀的IO框架和后台服务器，比如Libevent I/O框架和xinetd超级服务，都是统一处理信号和I/O事件。总结      操作系统提供了signal的系统调用，功能是为一个信号设置处理函数    操作系统提供了sigaction的系统调用，功能是为一个信号设置处理函数，并可以通过参数指定函数处理时的行为    在Linux中，信号集可以通过sigset_t来表示    操作系统提供了sigprocmask的系统调用，功能是设置和查看进程的信号掩码    操作系统提供了sigpending的系统调用，功能是获取被挂起的信号集  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 信号_1",
    "url": "/posts/%E4%BF%A1%E5%8F%B7_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 信号, kill",
    "date": "2023-06-28 20:20:00 +0800",
    





    
    "snippet": "信号/kill  本节初步介绍了信号。信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。我们介绍了信号的来源。进程可以通过kill系统调用向其他进程发送信号，接收信号的进程需要定义一个接收函数来处理。Linux的可用信号都定义在bits/signum.h头文件中，我们列举了标准信号的值及其含义。最后信号可能会中断某些处于阻塞状态的系统调用，并设置errn...",
    "content": "信号/kill  本节初步介绍了信号。信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。我们介绍了信号的来源。进程可以通过kill系统调用向其他进程发送信号，接收信号的进程需要定义一个接收函数来处理。Linux的可用信号都定义在bits/signum.h头文件中，我们列举了标准信号的值及其含义。最后信号可能会中断某些处于阻塞状态的系统调用，并设置errno为EINTR。信号信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux信号来源：  对于前台程序，用户可以通过输入特殊的终端字符来发送信号(比如ctrl+c通常会给进程发送一个中断信号)  系统异常(比如浮点异常和非法内存段访问)  系统状态变化(比如alarm定时器到期将触发SIGALRM信号)  运行kill命令或调用kill函数服务器程序必须处理(至少忽略)一些常见的信号，以免异常终止。killLinux中，一个进程可以通过kill函数给其他进程发送信号。下面是kill的系统调用，功能是给其他进程发送一个信号，其函数定义如下：#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig);参数和返回值：  pid: 目标进程  sig: 发送的信号值  返回值: 成功返回0，失败返回-1，并设置errnokill函数的pid参数及其含义：            pid参数      含义                  pid &gt; 0      信号发送给PID为pid的进程              pid = 0      信号发送给本进程组的其他进程              pid = -1      信号发送给除init进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限              pid &lt; -1      信号发送给组ID为-pid的进程组中的所有成员      kill常见的出错情况及errno的取值：            errno      含义                  EINVAL      无效的信号              EPERM      该进程没有权限发送信号给任何一个目标进程              ESRCH      目标进程或进程组不存在        Linux中所有信号都大于0，如果sig取0，则不发送任何信号。但sig为0可以检测目标进程或进程组是否存在，因为检查工作总是在信号发送之前执行。不过这种检测方式不可靠，一是由于进程PID的回绕，可能导致检测的PID不是我们期望的进程的PID；二是这种检测方法不是原子操作信号处理函数目标进程收到信号后，需要定义一个接收函数来处理。信号处理函数以函数指针定义，可以通过signal调用来为某个信号设置信号处理函数。  下面是信号处理函数的原型，功能是处理接收到的信号，其函数定义如下：#include &lt;signal.h&gt;typedf void (*__sighandler_t)(int); //  用函数指针的写法是因为信号处理函数一般都用于做回调函数信号处理函数只有一个整型参数，该参数指定信号类型。信号处理函数是可重入的，否则容易引发一些竞态条件。所以信号处理函数中禁止调用一些不安全的函数。除了用户自定义信号处理函数外，bits/signum.h头文件还定义了其他两种信号处理方式：#include &lt;bits/signum.h&gt;#define SIG_DFL ((__sighandler_t) 0)    //  将0/1强制转换为__sighandler_t类型，这是编译器一些约定的写法#define SIG_IGN ((__sighandler_t) 1)  SIG_IGN表示忽略目标信号  SIG_DFL表示使用信号的默认处理方式，信号的默认处理方式有：          结束进程(Term)      忽略信号(Ign)      结束进程并生成核心转储文件(Core)      暂停进程(Stop)      继续进程(Cont)      Linux信号Linux的可用信号都定义在bits/signum.h头文件中，包括标准信号和POSIX实时信号。Linux标准信号：            信号      起源      默认行为      含义                  SIGHUP      POSIX      结束进程      控制终端挂起              SIGINT      ANSI      结束进程      键盘输入以中断进程(Ctrl+C)              SIGQUIT      POSIX      结束进程并生成核心转储文件      键盘输入使进程退出(Ctrl+\\)              SIGILL      ANSI      结束进程并生成核心转储文件      非法指令              SIGTRAP      POSIX      结束进程并生成核心转储文件      断点陷阱，用于调试              SIGABRT      ANSI      结束进程并生成核心转储文件      进程调用abort函数时生成该信号              SIGIOT      4.2 BSD      结束进程并生成核心转储文件      和SIGABRT相同              SIGBUS      4.2 BSD      结束进程并生成核心转储文件      总线错误，错误内存访问              SIGFPE      ANSI      结束进程并生成核心转储文件      浮点异常              SIGKILL      POSIX      结束进程      终止一个进程，该信号不可被捕获或忽略              SIGUSR1      POSIX      结束进程      用户自定义信号一              SIGSEGV      ANSI      结束进程并生成核心转储文件      非法内存段引用              SIGUSR2      POSIX      结束进程      用户自定义信号二              SIGPIPE      POSIX      结束进程      往读端被关闭的管道或者socket连接中写数据              SIGALRM      POSIX      结束进程      由alarm或setitimer设置的实时闹钟超时引起              SIGTERM      ANSI      结束进程      终止进程，kill命令默认发送的信号是SIGTERM              SIGSTKFLT      Linux      结束进程      早期的Linux使用该信号来报告数学协处理器栈错误              SIGCLD      System V      忽略信号      子进程状态发生变化(退出或暂停)              SIGCHLD      POSIX      忽略信号      子进程状态发生变化(退出或暂停)              SIGCONT      POSIX      继续进程      启动被暂停的进程(Ctrl+Q)，如果目标进程未处于暂停状态，则信号被忽略              SIGSTOP      POSIX      暂停进程      暂停进程(Ctrl+S)。该信号不可被捕获或忽略              SIGTSTP      POSIX      暂停进程      挂起进程(Ctrl+Z)              SIGTTIN      POSIX      暂停进程      后台进程试图从中断读取输入              SIGTTOU      POSIX      暂停进程      后台进程试图往中断输出内容              SIGURG      4.2 BSD      忽略信号      socket连接上收到紧急数据              SIGXCPU      4.2 BSD      结束进程并生成核心转储文件      进程的CPU时间超过其软限制              SIGXFSZ      4.2 BSD      结束进程并生成核心转储文件      文件尺寸超过其软限制              SIGVTALRM      4.2 BSD      结束进程      与SIGALRM类似，不过它只统计本进程用户空间代码的运行时间              SIGPROF      4.2 BSD      结束进程      与SIGALRM类似，它同时统计用户代码和内核的运行时间              SIGWINCH      4.2 BSD      忽略信号      终端窗口大小发生变化              SIGPOLL      System V      结束进程      IO就绪              SIGIO      4.2 BSD      结束进程      IO就绪，比如socket上发生可读、可写事件。因为TCP服务器可触发SIGIO的条件很多，故而SIGIO无法在TCP服务器中使用。SIGIO信号可用于UDP服务器中，不过也非常少见              SIGPWR      System V      结束进程      用于使用UPS(Uninterruptable Power Supply)系统，当电池电量过低时，SIGPWR信号将被触发              SIGSYS      POSIX      结束进程并生成核心转储文件      非法系统调用              SIGUNUSED             结束进程并生成核心转储文件      保留，通常和SIGSYS效果相同      中断系统调用如果某些系统调用处于阻塞状态(比如connect、epoll_wait)，这时程序接收到信号，且我们为该信号设置了信号处理函数，默认情况下系统调用将会被中断，并设置errno为EINTR。我们可以使用sigaction函数为信号设置SA_RESTART标志来自动重启被中断的系统调用。对于默认行为是暂停进程的信号(比如SIGSTOP、SIGTTIN)，我们即使没有设置信号处理函数，也会中断某些系统调用(比如connect、epoll_wait)。这时Linux独有的，POSIX中没有规定这种行为。总结      信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常    操作系统提供了kill的系统调用，功能是给其他进程发送一个信号    目标进程收到信号后，需要定义一个接收函数来处理    Linux的可用信号都定义在bits/signum.h头文件中，包括标准信号和POSIX实时信号    信号可能会中断某些处于阻塞状态的系统调用，并设置errno为EINTR  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— IO复用_poll",
    "url": "/posts/IO%E5%A4%8D%E7%94%A8_poll/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, poll, IO复用",
    "date": "2023-06-26 19:31:00 +0800",
    





    
    "snippet": "poll  本节讲解了IO复用的其中一种系统调用——poll。我们首先介绍了poll的API。它的就绪条件和select调用一样，所以我们不再过多阐述。在最后我们将三种IO复用技术进行比较。poll API下面是poll的系统调用，功能和select类似，在指定时间内轮询一定数量的文件描述符，测试其中是否有就绪项，其函数定义如下：#include &lt;poll.h&gt;int poll...",
    "content": "poll  本节讲解了IO复用的其中一种系统调用——poll。我们首先介绍了poll的API。它的就绪条件和select调用一样，所以我们不再过多阐述。在最后我们将三种IO复用技术进行比较。poll API下面是poll的系统调用，功能和select类似，在指定时间内轮询一定数量的文件描述符，测试其中是否有就绪项，其函数定义如下：#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);参数和返回值：  fds: 指定所有被监听的文件描述符，这些文件描述符会被监听可读、可写和异常等事件  nfds: 被监听事件集合的大小，其中nfds_t定义为：typedef unsigned long int nfds_t;  timeout: 指定poll的超时值，单位是毫秒          如果timeout设置为-1，则poll调用将永远阻塞，直到某个事件发生      如果timeout设置为0，则poll调用会立即返回        返回值: 根据超时情况或是否被信号中断，存在以下几种返回情况：          成功返回就绪(可读、可写或异常)文件描述符的总数      如果在超时时间内没有任何文件描述符就绪，则返回0      失败返回-1，并设置errno      如果poll在等待期间接收到信号，则立即返回-1，并设置errno位EINTR      fds参数的类型是pollfd结构体数组指针，pollfd结构体的定义如下：struct pollfd{    int fd;         //  文件描述符    short events;    //  注册事件    short revents;   //  实际发生的事件，由内核写入};pollfd结构体成员含义：  fd: 指定文件描述符  events: 告诉poll监听fd上的哪些事件，它的值由一系列事件的按位或组成  revents: 由内核写入，用来通知应用程序fd实际发生了哪些事件poll支持的事件类型如下表所示：            事件      描述      是否可作为输入      是否可作为输出                  POLLIN      数据(包括普通数据和优先数据)可读      是      是              POLLRDNORM      普通数据可读      是      是              POLLRDBAND      优先数据可读(Linux不支持)      是      是              POLLPRI      高优先级数据可读，比如TCP带外数据      是      是              POLLOUT      数据(包括普通数据和优先数据)可写      是      是              POLLWRNORM      普通数据可写      是      是              POLLWRBAND      优先数据可写      是      是              POLLRDHUP      TCP连接被对方关闭，或对方关闭写操作，它由GNU引入      是      是              POLLERR      错误      否      是              POLLHUP      挂起。比如管道写端被关闭后，读端描述符上将收到POLLHUP事件      否      是              POLLNVAL      文件描述符未打开      否      是      原本应用程序需要根据recv的返回值判断socket上接收的是有效数据还是关闭连接请求。但Linux内核2.6.17之后，GNU为poll系统调用增加了POLLRDHUP事件，用来区分接收的是有效数据还是关闭连接请求。但使用POLLRDHUP事件时，需要在代码最开始处定义_GNU_SOURCE。三种IO复用函数的比较我们从事件集、最大支持文件描述符、工作模式、具体实现四个方面比较三种IO复用函数的异同：  事件集相同之处:  这三种IO复用函数都是通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并且通过这些结构体变量对应的参数获取内核处理结果不同之处：  select的参数类型fd_set没有将文件描述符和事件绑定，而是通过三个类型的参数来区分可读、可写和异常事件的发生。一方面，这使select不能处理更多类型的事件，另一方面应用程序下次调用select前不得不重置这三个fd_set集合  poll的参数类型pollfd则将文件描述符和事件绑定在一起，并且内核每次修改的是结构体中的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数  epoll则是在内核中维护一个事件表，并提供epoll_ctl调用控制内核表，往内核事件表中添加、删除、修改事件。这样每次epoll_wait调用都可以直接从内核事件表中取得用户注册的事件，而无须反复传入这些事件。而且epoll_wait返回就绪的事件集，而select和poll返回所有的事件集，这使得epoll检索就绪文件描述符的时间更快  最大支持文件描述符不同之处：  poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件，这两个数值都能达到系统允许打开的最大文件描述符数目，即65535(/proc/sys/fs/file-max)  select允许监听的最大文件描述符数量通常由限制，虽然可以修改这个限制，但是可能使程序出现BUG  工作模式不同之处：  select和poll只能工作在相对低效的LT模式  epoll可以工作在高效的ET模式，该模式能进一步减少可读、可写和异常等事件被触发的次数  具体实现不同之处：  select和poll都采用轮询的方式，即每次调用都要扫描整个注册文件描述符集合，将其中就绪的文件描述符返回给应用程序  epoll_wait则采用回调的方式，内核检测到就绪文件描述符，将触发回调函数。回调函数会将该文件描述符上对应的事件插入内核就绪事件队列中，在恰当的时机将就绪事件队列中的内容拷贝到用户空间(但是活动连接比较多时，epoll_wait未必高效，因为回调函数过于频繁。所以epoll_wait适用于连接数量比较多，活动连接比较少的情况)最后我们通过一个表总结这三种IO复用函数的区别：            系统调用      select      poll      epoll                  事件集合      用户通过3个参数分别传入感兴趣的可读、可写和异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。这使得用户每次调用select都要重置这3个参数      统一处理所有事件类型，因此只需要一个事件集参数，用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件      内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无须反复传入事件集。epoll_wait系统调用的参数events仅用于反馈就绪的事件              应用程序索引就绪文件描述符的时间复杂度      O(n)      O(n)      O(1)              最大支持文件描述符数量      有最大值限制      65535      65535              工作模式      LT      LT      LT &amp; ET              内核实现和工作效率      采用轮询方式来检测就绪事件，算法时间复杂度为O(n)      采用轮询方式来检测就绪事件，算法时间复杂度为O(n)      采用回调方式来检测就绪算法，算法时间复杂度为O(1)      总结      操作系统提供了poll的系统调用，功能是在指定时间内轮询一定数量的文件描述符，测试其中是否有就绪项  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— IO复用_epoll",
    "url": "/posts/IO%E5%A4%8D%E7%94%A8_epoll/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, epoll, IO复用",
    "date": "2023-06-25 20:00:00 +0800",
    





    
    "snippet": "epoll  本节讲解了IO复用的其中一种系统调用——epoll。epoll其他两种IO复用(select和poll)调用方式不同，它不是单个函数，而是使用一组函数来完成。而且它将文件描述符上的事件都放到内核的一个事件表中，不需要像select和poll那样每次调用都重复传入文件描述符集合或事件集合。我们详细介绍了epoll相关的一系列API，然后介绍了epoll的两种工作模式：LT模式和E...",
    "content": "epoll  本节讲解了IO复用的其中一种系统调用——epoll。epoll其他两种IO复用(select和poll)调用方式不同，它不是单个函数，而是使用一组函数来完成。而且它将文件描述符上的事件都放到内核的一个事件表中，不需要像select和poll那样每次调用都重复传入文件描述符集合或事件集合。我们详细介绍了epoll相关的一系列API，然后介绍了epoll的两种工作模式：LT模式和ET模式。最后我们介绍了EPOLLONESHOT事件，它可以使一个socket连接在任一时刻只能被一个线程处理，保证了连接的完整性，避免了可能的竞态条件。epollepoll是Linux特有的IO复用函数，它和前面介绍了select和poll有以下区别：  epoll使用一组函数来完成任务，而不是单个函数  epoll把用户关心的文件描述符上的事件放到内核的一个事件表中，不需要像select和poll那样每次调用都重复传入文件描述符集合或事件集合epoll_createepoll的内核事件表也是用一个文件描述符来标识，这个文件描述符通过epoll_create调用来创建。下面是epoll_create的系统调用，功能创建指向内核事件表的文件描述符，其函数定义如下：#include &lt;sys/epoll.h&gt;int epoll_create(int size);参数和返回值：  size: 提示内核事件表的大小，但现在并不起作用  返回值: 返回指向内核事件表的文件描述符，作为其他epoll系统调用的参数epoll_ctlLinux提供了epoll_ctl函数来直接操作epoll内核事件表。下面是epoll_ctl的系统调用，功能操作epoll的内核事件表，其函数定义如下：#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);参数和返回值：  epfd: 内核事件表的文件描述符  op: 指定操作类型，取值如下：          EPOLL_CTL_ADD: 往内核事件表中注册fd上的事件      EPOLL_CTL_MOD: 修改fd上的注册事件      EPOLL_CTL_DEL: 删除fd上的注册事件        fd: 要操作的文件描述符  event: 指定事件  返回值: 成功返回0，失败返回-1，并设置errnoevent参数的类型是epoll_event结构体指针，epoll_event结构体的定义如下：struct epoll_event{    __uint32_t events;  //  epoll事件    epoll_data_t data;  //  用户数据};pollfd结构体成员含义：  events: 描述事件类型，epoll支持的事件类型和poll相似，具体取值和含义见下表。  data: 存储用户数据，其类型epoll_data_t的定义如下：typedef union epoll_data{    void *ptr;    int fd;    uint32_t u32;    uint64_t u64;} epoll_data_t;epoll_data_t是一个联合体，它各个成员的含义如下：  ptr: 指定与fd相关的用户数据。但由于联合体的特性，不能同时使用fd和ptr成员。所以如果要将文件描述符和用户数据关联起来，只能使用其他手段，比如放弃epoll_data_t中的fd成员，而在ptr指向的用户数据中包含fd  fd: 指定事件所从属的目标文件描述符。使用的次数最多  u32: 存储一个32位数  u64: 存储一个64位数epoll支持的事件类型如下表所示：            事件      描述      是否可作为输入      是否可作为输出                  EPOLLIN      数据(包括普通数据和优先数据)可读      是      是              EPOLLRDNORM      普通数据可读      是      是              EPOLLRDBAND      优先数据可读(Linux不支持)      是      是              EPOLLPRI      高优先级数据可读，比如TCP带外数据      是      是              EPOLLOUT      数据(包括普通数据和优先数据)可写      是      是              EPOLLWRNORM      普通数据可写      是      是              EPOLLWRBAND      优先数据可写      是      是              EPOLLRDHUP      TCP连接被对方关闭，或对方关闭写操作，它由GNU引入      是      是              EPOLLERR      错误      否      是              EPOLLHUP      挂起。比如管道写端被关闭后，读端描述符上将收到EPOLLHUP事件      否      是              EPOLLET      开启ET工作模式      是      是              EPOLLONESHOT      确保同一时刻只触发一次可读、可写和异常事件，且只触发一次      是      是      epoll_waitepoll_wait是epoll系列系统调用的主要接口，用来等待就绪事件。下面是epoll_wait的系统调用，功能在一段超时时间内等待一组文件描述符上的事件，其函数定义如下：#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);参数和返回值：  epfd: 内核事件表的文件描述符  events: 如果epoll_wait函数检测到事件，就将所有就绪事件从内核事件表中复制到events指向的数组中  maxevents: 指定最多监听多少个事件，必须大于0  timeout: 指定超时时间，单位是毫秒          如果timeout设置为-1，则epoll调用将永远阻塞，直到某个事件发生      如果timeout设置为0，则epoll调用会立即返回        返回值: 成功返回就绪文件描述符的个数，失败返回-1，并设置errnoepoll获取就绪文件描述符的效率大于select和poll。我们先来看poll如何获取就绪文件描述符：//  如何索引poll返回就绪文件描述符int ret = poll(fds, MAX_EVENT_NUMBER, -1);for(int i = 0 ; i &lt; MAX_EVENT_NUMBER ; i++){    if(fds[i].revents &amp; POLLIN){        int sockfd = fds[i].fd;        //  处理sockfd    }}接着，我们来看epoll如何获取就绪文件描述符：int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);for(int i = 0 ; i &lt; ret ; i++){    int sockfd = events[i].data.fd;    //  处理sockfd}我们可以看到epoll得到的events数组只有就绪事件，相比poll得到的所有事件数组events，再依次判断要快。而且我们不需要像select和poll那样将数组用于输入用户注册的事件，又用于输出内核检测到的事件。所以epoll索引就绪文件描述符的效率更快。LT和ET模式epoll对文件描述符的操作有两种模式：LT模式(Level Trigger, 电平触发)和ET模式(Edge Trigger, 边沿触发)。LT模式是默认的工作模式，这种模式下epoll相对于一个效率较高的poll。对于采用LT工作模式的文件描述符，当epoll_wait检测到有事件就绪时，通知应用程序后，但应用程序可以不立即处理该事件。这样，当下一次应用程序调用epoll_wait时，epoll_wait还会再次向应用程序通知该事件，直到事件被处理。而ET模式是epoll的高效工作模式，需要往epoll内核事件中注册文件描述符上的EPOLLET事件来触发。对于采用ET工作模式的文件描述符，当epoll_wait检测到有事件就绪时，通知应用程序后，应用程序必须立即处理该事件，因为后续epoll_wait不会再向应用程序通知这一事件。由于ET模式很大程度降低了同一个epoll事件被重复触发的次数，所以效率要高于LT模式。下面我们通过一个例子来展示LT模式和ET模式的差异：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#define MAX_EVENT_NUMBER 1024#define BUFFER_SIZE 10//  将文件描述符设置成非阻塞的int setnonblocking(int fd){    int old_option = fcntl(fd, F_GETFL);    int new_option = old_option | O_NONBLOCK;    fcntl(fd, F_SETFL, new_option);    return old_option;}//  将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式void addfd(int epollfd, int fd, bool enable_et){    epoll_event event;    event.data.fd = fd;    event.events = EPOLLIN;    if(enable_et){        event.events |= EPOLLET;    }    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);    setnonblocking(fd);}//  LT模式的工作流void lt(epoll_event *events, int number, int epollfd, int listenfd){    char buf[BUFFER_SIZE];    for(int i = 0 ; i &lt; number ; i++){        int sockfd = events[i].data.fd;        if(sockfd == listenfd){     //  处理连接事件            struct sockaddr_in client_address;            socklen_t client_addrlength = sizeof(client_address);            int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);            //  添加读取数据的监听事件            addfd(epollfd, connfd, false);  //  对connfd禁用ET模式        }else if(events[i].events &amp; EPOLLIN){   //  处理读取数据事件            printf(\"event trigger once\\n\");            memset(buf, '\\0', BUFFER_SIZE);            int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);            if(ret &lt;= 0){                //  读取到数据尾部                close(sockfd);                continue;            }            printf(\"get %d bytes of content: %s\\n\", ret, buf);        }else{  //  处理其他事件            printf(\"something else happend\\n\");        }    }}//  ET模式的工作流void et(epoll_event *events, int number, int epollfd, int listenfd){    char buf[BUFFER_SIZE];    for(int i = 0 ; i &lt; number ; i++){        int sockfd = events[i].data.fd;        if(sockfd == listenfd){     //  处理连接事件            struct sockaddr_in client_address;            socklen_t client_addrlength = sizeof(client_address);            int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);            //  添加读取数据的监听事件            addfd(epollfd, connfd, true);  //  对connfd开启ET模式        }else if(events[i].events &amp; EPOLLIN){   //  处理读取数据事件            printf(\"event trigger once\\n\");            while(1){   //  由于读取事件不会被重复触发，所以需要循环读取数据，确保读缓冲区中的所有数据读出                memset(buf, '\\0', BUFFER_SIZE);                int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);                if(ret &lt; 0){                    //  对于非阻塞IO，下面条件成立则表示数据全部读取完毕                    //  此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作                    if((errno == EAGAIN) || (errno == EWOULDBLOCK)){                        printf(\"read later\\n\");                        break;                    }                    close(sockfd);                      break;  //  发生异常，退出循环                }else if(ret == 0){                    close(sockfd);                }else{                    printf(\"get %d bytes of content: %s\\n\", ret, buf);                }            }        }else{  //  处理其他事件            printf(\"something else happend\\n\");        }    }}//  主函数int main(int argc, char *argv[]){    if(argc &lt;= 2){        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));        return 1;    }    const char *ip = argv[1];    int port = atoi(argv[2]);    int ret = 0;    struct sockaddr_in address;    bzero(&amp;address, sizeof(address));    address.sin_family = AF_INET;    inet_pton(AF_INET, ip, &amp;address.sin_addr);    address.sin_port = htons(port);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    assert(listenfd &gt;= 0);    ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    assert(ret != -1);    ret = listen(listenfd, 5);    assert(ret != -1);    epoll_event events[MAX_EVENT_NUMBER];    int epollfd = epoll_create(5);    assert(epollfd != -1);    addfd(epollfd, listenfd, true); //  添加监听socket事件    while(1){        int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);        if(ret &lt; 0){            printf(\"epoll failure\\n\");            break;        }        // lt(events, ret, epollfd, listenfd);     //  使用LT模式        et(events, ret, epollfd, listenfd);  //  使用ET模式    }    close(listenfd);    return 0;}  每个使用ET模式的文件描述符都应该是非阻塞的。因为如果文件描述符是阻塞的，那么读或写操作将会因为没用后续事件而一直处于阻塞状态。EPOLLONESHOT即使我们使用ET模式，一个socket上的事件可能被触发多次，这会导致一个问题：如果一个线程在读完某个socket上的数据后开始处理这些数据，但数据处理过程中，该socket上又传来了新的数据。这时候会有两个工作线程同时操作同一个socket上的数据。而我们期望的是，一个socket连接在任一时刻只能被一个线程处理。epoll提供了EPOLLONESHOT事件来保证这一点。对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写和异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上的EPOLLONESHOT事件。这样，当一个线程处理了某个socket，其他线程就不能再处理该socket了。反过来，该socket被处理完毕，只要我们重置EPOLLONESHOT事件，就能保证该socket下一次有数据传来时，其EPOLLIN事件被触发，进而使其他工作线程能够处理该socket。我们通过一个例子来展示EPOLLONESHOT事件的用法：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#define MAX_EVENT_NUMBER 1024#define BUFFER_SIZE 1024struct fds{    int epollfd;    int sockfd;};//  将文件描述符设置成非阻塞的int setnonblocking(int fd){    int old_option = fcntl(fd, F_GETFL);    int new_option = old_option | O_NONBLOCK;    fcntl(fd, F_SETFL, new_option);    return old_option;}//  将文件描述符fd上的EPOLLIN和EPOLLET注册到epollfd指示的epoll内核事件表中，参数oneshot指定是否注册fd上的EPOLLONESHOT事件void addfd(int epollfd, int fd, bool oneshot){    epoll_event event;    event.data.fd = fd;    event.events = EPOLLIN | EPOLLET;    if(oneshot){        event.events |= EPOLLONESHOT;    }    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);    setnonblocking(fd);}//  重置fd上的事件，这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操作系统仍会触发fd上的EPOLLIN事件，且只触发一次void reset_oneshot(int epollfd, int fd){    epoll_event event;    event.data.fd = fd;    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);}//  工作线程void* worker(void *arg){    int sockfd = ((fds*)arg)-&gt;sockfd;    int epollfd = ((fds*)arg)-&gt;epollfd;    printf(\"start new thread to receive data on fd: %d\\n\", sockfd);    char buf[BUFFER_SIZE];    memset(buf, '\\0', BUFFER_SIZE);    //  循环读取sockfd上的数据，直到遇到EAGAIN错误    while(1){        int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);        if(ret == 0){            close(sockfd);            printf(\"foreigner closed the connection\\n\");            break;        }else if(ret &lt; 0){            if(errno == EAGAIN){                reset_oneshot(epollfd, sockfd);                printf(\"read later\\n\");                break;            }        }else{            printf(\"get content: %s\\n\", buf);            //  休眠5s，模拟数据处理过程            sleep(5);        }    }    printf(\"end thread receiving data on fd: %d\\n\", sockfd);}//  主函数int main(int argc, char *argv[]){    if(argc &lt;= 2){        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));        return 1;    }    const char *ip = argv[1];    int port = atoi(argv[2]);    int ret = 0;    struct sockaddr_in address;    bzero(&amp;address, sizeof(address));    address.sin_family = AF_INET;    inet_pton(AF_INET, ip, &amp;address.sin_addr);    address.sin_port = htons(port);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    assert(listenfd &gt;= 0);    ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    assert(ret != -1);    ret = listen(listenfd, 5);    assert(ret != -1);    epoll_event events[MAX_EVENT_NUMBER];    int epollfd = epoll_create(5);    assert(epollfd != -1);    //  注意：监听socket不能注册EPOLLONESHOT事件，否则应用程序只会处理一个客户连接    //  因为后续的客户连接不会再触发listenfd上的EPOLLIN事件    addfd(epollfd, listenfd, false); //  添加监听socket事件    while(1){        int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);        if(ret &lt; 0){            printf(\"epoll failure\\n\");            break;        }        for(int i = 0 ; i &lt; ret ; i++){ //  处理连接事件            int sockfd = events[i].data.fd;            if(sockfd == listenfd){                struct sockaddr_in client_address;                socklen_t client_addrlength = sizeof(client_address);                int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);                //  对每个非监听文件描述符都注册EPOLLONESHOT事件                addfd(epollfd, connfd, true);            }else if(events[i].events &amp; EPOLLIN){   //  处理数据读取事件                pthread_t thread;                fds fds_for_new_worker;                fds_for_new_worker.epollfd = epollfd;                fds_for_new_worker.sockfd = sockfd;                //  启动一个工作线程位sockfd服务                pthread_create(&amp;thread, NULL, worker, (void*)&amp;fds_for_new_worker);            }else{                printf(\"something else happend\\n\");            }        }    }    close(listenfd);    return 0;}如果一个工作线程处理完某个socket上的一次请求(我们用休眠5s来模拟这个过程)之后，有接收到该socket上的新的客户的请求，则线程将继续为这个socket服务。由于该socket上注册了EPOLLONESHOT事件，所以其他线程没有机会接触这个socket。如果工作线程等待5s后没用收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时调用reset_oneshot函数来重置该socket上的注册事件。这样epoll可以再次检测到该socket上的EPOLLIN事件，是其他工作线程有机会为该socket服务。由此看来，尽管一个socket在不同的时间内可能被不同的线程处理，但同一时刻只有一个线程为该socket服务。这样保证了连接的完整性，避免了可能的竞态条件。总结      操作系统提供了epoll_create的系统调用，功能创建指向内核事件表的文件描述符    操作系统提供了epoll_ctl的系统调用，功能操作epoll的内核事件表    操作系统提供了epoll_wait的系统调用，功能在一段超时时间内等待一组文件描述符上的事件    epoll对文件描述符的操作有两种模式：LT模式和ET模式    采用LT工作模式的文件描述符，当epoll_wait检测到有事件就绪时，通知应用程序后，但应用程序可以不立即处理该事件    采用ET工作模式的文件描述符，当epoll_wait检测到有事件就绪时，通知应用程序后，应用程序必须立即处理该事件，后续poll_wait不会再向应用程序通知这一事件    ET模式很大程度降低了同一个epoll事件被重复触发的次数，所以效率要高于LT模式    注册EPOLLONESHOT事件可以使一个socket连接在任一时刻只能被一个线程处理  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— IO复用_select",
    "url": "/posts/IO%E5%A4%8D%E7%94%A8_select/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, select, IO复用",
    "date": "2023-06-20 21:15:00 +0800",
    





    
    "snippet": "select  本节讲解了IO复用的其中一种系统调用——select。我们首先介绍了select的API，然后列举了触发select的就绪条件的情况。最后通过处理带外数据的例子来展示select调用的用法。IO复用IO复用的场景：  客户端程序要同时处理多个socket  客户端程序要同时处理用户输入和网络连接  TCP服务器要同时处理监听socket和连接socket  服务器要同时处理T...",
    "content": "select  本节讲解了IO复用的其中一种系统调用——select。我们首先介绍了select的API，然后列举了触发select的就绪条件的情况。最后通过处理带外数据的例子来展示select调用的用法。IO复用IO复用的场景：  客户端程序要同时处理多个socket  客户端程序要同时处理用户输入和网络连接  TCP服务器要同时处理监听socket和连接socket  服务器要同时处理TCP请求和UDP请求  服务器要同时监听多个端口，或处理多种服务IO复用的作用就是可以同时监听多个文件描述符，不过IO复用本身是阻塞的。下面我们依次介绍三种IO复用技术：select、poll和epoll。select API我们先介绍select的API，然后讨论select判断文件描述符就绪的条件，最后通过select处理带外数据的例子来展示它的用法。下面是select的系统调用，功能是在一段指定时间内，监听用户指定的文件描述符上的可读、可写和异常等事件，其函数定义如下：#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);参数和返回值：  nfds: 指定被监听的文件描述符的总数。通常设置为所有监听的文件描述符的最大值+1(因为文件描述符从0开始计数的)  readfds: 指向可读事件对应的文件描述符集合  writefds: 指向可写事件对应的文件描述符集合  exceptfds: 指向异常事件对应的文件描述符集合  timeout: 设置select函数的超时事件  返回值: 根据超时情况或是否被信号中断，存在以下几种返回情况：          成功返回就绪(可读、可写或异常)文件描述符的总数      如果在超时时间内没有任何文件描述符就绪，则返回0      失败返回-1，并设置errno      如果select在等待期间接收到信号，则立即返回-1，并设置errno位EINTR      readfds、writefds和exceptfds参数的类型是fd_set结构体的指针，fd_set结构体的定义如下：#include &lt;typesizes.h&gt;#define __FD_SETSIZE 1024#include &lt;sys/select.h&gt;#define FD_SETSIZE __FD_SETSIZEtypedef long int __fd_mask;#undef __NFDBITS#define __NFDBITS (8 * (int)sizeof(__fd_mask))typedef struct{#ifdef __USE_XOPEN__fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];   //  数组长度为32，每个元素长度为4，所以支持最大的文件描述符为128#define __FDS_BITS(set) ((set)-&gt;fds_bits)#else__fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];#define __FDS_BITS(set) ((set)-&gt;__fds_bits)#endif} fd_set;fd_set结构体仅包含一个整型数组，数组大小由FD_SETSIZE决定，也就是说fd_set能容纳的文件描述符数量由FD_SETSIZE指定，限制了select能同时处理的文件描述符的总量。fd_set中数组每个元素的每一位(bit)标记一个文件描述符。当select调用返回时，内核将修改fd_set中的标记来通知应用程序哪些文件描述符已经就绪。由于位操作比较繁琐，所以select.h头文件提供了一系列宏来访问fd_set结构体中的位：#include &lt;sys/select.h&gt;FD_ZERO(fd_set *fdset);                 //  清除fdset的所有位FD_SET(int fd, fd_set *fdset);          //  设置fdset的位fdFD_CLR(int fd, fd_set *fdset);          //  清除fdset的位fdint FD_ISSET(int fd, fd_set *fdset);    //  测试fdset的位fd是否被设置timeout参数的类型是timeval结构体的指针，timeval结构体的定义如下：struct timeval{    long tv_sec;    //  秒数    long tv_usec;   //  微秒数};timeout是一个指针类型，因为内核将会修改变量，从而告诉程序select调用等待了多久。不过select调用返回后的timeout值不一定准确，比如调用失败时，timeout的值是不确定的。注意：如果给timeout变量的tv_sec和tv_usec成员都传递0，select将会立即返回。如果给timeout变量传递NULL，则select会一直阻塞，直到某个文件描述符就绪。文件描述符就绪条件在网络编程中，socket可读的情况：  socket内核接收缓冲区的字节数大于或等于其低水位标记SO_RCVLOWAT  socket通信的对方关闭连接，此时读操作将返回0  监听socket上有新的连接请求  socket上有未处理的错误，我们可以使用getsockopt来读取和清除该错误socket可写的情况：  socket内核发送缓冲区的字节数大于或等于其低水位标记SO_SNDLOWAT  socket写操作被关闭，对写操作被关闭的socket执行写操作会触发SIGPIPE信号  socket使用非阻塞connect连接成功或失败(超时)之后  socket上有未处理的错误，我们可以使用getsockopt来读取和清除该错误socket异常的情况：  socket上接收到了带外数据处理带外数据如果socket接收到普通数据和带外数据，都会使select调用返回，但是前者是处于可读状态，后者是处于异常状态。我们通过一个例子来说明这两种状态：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]){    if(argc &lt;= 2){        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));        return 1;    }    const char *ip = argv[1];    int port = atoi(argv[2]);    int ret = 0;    struct sockaddr_in address;    bzero(&amp;address, sizeof(address));    address.sin_family = AF_INET;    inet_pton(AF_INET, ip, &amp;address.sin_addr);    address.sin_port = htons(port);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    assert(listenfd &gt;= 0);    ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address));    assert(ret != -1);    ret = listen(listenfd, 5);    assert(ret != -1);    struct sockaddr_in client_address;    socklen_t client_addrlength = sizeof(client_address);    int connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);    if(connfd &lt; 0){        printf(\"errno is : %d\\n\", errno);        close(listenfd);        return 1;    }    char buf[1024];    fd_set read_fds;    fd_set except_fds;    FD_ZERO(&amp;read_fds);    FD_ZERO(&amp;except_fds);    while(1){        memset(buf, '\\0', sizeof(buf));        //  每次调用select前都需要重新在read_fds和except_fds设置文件描述符connfd，因为事件发生后，文件描述符集合将会被内核修改        FD_SET(connfd, &amp;read_fds);        FD_SET(connfd, &amp;except_fds);        ret = select(connfd + 1, &amp;read_fds, NULL, &amp;except_fds, NULL);        if(ret &lt; 0){            printf(\"selection failure\\n\");            break;        }        if(FD_ISSET(connfd, &amp;read_fds)){    //  可读事件            ret = recv(connfd, buf, sizeof(buf) - 1, 0);            if(ret &lt;= 0){                break;            }            printf(\"get %d bytes of normal data: %s\\n\", ret, buf);        }else if(FD_ISSET(connfd, &amp;except_fds)){    //  异常事件            //  采用MSG_OOB标志的recv函数读取带外数据            ret = recv(connfd, buf, sizeof(buf) - 1, MSG_OOB);              if(ret &lt;= 0){                break;            }            printf(\"get %d bytes of oob data: %s\\n\", ret, buf);        }    }    close(connfd);    close(listenfd);    return 0;}总结      操作系统提供了select的系统调用，功能是在一段指定时间内，监听用户指定的文件描述符上的可读、可写和异常等事件  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程_提升服务器性能",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%8F%90%E5%8D%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Pool, Data Replication, Context Switch, Lock",
    "date": "2023-06-16 15:00:00 +0800",
    





    
    "snippet": "池/数据复制/上下文切换和锁  本节简单介绍了提升服务器性能的三个建议。首先，我们可以用池代替资源的动态分配，因为系统资源的分配是相当耗时的，池可以随用随放，提高效率。其次，我们应该减少程序内数据的复制。最后，我们探讨了上下文切换和加锁会占用CPU时间和系统资源，一个高性能的服务器设计应该尽量减少上下文切换和加锁。池随着科技的发展，硬件的性能大幅提升，在许多编程模式中，常常以空间换时间的方式...",
    "content": "池/数据复制/上下文切换和锁  本节简单介绍了提升服务器性能的三个建议。首先，我们可以用池代替资源的动态分配，因为系统资源的分配是相当耗时的，池可以随用随放，提高效率。其次，我们应该减少程序内数据的复制。最后，我们探讨了上下文切换和加锁会占用CPU时间和系统资源，一个高性能的服务器设计应该尽量减少上下文切换和加锁。池随着科技的发展，硬件的性能大幅提升，在许多编程模式中，常常以空间换时间的方式提升程序的效率，基于这种思想的启发，诞生了池的概念。池是一组资源的集合，这组资源在服务器启动之初就被创建好并初始化，这称为静态资源分配。当服务器正式运行时，如果线程需要相关的资源，就可以直接从池中获取，而无须动态分配。显然，从池中获取相关资源要比动态分配资源的速度快得多，因为分配系统资源的调用是相当耗时的。当服务器处理完客户请求后，可以把相关资源放回池中，而无须执行系统调用来释放资源。所以池是应用层面的系统资源管理设施，避免了服务器对内核的频繁访问。池的分配数量问题：由于池中的资源是预先静态分配的，我们无法预估应该分配多少资源。如果分配足够多的资源(比如每个可能的客户连接都分配必要的资源)，往往会造成资源的浪费，因为任一时刻的客户数量远远小于服务器能支持最大客户数量。一般采取的解决方案是预先分配一定的资源，如果发生资源不够用的问题，再动态分配一些资源加入池中。同理，当空闲资源过多时，也会从池中动态释放一些资源。常见的池：  内存池: 通常用于socket接收缓存和发送缓存。  进程池/线程池: 当我们需要一个工作进程/工作线程来处理新的客户请求时，我们可以直接从进程池/线程池中取得一个执行实体，而无序动态调用fork/pthread_create等函数创建进程/线程。  连接池: 通常用于服务器或服务器集群的内部永久连接。如果逻辑单元需要频繁访问数据库，采用访问数据库时发起连接、访问完毕后释放连接的方式太低效了。而如果采用连接池的方式，在服务器和数据库程序预先建立一组连接集合，当某个逻辑单元需要访问数据库时，取出池中一个连接实体使用之，待访问完毕后归还给连接池，这样的做法会更加便捷、高效。数据复制高性能服务器应该避免不必要的数据复制。  应用层和内核之间的数据复制如果内核可以直接处理socket或文件读入的数据，那么应用程序没必要将这些数据从内核缓冲区复制到应用程序缓冲区。(这里的直接处理指应用程序不关心数据的内容，不需要对数据做分析)  比如ftp服务器，当客户请求一个文件时，我们不关心文件的具体内容，在检测文件是否存在及读写权限后，我们无须把文件内容读入应用程序缓冲区中并调用send函数发送，而是可以通过零拷贝函数sendfile将文件直接从内容发送给客户端。  应用层内部的数据复制用户代码内部(不涉及内核)的数据复制也应该尽量避免。当了两个工作进程之间需要传递大量数据时，我们应该考虑使用共享内存在它们之间共享这些数据，而不是用管道或消息队列传递数据。比如解析HTTP请求时，我们用指针start_line指出每行在buffer中的起始位置，便于随后对行内容的访问，而不是将每一行的内容复制到另一个缓冲区上进行分析，这样既浪费空间，又效率低下。上下文切换和锁  上下文切换并发程序需要考虑上下文切换(context switch)的问题，即进程切换或线程切换导致的系统开销。过多的工作线程(或进程)在切换时会占用大量CPU时间，导致真正用于处理业务逻辑的CPU时间比重减少。所以，为每个客户都创建一个工作线程的服务器模型是不可取的。比如半同步/半异步模型是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。  锁并发程序需要考虑的另一个问题是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为它引入的代码不处理任何业务逻辑，还要访问内核资源。所以，服务器如果有更好的方案，应该尽量避免使用锁。如果服务器必须使用锁，可以考虑减小锁的颗粒度。比如使用读写锁。当所有工作进程只读取一块共享内存时，读写锁不会增加系统的额外开销。只有当某一个工作线程需要写入这块内存时，系统才必须锁住这块区域。总结      池是一组资源的集合，这组资源在服务器启动之初就被创建好并初始化，这称为静态资源分配    高性能服务器应该避免不必要的数据复制    并发程序需要考虑上下文切换和锁的问题，频繁的上下文切换和大量的锁会占用系统资源，降低效率  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程_逻辑单元之有限状态机",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E4%B9%8B%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Finite State Machine",
    "date": "2023-06-16 11:27:00 +0800",
    





    
    "snippet": "有限状态机  本节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。因为某些应用层协议的头部含有数据报类型字段，我们可以把每种类型映射为逻辑单元的一种执行状态，然后通过有限状态机模型实现状态之间的转移。接下来我们将通过解析HTTP请求头的例子来说明有限状态机在逻辑单元的应用。有限状态机有些应用层协议的头部包含数据报类型字段，我们可以将每种类型映射为逻辑单元的一种执行状态，服务器可以根据这些...",
    "content": "有限状态机  本节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。因为某些应用层协议的头部含有数据报类型字段，我们可以把每种类型映射为逻辑单元的一种执行状态，然后通过有限状态机模型实现状态之间的转移。接下来我们将通过解析HTTP请求头的例子来说明有限状态机在逻辑单元的应用。有限状态机有些应用层协议的头部包含数据报类型字段，我们可以将每种类型映射为逻辑单元的一种执行状态，服务器可以根据这些状态编写相应的处理逻辑。我们给出一个简单的有限状态机模型：STATE_MACHINE(){    State cur_State = type_A;    while(cur_State != type_C)    {        Package _pack = getNewPackage();    //  读取数据报        switch(cur_State)        {            case type_A:                process_package_state_A(_pack); //  执行type_A类型对应操作                cur_State = type_B;             //  将状态切换为type_B                break;            case type_B:                process_package_state_B(_pack); //  执行type_B类型对应操作                cur_State = type_C;             //  将状态切换为type_C                break;        }    }}上述状态机模型包含三种状态：type_A、type_B、type_C。其中type_A是初始状态，type_C是结束状态。状态机的当前状态由cur_State变量记录。在一趟循环过程中，状态机先通过getNewPackage函数获取一个新的数据报，然后通过cur_State变量判断如何处理该数据报。数据报处理完之后，状态机通过修改cur_State的值实现状态转移。当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。示例我们通过HTTP请求读取和分析的例子来展示有限状态机的用法。在TCP和IP协议中，头部有头部长度字段，我们可以根据该字段判断是否接收到一个完整的头部。但HTTP协议并没有头部字段，而是用一行空行(&lt;CR&gt;&lt;LF&gt;)来判断头部部分是否结束。所以一次读操作如果没有读取HTTP请求的整个头部，即没有遇到空行，我们需要等待客户继续写入数据并继续读入。为了提高解析效率，在寻找空行的过程中，我们需要同时完成对整个HTTP请求头部的分析。我们用主、从两个有限状态机表示这个过程。#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#define BUFFER_SIZE 4096    //  读缓冲区大小enum CHECK_STATE{    CHECK_STATE_REQUESTLINE = 0,    //  正在分析请求行    CHECK_STATE_HEADER              //  正在分析头部字段};enum LINE_STATUS{    LINE_OK = 0,    //  读取到一个完整的行    LINE_BAD,       //  行出错    LINE_OPEN       //  行数据不完整};enum HTTP_CODE{         NO_REQUEST,         //  请求不完整，需要继续读取客户数据    GET_REQUEST,        //  获得一个完整的客户请求    BAD_REQUEST,        //  客户请求有语法错误    FORBIDDEN_REQUEST,  //  客户对资源没有足够的访问权限    INTERNAL_ERROR,     //  服务器内部错误    CLOSE_CONNECTION    //  客户端已经关闭连接};//  返回客户端的应答结果(简化为回复成功/失败)static const char *szret[] = {\"I get a correct result\\n\", \"Something wrong\\n\"};//  解析一行的内容LINE_STATUS parse_line(char *buffer, int &amp;checked_index, int &amp;read_index){    char temp;    //  checked_index: 指向buffer缓冲区中正在分析的字节    //  read_index指向buffer中客户数据尾部的下一个字节    //  buffer中第0-checked_index字节已经分析完毕，第checked_index-(read_index-1)字节由下面循环挨个分析    for(; checked_index &lt; read_index ; ++checked_index){        //  获得当前要分析的字节        temp = buffer[checked_index];        if(temp == '\\r'){       //  如果当前字节是\\r(回车符)，说明可能读到一个完整的行            if(checked_index + 1 == read_index){                //  如果\\r是缓冲区buffer最后一个被读入的客户数据，无法判断是否读到一个完整的行                //  返回LINE_OPEN表示继续读取客户数据                return LINE_OPEN;            }else if(buffer[checked_index + 1] == '\\n'){                //  读到一个完整的行                buffer[checked_index++] = '\\0';                buffer[checked_index++] = '\\0';                return LINE_OK;            }            return LINE_BAD;    //  该HTTP请求语法有错误        }        else if(temp == '\\n'){  //  如果当前字节是\\n(换行符)，说明可能读到一个完整的行            //  该分支处理上次recv读取的最后一个字符是\\r的情况            //  当缓冲区读入新内容时，若为一个完整行，上一个字符一定是\\r            if((checked_index &gt; 1) &amp;&amp; buffer[checked_index - 1] == '\\r'){   //  读到一个完整的行                buffer[checked_index - 1] = '\\0';                buffer[checked_index++] = '\\0';                return LINE_OK;            }            return LINE_BAD;        }    }    //  如果所有内容分析完毕，没有遇到\\r字符，则说明还需要继续读取客户数据    return LINE_OPEN;}//  分析请求行HTTP_CODE parse_requestline(char *temp, CHECK_STATE &amp;checkstate){    char *url = strpbrk(temp, \" \\t\");    if(!url){        //  如果请求行中没有空白字符或\\t字符，则该HTTP请求语法有错误        return BAD_REQUEST;    }    *url++ = '\\0';    char *method = temp;    if(strcasecmp(method, \"GET\") == 0){ //  仅支持GET方法        printf(\"the request method is GET\\n\");    }else{        return BAD_REQUEST;    }    url += strspn(url, \" \\t\");    char *version = strpbrk(url, \" \\t\");    if(!version){        //  如果请求行中没有空白字符或\\t字符，则该HTTP请求语法有错误        return BAD_REQUEST;    }    *version++ = '\\0';    version += strspn(version, \" \\t\");    if(strcasecmp(version, \"HTTP/1.1\") != 0){   //  仅支持HTTP/1.1        return BAD_REQUEST;    }    //  检查URL的是否合法    if(strncasecmp(url, \"http://\", 7) == 0){        url += 7;        url = strchr(url, '/'); //  跳过域名部分，/后面是访问路径    }    if(!url || url[0] != '/'){        return BAD_REQUEST;    }    printf(\"The request URL is: %s\\n\", url);    checkstate = CHECK_STATE_HEADER;    return NO_REQUEST;}//  分析头部字段HTTP_CODE parse_headers(char *temp){    //  遇到一个空行，说明我们得到了一个正确的HTTP请求    if(temp[0] == '\\0'){        return GET_REQUEST;    }    else if(strncasecmp(temp, \"Host:\", 5) == 0){ //  处理Host头部字段        temp += 5;        temp += strspn(temp, \" \\t\");        printf(\"The request host is: %s\\n\", temp);    }else{  //  其他头部字段不处理        printf(\"I can not handle this header\\n\");    }    return NO_REQUEST;}//  分析HTTP请求入口函数HTTP_CODE parse_content(char *buffer, int &amp;checked_index, CHECK_STATE &amp;checkstate, int &amp;read_index, int &amp;start_line){    LINE_STATUS linestatus = LINE_OK;   //  linestatus字段记录当前行的读取状态    HTTP_CODE retcode = NO_REQUEST;     //  retcode字段记录HTTP请求的处理结果    //  主状态机，用于从buffer中取出所有完整的行    while((linestatus = parse_line(buffer, checked_index, read_index)) == LINE_OK){        char *temp = buffer + start_line;        start_line = checked_index;        //  checkstate字段保存主状态机的当前状态        switch(checkstate){            case CHECK_STATE_REQUESTLINE:   //  分析请求行            {                retcode = parse_requestline(temp, checkstate);                if(retcode == BAD_REQUEST){                    return BAD_REQUEST;                }                break;            }            case CHECK_STATE_HEADER:        //  分析头部字段            {                retcode = parse_headers(temp);                if(retcode == BAD_REQUEST){                    return BAD_REQUEST;                }else if(retcode == GET_REQUEST){                    return GET_REQUEST;                }                break;            }            default:            {                return INTERNAL_ERROR;            }        }    }    //  若没用读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析    if(linestatus == LINE_OPEN){        return NO_REQUEST;    }else{        return BAD_REQUEST;    }}//  主函数int main(int argc, char *argv[]){    if(argc &lt;= 2){        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));        return 1;    }    const char *ip = argv[1];    int port = atoi(argv[2]);    struct sockaddr_in address;    bzero(&amp;address, sizeof(address));    address.sin_family = AF_INET;    inet_pton(AF_INET, ip, &amp;address.sin_addr);    address.sin_port = htons(port);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    assert(listenfd &gt;= 0);    int ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    assert(ret != -1);    ret = listen(listenfd, 5);    assert(ret != -1);    struct sockaddr_in client_address;    socklen_t client_addrlength = sizeof(client_address);    int fd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);    if(fd &lt; 0){        printf(\"errno is: %d\\n\", errno);    }else{        char buffer[BUFFER_SIZE];   //  读缓冲区大小        memset(buffer, '\\0', BUFFER_SIZE);        int data_read = 0;        int read_index = 0;         //  当前已经读取了多少字节的客户数据        int checked_index = 0;      //  当前已经分析了多少字节的客户数据        int start_line = 0;         //  行在buffer中的起始位置        //  设置主状态机初始状态        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;        while(1){   //  循环读取并分析客户数据            data_read = recv(fd, buffer + read_index, BUFFER_SIZE - read_index, 0);            if(data_read == -1){                printf(\"reading failed\\n\");                break;            }else if(data_read == 0){                printf(\"remote client has closed the connection\");                break;            }            read_index += data_read;            //  分析目前已经得到的所有客户数据            HTTP_CODE result = parse_content(buffer, checked_index, checkstate, read_index, start_line);            if(result == NO_REQUEST){   //  未得到一个完整的HTTP请求                continue;            }else if(result == GET_REQUEST){    //  得到一个完整、正确的HTTP请求                send(fd, szret[0], strlen(szret[0]), 0);                break;            }else{  //  其他情况表示发生错误                send(fd, szret[1], strlen(szret[1]), 0);                break;            }        }        close(fd);    }    close(listenfd);    return 0;}发送给服务端的内容:GET http://jj.com/jj/index.html HTTP/1.1\\r\\nabc:123\\r\\ncdna:456\\r\\nHost:127.0.0.1\\r\\n\\r\\n服务端终端打印内容：$ ./fsm 127.0.0.1 18888the request method is GETThe request URL is: /jj/index.htmlI can not handle this headerI can not handle this headerThe request host is: 127.0.0.1该程序涉及两个状态机：主状态机和从状态机。它们的关系是主状态机内部调用从状态机。从状态机的状态转移过程如下图所示：从状态机的初始状态是LINK_OK。在main函数中，我们循环调用recv函数读取客户数据。每次读取到数据，就调用parse_line函数获取一个行。假设服务器经过一次recv调用后，buffer的内容及部分变量值如图a所示：parse_line函数挨个检查checked_index到read_index-1之间的字节，判断是否存在行结束符，并更新checked_index的值，如图b所示。当前buffer不存在行结束符，所以parse_index返回LINE_OPEN。接下来循环调用recv读取更多的客户数据，下一次读入的客户数据后，buffer的内容及部分变量值如图c所示。接下来继续调用parse_line函数处理新到来的数据。这次parse_line函数读到了行结束符，即读到了一个完整的行，如图d所示。此时parse_line函数将这行内容传递给parse_content函数的主状态机处理。在主状态机中使用checkstate变量来记录当前的状态。  如果当前状态是CHECK_STATE_REQUESTLINE，表示parse_line函数解析出的是请求行。于是主状态机调用parse_requestline函数分析请求行。分析完毕后，主状态机进入下一个状态CHECK_STATE_HEADER。  如果当前状态是CHECK_STATE_HEADER，表示parse_line函数解析出的是头部字段。于是主状态机调用parse_header函数分析头部字段。总结      某些应用层协议的头部包含数据报类型字段，可以将每种类型映射为逻辑单元的一种执行状态，从而通过有限状态机模型实现逻辑处理  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程_并发模式",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, 并发模式, 半同步/半异步模式, 领导者/追随者模式",
    "date": "2023-06-15 17:01:00 +0800",
    





    
    "snippet": "半同步/半异步模式/半同步/半反应堆模式/领导者/追随者模式  本节介绍了网络编程设计中的两种并发模式：半同步/半异步模式和领导者/追随者模式。半同步/半异步模式是指同步线程用于处理客户逻辑，异步线程用于处理IO事件。它有一种变体：半同步/半反应堆模式。半同步/半反应堆模式中异步线程只有主线程，工作线程负责处理IO读写和业务逻辑，是同步线程。接着我们介绍了领导者/追随者模式，它是指多个工作线...",
    "content": "半同步/半异步模式/半同步/半反应堆模式/领导者/追随者模式  本节介绍了网络编程设计中的两种并发模式：半同步/半异步模式和领导者/追随者模式。半同步/半异步模式是指同步线程用于处理客户逻辑，异步线程用于处理IO事件。它有一种变体：半同步/半反应堆模式。半同步/半反应堆模式中异步线程只有主线程，工作线程负责处理IO读写和业务逻辑，是同步线程。接着我们介绍了领导者/追随者模式，它是指多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。最后我们分别总结了半同步/半异步模式和领导者/追随者模式的缺点。两种高效的并发模式对于计算密集型程序，并发编程并没有优势，反而因为切换任务导致效率下降。但对服务器这种IO密集型程序，并发编程可以使IO被阻塞时，将CPU分配给其他线程或进程，从而提高CPU利用率和程序速度。接下来我们探讨网络编程的并发模式。并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的方式。服务器上主要的并发模式有两种：半同步/半异步模式(half-sync/half-async)，领导者/追随者模式(Leader/Followers)同步线程/异步线程在IO模型中，同步和异步是指内核向应用程序通知的是何种IO事件(就绪事件还是完成事件)，以及谁来完成IO读写(内核还是应用程序)。而在并发模式中，同步是指程序按代码顺序执行；异步是指程序的执行需要由系统事件(比如中断、信号等)来驱动。同步读操作如下图a所示，程序按照代码顺序执行，当执行read函数时被阻塞，直到读取完数据再继续往下执行。异步读操作如下图b所示，程序执行read操作时，会放弃cpu，处理其他任务，直到数据读取完毕。系统会向应用程序发送一个信号，程序接收到信号后再继续往下执行。它不是严格按照代码顺序的，而是被阻塞时交替使用cpu。我们将同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。优缺点：  异步线程执行率高，实时性强，但程序复杂，难以调试和扩展，不适合大量并发的情况。  同步线程效率低，实时性差，但逻辑简单。对于服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们应该同时使用同步线程和异步线程来实现，即半同步/半异步模式。半同步/半异步模式在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，将其封装成请求对象，并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取和处理该请求对象。下图总结了半同步/半异步模式的工作流程：半同步/半反应堆模式半同步/半反应堆(half-sync/half-reactive)模式是半同步/半异步模式中的一种变体。  在半同步/半反应堆模式中，异步线程只有一个，即主线程，负责监听所有socket上的事件  如果监听到socket上有可读事件发生，主线程接受该连接，然后往epoll内核事件表中注册该socket上的读写事件  如果连接的socket上有读写事件发生，主线程将该socket插入请求队列中  所有的工作线程都睡眠在请求队列上，当有任务到来时，它们通过竞争(比如申请互斥锁)获取任务的接管权半同步/半反应堆模式的工作流程如下图所示：主线程插入请求队列的是就绪的连接socket，所以半同步/半反应堆模式采用了Reactor模式。该模式要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这也是该模式名称中half-reactive的含义。  半同步/半反应堆模式也可以使用模拟Proactor事件处理模式，即主线程完成数据的读写，然后将数据、任务类型等信息封装为一个任务对象，将其插入请求队列中。工作线程从请求队列中取得任务对象后，即可直接处理，无序执行读写操作。半同步/半反应堆模式的缺点：  主线程和工作线程共享请求队列，都需要对请求队列加锁互斥访问，耗费CPU时间  每个工作线程同一时间只能处理一个客户请求，如果客户数量较多，请求队列会堆积许多任务对象，客户端响应速度会越来越慢。如果增加工作线程，大量的工作线程切换会耗费大量CPU时间针对上诉缺点，我们对半同步/半反应堆模式进行改进，使它的工作线程能同时处理多个客户连接，如下图所示：这种模式更加高效。主线程只负责监听socket，连接socket由工作线程来完成。当有新的连接到来时，主线程将该连接socket派发给某个工作线程，此后新socket上的任何IO操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把新socket上的读写事件注册到自己的epoll内核事件表中。由于每个线程(主线程和工作线程)都维护自己的事件循环，它们独立监听不同的事件，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。领导者/追随者模式领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序仅有一个领导者线程，它负责监听IO事件；其他线程则是追随者，在线程池中处于休眠状态，等待成为新的领导者。如果当前领导者线程检测到IO事件，首先从线程池中推选出新的领导者线程，然后处理IO事件。此时新的领导者等待新的IO事件，原来的领导者处理IO事件，二者事件了并发。领导者/追随者模式包含以下几个组件：  句柄集(HandleSet)  线程集(ThreadSet)  事件处理器(EventHandler)  具体的事件处理器(ConcreteEventHandler)这些组件的关系如下图所示：  句柄集句柄表示IO资源，在Linux中通常是一个文件描述符。句柄集管理众多句柄，它用wait_for_event方法来监听这些句柄上的IO事件，并将其中就绪的事件通知给领导者进程。领导者则调用绑定句柄上的事件处理器来处理事件。领导者将句柄和事件处理器的绑定是通过句柄集中的register_handle方法实现的  线程集线程集是所有工作线程的管理者，负责线程之间的同步，以及新领导者的推选。线程集中的线程在任一时间都处于下面三种状态之一：  Leader: 线程当前处于领导者状态，负责等待句柄集上的IO事件  Processing: 线程正在处理事件。领导者检测到IO事件后，可以转义到Processing状态来处理事件，并调用promote_new_leader方法推选新的领导者。领导者也可以指定其他追随者来处理事件(Event Handoff)，此时领导者地位不变。当处于Processing状态的线程处理完事件后，如果当前线程中没有领导者，那它将成为新的领导者，否则它将转变为追随者。  Follower: 当前线程处于追随者身份。可以通过调用线程集的join方法等待成为新的领导者，也可以被当前的领导者指定来处理新的任务。这三种状态之间的转换关系如下图所示：  由于领导者线程推选新的领导者和追随者等待成为新领导者者两个操作都需要修改线程集，所以线程集提供一个Synchronizer成员来同步这两个操作。  事件处理器和具体的事件处理器事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。事务处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器的回调函数。具体的事件处理器是事件处理器的派生类，它们必须重新实现基类的handle_event方法，以处理特定的任务。领导者/追随者模式的优缺点：  由于领导者线程自己监听IO事件并处理客户请求，所以不需要在线程之间传递数据，也不需要像半同步/半反应堆模式那样同步请求队列的访问  但领导者/追随者模式仅支持一个事件源集合，所以无法让各个工作线程独立地管理多个客户连接总结      服务器上主要的并发模式有两种：半同步/半异步模式，领导者/追随者模式    在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件    半同步/半反应堆模式是半同步/半异步模式中的一种变体    领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式    领导者/追随者模式包含以下几个组件：句柄集、线程集、事件处理器、具体的事件处理器  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程_事件处理模式",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Reactor, Proactor",
    "date": "2023-06-15 15:49:00 +0800",
    





    
    "snippet": "Reactor/Proactor  本节介绍了网络编程中两种高效的事件处理模式：Reactor模式和Proactor模式。同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。但同步IO模型也能模拟出Proactor模式。Reactor模式指主线程只负责监听文件描述符是否有事件发生，其他实质性的工作，比如读写数据、业务处理都交给工作线程负责。而Proactor模式...",
    "content": "Reactor/Proactor  本节介绍了网络编程中两种高效的事件处理模式：Reactor模式和Proactor模式。同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。但同步IO模型也能模拟出Proactor模式。Reactor模式指主线程只负责监听文件描述符是否有事件发生，其他实质性的工作，比如读写数据、业务处理都交给工作线程负责。而Proactor模式中主线程除了负责监听socket事件的发生，还负责所有的数据读写。而工作线程只负责业务逻辑。两种高效的事件处理模式网络设计模式中有两种高效的事件处理模式：Reactor模式和Proactor模式。 同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。当然，同步IO模型也能模拟Proactor模式。接下来我们围绕这两种事件处理模式进行探讨。Reactor模式Reactor模式指主线程(IO处理单元)只负责监听文件描述符是否有事件发生，如果事件发生则通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作(比如读写数据，接收新的连接，处理客户请求)，这些实质性工作均在工作线程中完成。同步IO模型使用Reactor模式的工作流程如下图所示(以epoll_wait为例)：  主线程向epoll内核事件表中注册socket上的读就绪事件  主线程调用epoll_wai等待socket上有数据可读  当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列  睡眠在请求队列上的某个工作线程被唤醒，从socket中读取数据，并处理客户请求  工作线程向epoll内核事件表中注册该socket上的写就绪事件  主线程调用epoll_wai等待socket可写  当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列  睡眠在请求队列上的某个工作线程被唤醒，它往socket中写入服务器处理客户请求的结果  工作线程从请求队列中取出事件后，会根据事件的类型处理它，对于可读事件，执行读数据和处理请求的操作；对于可写事件，执行写数据的操作。这里不会区分读工作线程和写工作线程。Proactor模式Proactor模式模式是将所有的IO操作都交给主线程和内存来处理，工作线程只负责业务逻辑。异步IO模型使用Proactor模式的工作流程如下图所示(以aio_read和aio_write为例)：  主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序  主线程继续处理其他逻辑  当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用  应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求  工作线程处理完客户请求后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序  主程序继续处理其他逻辑  当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据以及发送完毕  应用程序预先定义好的信号处理函数选择一个工作线程来进行善后处理，比如决定是否关闭socket  图中连接socket的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接在socket上的读写事件。主线程中的epoll_wait调用仅仅用来监听socket上的连接请求事件，而不用来检测连接socket上的读写事件。同步IO模型模拟Proactor模式同步IO模型模拟Proactor模式的原理是：主线程执行数据的读写操作，在读写完成后，主线程向工作线程通知这一完成事件。工作线程直接获得了数据读写的结果，只需要对读写结果进行逻辑处理。同步IO模型模拟Proactor模式的工作流程如下图所示(以epoll_wait为例)：  主线程向epoll内核事件表中注册socket上的读就绪事件  主线程调用epoll_wai等待socket上有数据可读  当socket上有数据可读时，epoll_wait通知主线程。主线程从socket中循环读取数据，然后把读取到的数据封装成一个请求对象插入请求队列中  睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求  工作线程向epoll内核事件表中注册该socket上的写就绪事件  主线程调用epoll_wai等待socket可写  当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果总结      网络设计模式中有两种高效的事件处理模式：Reactor模式和Proactor模式    同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。同步IO模型也能模拟Proactor模式    Reactor模式指主线程(IO处理单元)只负责监听文件描述符是否有事件发生，如果事件发生则通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作(比如读写数据，接收新的连接，处理客户请求)，这些实质性工作均在工作线程中完成    Proactor模式模式是将所有的IO操作都交给主线程和内存来处理，工作线程只负责业务逻辑    同步IO模型模拟Proactor模式的原理是：主线程执行数据的读写操作，在读写完成后，主线程向工作线程通知这一完成事件。工作线程直接获得了数据读写的结果，只需要对读写结果进行逻辑处理  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程_服务器IO模型简介",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8IO%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, IO模型",
    "date": "2023-06-15 14:38:00 +0800",
    





    
    "snippet": "服务器编程框架/IO模型  本节先介绍了一下服务器的编程框架，主要分为三个部分：IO处理单元、逻辑单元、网络存储单元。逻辑单元因服务器具体业务而异，网络存储单元不是必要的。而IO处理单元是网络编程中的重要部分。对应的IO模型一般有四种：阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号、异步IO。接下来我们将围绕这四种模型简单介绍。服务器编程框架介绍IO模型之前，我们先简单了...",
    "content": "服务器编程框架/IO模型  本节先介绍了一下服务器的编程框架，主要分为三个部分：IO处理单元、逻辑单元、网络存储单元。逻辑单元因服务器具体业务而异，网络存储单元不是必要的。而IO处理单元是网络编程中的重要部分。对应的IO模型一般有四种：阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号、异步IO。接下来我们将围绕这四种模型简单介绍。服务器编程框架介绍IO模型之前，我们先简单了解一下服务器的框架，IO是服务器框架中的一部分。服务器编程框架一般分为三个部分：IO处理单元、逻辑单元、网络存储单元。如下图所示：  IO处理单元IO处理单元是服务器管理客户连接的模块。它的功能是：  等待并接收新的客户连接  接收客户数据  将服务器响应数据返回给客户端对于一个服务器集群来说，IO处理单元是一个专门的接入服务器，它实现负载均衡，从所有逻辑服务器中选择负荷最小的一台来为新客户服务。  这里注意，数据的收发不一定在IO处理单元中执行，也可能在逻辑单元中执行，取决于事件处理模式。  逻辑单元逻辑单元一般是一个线程或进程。它的功能是：  分析并处理客户数据  将结果传递给IO处理单元或直接发给客户端(取决于事件处理模式)对于一个服务器集群来说，集群有多台逻辑服务器，每台服务器有多个逻辑单元，可以实现对多个用户任务的并行处理。  网络存储单元网络存储单元是数据库、缓存和文件，也可以是一台单独的服务器。它的功能是获取或存储客户交互过程中的各种数据。  它不是必须的，比如ssh、telnet等登录服务不需要网络存储单元。  请求队列图中的请求队列其实就是各个单元之间的通信。IO处理单元接受客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样地，多个逻辑单元同时访问一个存储单元时，需要某种机制来协调处理竞争条件。在服务器集群中，各个单元是单独的服务器，它们通过TCP连接进行通信，而且这种TCP连接是永久的、预先建立的、静态的。这种TCP连接能提高服务器之间交换数据的效率，避免动态建立TCP连接导致的额外的系统开销。最后我们通过一个表来总结服务器的基本模块。            模块      单个服务器      服务器集群                  IO处理单元      处理客户连接，读写网络程序      作为接入服务器，实现负载均衡              逻辑单元      业务进程或线程      逻辑服务器              网络存储单元      本地数据库、文件、缓存      数据库服务器              请求队列      各单元之间的通信方式      各服务器之间永久的TCP连接      IO模型IO模型分为四种，其中非阻塞IO需要搭配其他IO通知机制一起使用：  阻塞IOsocket在创建时默认是阻塞的，当阻塞IO执行的系统调用因无法立即完成时，会被操作系统挂起，直到等待事件发生为止。  比如客户端通过connect向服务器发起连接，connect会先发送同步报文，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，connect调用就会被挂起。直到客户端接收到确认报文段，然后唤醒connect调用。在socket的基础API中，可能被阻塞的系统调用包括accpet、send、recv和connect。  非阻塞IO许多系统调用可以通过一些参数设置为非阻塞。  比如我们可以给socket系统调用的第二个参数传递SOCK_NONBLOCK标志，或通过fcntl系统调用的F_SETFL命令，设置为非阻塞。非阻塞IO执行的系统调用总是立即返回的。如果事件没有发生，这些系统调用会返回-1。为了区分这些系统调用是出错了，还是事件没有发生，errno会记录这些系统调用返回-1的原因。  比如accept、send和recv调用，如果事件未发生，errno通常被设置为EAGAIN(再来一次)或EWOULDBLOCK(期望阻塞)。connec调用，如果事件未发生，errno则被设置为EINPROGRESS(在处理中)。显然，我们需要在事件已经发生的情况下操作非阻塞IO，才能提供程序效率。所以非阻塞IO需要和其他IO通知机制一起使用，比如IO复用和SIGIO信号。  非阻塞IO + IO复用IO复用是最常用的IO通知机制。它是指应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数将其中就绪的事件通知给应用程序。  比如Linux上常用的IO复用函数是select、poll和epoll_wait。IO复用函数本身是阻塞的，它们能够提高程序效率的原因是：它们能够同时监听多个IO事件。  非阻塞IO + SIGIO信号SIGIO信号也是用来报告IO事件的。它的原理是如果为目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数就会触发，我们就可以在该信号处理函数中对目标文件描述符执行非阻塞IO操作。  异步IO上述介绍的阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号都是同步IO模型。它们都是在IO事件发生后，由应用程序来完成接下来的读写操作。 POSIX规范的异步IO模型不同，用户事先告诉内核读写缓冲区的位置，以及IO操作完成后内核通知应用程序的方式。然后用户可以直接对IO执行读写操作。异步IO的读写操作总是立即返回的，无论IO是否阻塞，因为真正的读写操作由内核接管。Linux提供了异步IO的支持，对应的函数存储在aio.h的头文件中。  同步IO模型向应用程序通知的是IO就绪事件，而异步IO模型向应用程序通知的是IO完成事件。最后我们通过一个表来总结这些IO模型。            IO模型      读写操作及阻塞阶段                  阻塞IO      程序阻塞于读写函数              非阻塞IO + IO复用      程序阻塞于IO复用函数，但可同时监听多个IO事件，对IO本身的读写操作是非阻塞的              非阻塞IO + SIGIO信号      信号触发读写就绪事件，用户程序执行读写操作，用户程序没有阻塞阶段              异步IO      内核执行读写操作并触发读写完成事件，用户程序没有阻塞阶段      总结      服务器编程框架一般分为三个部分：IO处理单元、逻辑单元、网络存储单元    IO处理单元是服务器管理客户连接的模块    逻辑单元一般是一个线程、进程或一台服务器    网络存储单元是数据库、缓存和文件，也可以是一台单独的服务器    在服务器集群中，各个单元是单独的服务器，它们通过永久的、预先建立的、静态的TCP连接进行通信    IO模型分为四种：阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号、异步IO    Linux提供了异步IO的支持，对应的函数存储在aio.h的头文件中    同步IO模型向应用程序通知的是IO就绪事件，而异步IO模型向应用程序通知的是IO完成事件  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 改变程序工作目录及后台运行",
    "url": "/posts/%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, getcwd, chdir, chroot, daemon",
    "date": "2023-06-14 16:13:00 +0800",
    





    
    "snippet": "getcwd/chdir/chroot/daemon  本节介绍了如何获取进程当前工作目录，如何改变进程当前工作目录及根目录。不过需要注意，只有特权进程才能改变根目录。最后我们介绍了daemon函数实现使程序以守护进程的方式后台运行，并简单还原了它的源码。getcwd有些服务器程序需要改变工作目录和根目录，比如对于Web服务器来说，逻辑根目录不是“/”，而是站点的根目录(一般为/var/ww...",
    "content": "getcwd/chdir/chroot/daemon  本节介绍了如何获取进程当前工作目录，如何改变进程当前工作目录及根目录。不过需要注意，只有特权进程才能改变根目录。最后我们介绍了daemon函数实现使程序以守护进程的方式后台运行，并简单还原了它的源码。getcwd有些服务器程序需要改变工作目录和根目录，比如对于Web服务器来说，逻辑根目录不是“/”，而是站点的根目录(一般为/var/www)。Linux系统中提供了获取和修改当前进程的工作目录、根目录的的函数。下面是getcwd的系统调用，功能是获取进程当前工作目录，其函数原型如下：#include &lt;unistd.h&gt;char* getcwd(char *buf, size_t size);参数和返回值：  buf: 存储进程当前工作目录的绝对路径名的缓冲区  size: 缓冲区大小  返回值: 成功时返回指向缓冲区的指针，失败则返回NULL，并设置errnogetcwd存在以下几种情况：  如果缓冲区大小size小于绝对路径的长度，则getcwd会返回NULL，并设置errno为ERANGE  如果缓冲区buf为NULL，但size非0，则getcwd内部会调用malloc来动态分配内存，并将进程的当前工作目录存储其中。这种情况需要我们自己释放getcwd内存创建的动态内存chdir下面是chdir的系统调用，功能是改变进程当前工作目录，其函数原型如下：#include &lt;unistd.h&gt;int chdir(const char *path);参数和返回值：  path: 指定要切换到的目标目录  返回值: chdir函数成功时返回0，失败则返回-1，并设置errnochroot下面是chroot的系统调用，功能是改变进程的根目录，其函数原型如下：#include &lt;unistd.h&gt;int chroot(const char *path);参数和返回值：  path: 指定要切换到的目标根目录  返回值: chdir函数成功时返回0，失败则返回-1，并设置errnochroot函数并不改变进程的工作目录，所以仍然需要使用chdir(“/”)来将工作目录切换到新的根目录。改变进程的根目录后，程序可能无法访问类似/dev的文件或目录，因为这些文件和目录并不处于新的根目录下。不过调用chroot函数后，进程原先打开的文件描述符依然有效。最后需要注意，只有特权进程才能改变根目录。服务器程序后台化最后我们令进程以守护进程的方式运行，我们给出一个具体实现：bool daemonize(){  //  创建子进程，关闭父进程，这样可以使程序在后台运行  pid_t pid = fork();  if(pid &lt; 0){    return false;  }else if(pid &gt; 0){  //  父进程    exit(0);    }                //  子进程  //  设置文件权限掩码，当进程创建新文件时，文件权限是mode &amp;0777  umask(0);  pid_t sid = setsid(); //  创建新会话  if(sid &lt; 0){    return false;  }  if(chdir(\"/\") &lt; 0){  //  切换工作目录    return false;  }  close(STDIN_FILENO);  //  关闭标准输入设备  close(STDOUT_FILENO);  //  关闭标准输出设备  close(STDERR_FILENO);  //  关闭标准错误输出设备    /*    关闭其他打开的文件描述符，代码省略    */  open(\"/dev/null\", O_RDONLY);  //  将标准输入定向到/dev/null  open(\"/dev/null\", O_RDWR);  //  将标准输出定向到/dev/null  open(\"/dev/null\", O_RDWR);  //  将标准错误输出定向到/dev/null  return true;}上面的代码实现了使程序以后台进程的方式运行，Linux中提供了同样功能的函数。下面是daemon的系统调用，功能是使程序以后台进程的方式运行，其函数原型如下：#include &lt;unistd.h&gt;int daemon(int nochdir, int noclose);参数和返回值：  nochdir: 是否改变工作目录，传参0表示将工作目录设置为根目录(“/”)，否则继续使用当前工作目录  noclose: 传参0表示将标准输入、标准输出、标准错误输出重定向到/dev/null文件，否则继续使用当前设备  返回值: 成功返回0，失败则返回-1，并设置errno总结      操作系统提供了getcwd的系统调用，功能是获取进程当前工作目录    操作系统提供了chdir的系统调用，功能是改变进程当前工作目录    操作系统提供了chroot的系统调用，功能是改变进程的根目录    只有特权进程才能改变根目录    操作系统提供了daemon的系统调用，功能是使程序以后台进程的方式运行  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 系统资源限制",
    "url": "/posts/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, rlimit",
    "date": "2023-06-14 14:38:00 +0800",
    





    
    "snippet": "getrlimit/setrlimit  本节介绍了getrlimit和setrlimit函数，它们可以在程序内修改系统资源的软限制和硬限制。软限制是建议性的、最好不要超过该值的限制，硬限制是软限制的上限，是绝对不能超过的。此外，通过ulimit命令和配置文件也可以修改系统资源的限制。getrlimit/setrlimitLinux上运行的程序会受到资源限制的影响，比如物理设备限制(CPU数...",
    "content": "getrlimit/setrlimit  本节介绍了getrlimit和setrlimit函数，它们可以在程序内修改系统资源的软限制和硬限制。软限制是建议性的、最好不要超过该值的限制，硬限制是软限制的上限，是绝对不能超过的。此外，通过ulimit命令和配置文件也可以修改系统资源的限制。getrlimit/setrlimitLinux上运行的程序会受到资源限制的影响，比如物理设备限制(CPU数量，内存数量等)、系统策略限制(CPU时间等)、具体实现的限制(文件名最大长度等)。Linux提供了一对函数来读取和设置这些系统资源的限制。 下面是getrlimit/setrlimit的系统调用，功能是设置或读取资源限制，其函数原型如下：#include &lt;sys/resource.h&gt;int getrlimit(int resource, struct rlimit *rlim);int setrlimit(int resource, const struct rlimit *rlim);参数和返回值：  resource: 指定资源限制类型，具体参数值及含义见下表  rlim: rlimit结构体指针，具体定义如下，描述资源的限制级别  返回值: 成功时返回0，失败则返回-1，并设置errnorlimit结构体定义：struct rlimit{  //  rlim_t是一个整数类型  rlim_t rlim_cur;    //  指定资源的软限制  rlim_t rlim_max;    //  指定资源的硬限制};  软限制指一个建议性，最好不要超过该值的限制，如果超过的话，系统可能会向进程发送信号终止其运行。例如当进程CPU时间超过其软限制时，系统将向进程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发送SIGXFSZ信号。  硬限制一般是软限制是上限。  普通程序只能减小硬限制，只有root身份运行的程序才能增加硬限制。此外，我们可以用ulimit命令修改当前shell环境下的资源限制(软限制/硬限制)。这种修改会对该shell启动的所有后续程序生效。我们也可以通过修改配置文件来改变系统资源的软限制和硬限制，这种方式修改结果是永久的。resource常用的参数值及含义            资源限制类型      含义                  RLIMIT_AS      进程虚拟内存总量限制(单位是字节)。超过该限制将使某些函数(比如mmap)产生ENOMEM错误              RLIMIT_CORE      进程核心转储文件(core dump)大小限制(单位是字节)。其值为0表示不产生核心转储文件              RLIMIT_CPU      进程CPU时间限制(单位是秒)              RLIMIT_DATA      进程数据段限制(初始化数据data段、未初始化数据bss段和堆，单位是字节)              RLIMIT_FSIZE      文件大小限制(单位是字节)。超过该限制将使某些函数(比如write)产生EFBIG错误              RLIMIT_NOFILE      文件描述符数量限制，超过该限制将使某些函数(比如pipe)产生EMFILE错误              RLIMIT_NPROC      用户能创建的进程数限制，超过该限制将使某些函数(比如fork)产生EAGAIN错误              RLIMIT_SIGPENDING      用户能够挂起的信号数量限制              RLIMIT_STACK      进程栈内存限制(单位是字节)，超过该限制将引起SIGSEGV信号      总结      操作系统提供了getrlimit和setrlimit的系统调用，功能是设置或读取资源限制    软限制指一个建议性，最好不要超过该值的限制，如果超过的话，系统可能会向进程发送信号终止其运行    硬限制一般是软限制是上限    可以通过ulimit命令和修改配置文件来改变系统资源的软限制和硬限制  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 用户、进程信息",
    "url": "/posts/%E7%94%A8%E6%88%B7-%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, UID, EUID, SID",
    "date": "2023-06-13 10:01:00 +0800",
    





    
    "snippet": "UID/EUID/GID/EGID/SID  本节介绍了用户、进程相关的只是。进程的用户ID分为真实用户ID和有效用户ID，有效用户ID指运行程序的用户能够拥有该程序有效用户的权限。类似的，进程的组用户ID也分为真实组ID和有效组ID，运行目标程序的组用户提供有效组的权限。Linux中，每一个进程都隶属于一个进程组。Linux系统了getpgid和setpgid函数来获取和设置目标进程的进程...",
    "content": "UID/EUID/GID/EGID/SID  本节介绍了用户、进程相关的只是。进程的用户ID分为真实用户ID和有效用户ID，有效用户ID指运行程序的用户能够拥有该程序有效用户的权限。类似的，进程的组用户ID也分为真实组ID和有效组ID，运行目标程序的组用户提供有效组的权限。Linux中，每一个进程都隶属于一个进程组。Linux系统了getpgid和setpgid函数来获取和设置目标进程的进程组。最后我们提到了会话的概念，相关联的几个进程组可以形成一个会话，可以通过setsid函数创建会话，通过getsid函数获取目标进程的会话ID。通过ps命令，我们可以在终端查看进程、进程组和会话之间的关系。UID/EUID/GID/EGID用户信息对于服务器程序的安全至关重要。大部分服务器必须以root身份启动，但是不能以root身份运行。 下面是用户信息相关的的系统调用，功能是获取或设置当前进程的真实用户ID(UID)、有效用户ID(EUID)、真实组ID(GID)、有效组ID(EGID)，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t getuid();           //  获取真实用户ID  uid_t geteuid();          //  获取有效用户IDgid_t getgid();           //  获取真实组IDgid_t getegid();          //  获取有效组IDint setuid(uid_t uid);    //  设置真实用户IDint seteuid(uid_t uid);   //  设置有效用户IDint setgid(gid_t gid);    //  设置真实组IDint setegid(gid_t gid);   //  设置有效组ID参数和返回值：  uid: 需要设置的用户ID  gid: 需要设置的组ID  返回值: 设置ID函数执行成功时返回0，失败则返回-1真实用户ID和有效用户ID的区别：刚刚我们说到大部分服务器必须以root身份启动，但是不能以root身份运行。如果服务器不以root身份运行，可能访问某些资源会受限，为了解决这个问题，Linux提供了有效用户ID，使运行程序的用户能够拥有该程序有效用户的权限。比如su程序，任何用户都可以通过su程序来修改自己的账户信息(比如密码)，这时候su程序需要访问/etc/passwd文件，但访问该文件需要root权限，而普通用户启动的su程序并没有root权限。为了探讨答案，我们用ls命令查看su程序权限。zhangzf@ubuntu:/bin$ ls -l | grep su-rwxr-xr-x 1 root root  245368 Aug 14  2019 btrfs-select-super-rwxr-xr-x 1 root root  253816 Aug 14  2019 btrfs-show-super-rwsr-xr-x 1 root root   40128 Mar 27  2019 su-rwxr-xr-x 1 root root   43080 Dec 10  2021 systemd-sysusers我们可以发现su对应的权限是-rws，而其他程序是-rwx。这里的s表示set_user_id标志，表示任何普通用户运行su程序时，其有效用户是root。那么根据有效用户的定义，任何运行su程序的普通用户都能够访问/etc/passwd文件。  有效用户为root的进程被称为特权进程(privileged processes)。  EGID的含义和EUID类似：给运行目标程序的组用户提供有效组的权限。最后我们通过一个例子来测试进程的UID和EUID。#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(){  uid_t uid = getuid();  uid_t euid = geteuid();  printf(\"userid is %d, effective userid is %d\\n\", uid, euid);  return 0;}执行结果：$ ./test_uiduserid is 1006, effective userid is 1006  //  此时UID和EUID都是普通用户$ sudo chown root:root test_uid           //  设置用户所有者为root$ sudo chmod +s test_uid                  //  设置set_user_id标志$ ./test_uid                              //  重新运行程序userid is 1006, effective userid is 0     //  此时EUID变成了0(root)切换用户上面我们提到大部分服务器必须以root身份启动，但是不能以root身份运行。当我们以root身份启动后，需要在程序内将进程切换成一个普通用户运行。下面是切换用户的示例代码：//  传入目标用户的uid和gid，以该uid和gid运行进程static bool switch_to_user(uid_t user_id, gid_t gp_id){  //  先确保目标用户不是root  if((user_id == 0) &amp;&amp; (gp_id == 0)){    return false;  }  //  确保当前用户是合法用户：如果当前用户不是root也不是目标用户，返回失败  gid_t gid = getgid();  uid_t uid = getuid();  if(((gid != 0) || (uid != 0)) &amp;&amp; ((gid != gp_id) || (uid != user_id))){    return false;  }  if(uid != 0){   //  如果不是root用户，则已经是目标用户了    return true;  }  if((setgid(gp_id) &lt; 0) || (setuid(user_id) &lt; 0)){ //  切换用户    return false;  }  return true;}进程组Linux中每一个进程都隶属于一个进程组，所以每个进程除了PID信息外，还包含进程组ID(PGID)信息。下面是getpgid的系统调用，功能是获取进程的进程组ID(PGID)，其函数原型如下：#include &lt;unistd.h&gt;pid_t getpgid(pid_t pig);参数和返回值：  pig: 需要查询的目标进程ID  返回值: 成功返回目标进程的PGID，失败则返回-1，并设置errno每个进程组都有一个首领进程，首领进程的PID和PGID相同。当进程组中的所有进程都退出，或者都加入到其他进程组，该进程组就会销毁。下面是setpgid的系统调用，功能是设置进程的进程组ID(PGID)，其函数原型如下：#include &lt;unistd.h&gt;int setpgid(pid_t pig, pid_t pgid);参数和返回值：  pig: 需要设置的目标进程ID  pgid: 目标进程需要加入的进程组ID  返回值: 成功返回0，失败则返回-1，并设置errnosetpgid函数根据传入参数的不同，可能会有不同的表现：  如果pid和pgid相同，则将pid对应的进程设置为进程组首领  如果pid为0，则需要设置的目标进程为当前进程  如果pgid为0，则使用pid作为目标PGID最后需要注意，一个进程只能设置自己或其子进程的PGID，并且子进程调用exec系列函数后，不能再通过父进程设置它的PGID。会话一些有关联的进程组可以形成一个会话(session)。下面是setsid的系统调用，功能是创建一个会话，其函数原型如下：#include &lt;unistd.h&gt;pid_t setsid(void);参数和返回值：  返回值: 成功返回新的进程组PGID，失败则返回-1，并设置errno这里需要注意，setsid函数不能由进程组的首领进程调用，否则会产生一个错误。对于非首领进程，调用函数时会创建新的会话，而且调用进程会称为会话的首领，此时该进程是新会话唯一的成员。也就是说，系统会新建一个进程组，其PGID就是调用进程的PID。而且调用进程如果有终端的话，将会甩开终端。虽然Linux进程未提供会话ID(SID)的概念，但是Linux系统认为它等于会话首领所在进程组的PGID，并提供相关函数来读取SID。下面是getsid的系统调用，功能是获取目标进程的会话ID(SID)，其函数原型如下：#include &lt;unistd.h&gt;pid_t getsid(pid_t pid);参数和返回值：  pid: 需要查询的目标进程的SID  返回值: 成功返回对应进程的SID，失败则返回-1，并设置errnoPS命令PS命令可以查看进程、进程组和会话之间的关系。$ ps -o pid,ppid,pgid,sid,comm | less   PID   PPID   PGID    SID COMMAND 83908  83906  83908  83908 bash172354  83908 172354  83908 ps172355  83908 172354  83908 less我们在bash shell下执行ps和less命令，所以ps和less命令的父进程是bash命令，可以看出ps和less命令的PPID(父进程ID)是bash命令的PID。这3条命令创建了1个会话(SID都是83908)和2个进程组(GID是83908和172354)。bash命令的PID、PGID、SID系统，所以它既是会话首领，又是进程组83908的首领。PS命令是进程组172354的首领。它们三者的关系如下图所示：总结      大部分服务器必须以root身份启动，但是不能以root身份运行    操作系统提供了用户信息相关的的系统调用，功能是获取或设置当前进程的真实用户ID(UID)、有效用户ID(EUID)、真实组ID(GID)、有效组ID(EGID)    Linux提供了有效用户ID，使运行程序的用户能够拥有该程序有效用户的权限    有效用户为root的进程被称为特权进程(privileged processes)    EGID的含义和EUID类似：给运行目标程序的组用户提供有效组的权限    操作系统提供了getpgid的系统调用，功能是获取进程的进程组ID(PGID)    操作系统提供了setpgid的系统调用，功能是设置进程的进程组ID(PGID)    操作系统提供了setsid的系统调用，功能是创建一个会话    操作系统提供了getsid的系统调用，功能是获取目标进程的会话ID(SID)    PS命令可以查看进程、进程组和会话之间的关系  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— Linux系统日志",
    "url": "/posts/Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, syslogd",
    "date": "2023-06-12 09:58:00 +0800",
    





    
    "snippet": "syslog/openlog/setlogmask/closelog  本节介绍了Linux系统中提供的syslogd守护进程，它是用来处理系统日志的。系统日志分为内核日志和用户进程输出的日志。我们简单介绍了这两种日志的生成过程。日志可以通过配置文件修改各种配置项，比如将不同的消息输出到指定的日志文件中。用户程序通过syslog函数输出系统日志。还可以通过openlog函数结构化日志内容，通...",
    "content": "syslog/openlog/setlogmask/closelog  本节介绍了Linux系统中提供的syslogd守护进程，它是用来处理系统日志的。系统日志分为内核日志和用户进程输出的日志。我们简单介绍了这两种日志的生成过程。日志可以通过配置文件修改各种配置项，比如将不同的消息输出到指定的日志文件中。用户程序通过syslog函数输出系统日志。还可以通过openlog函数结构化日志内容，通过setlogmask函数设置日志掩码，最后通过closelog函数关闭日志。rsyslogdLinux中提供了一个守护进程来处理系统日志：syslogd。现在一般使用它的升级版：rsyslogd。rsyslogd能接收的日志分为两种，如下图所示：  用户进程输出的日志  内核日志  内核日志内核日志通过printk等函数打印到内核中的一个循环队列缓存(ring buffer)中，然后缓存中的内容会直接映射到/proc/kmsg文件中。rsyslogd则通过去读该文件来获得内核日志。缓存中的内核信息可以通过dmesg命令来输出的终端中。  内核日志在老系统上通过另一个守护进程kdlogd来管理的，但后来rsyslogd利用额外的模块实现了相同的功能。  用户进程日志用户进程通过调用syslog函数生成系统日志。该函数通过UNIX本地域的socket将日志输出到/dev/log中。rsyslogd通过监听该文件来获得用户进程的日志。rsyslogd守护进程在接收到用户进程或内核的日志后，会把它们输出到特定的日志文件中。默认情况下，调试信息会保存到/var/log/debug文件，普通信息会保存到/var/log/messages文件，内核信息会保存到/var/log/kern.log文件。此外，rsyslogd可以在配置文件中设置这些日志具体怎么分发。rsyslogd的主配置文件是/etc/rsyslogd.conf，主要配置项包括：  内核日志输入路径  是否接收UDP日志及监听端口(默认端口514，在/etc/services文件中修改)  是否接收TCP日志及监听端口  日志文件的权限  包含哪些子配置文件(子配置文件在/etc/rsyslogd.d/*conf中，它用于指定各类日志的目标存储路径)syslog下面是syslog的系统调用，功能是使用户程序与rsyslogd守护进程进行通信，输出日志内容，其函数原型如下：#include &lt;syslog.h&gt;void syslog(int priority, const char *message, ...);参数和返回值：  priority: 设施值(默认LOG_USER)与日志级别的按位或，日志级别包括：          #define LOG_EMERG 0：系统不可用      #define LOG_ALERT 1：报警，需要立即采取动作      #define LOG_CRIT 2：非常严重的情况      #define LOG_ERR 3：错误      #define LOG_WARNING 4：警告      #define LOG_NOTICE 5：通知      #define LOG_INFO 6：信息      #define LOG_DEBUG 7：调试        message: 第二个参数和可变参数用来控制结构化输出openlogLinux还提供了openlog函数来进一步结构化日志内容，改变syslog函数的输出方式。下面是openlog的系统调用，功能是改变syslog函数的默认输出方式，其函数原型如下：#include &lt;syslog.h&gt;void openlog(const char* ident, int logopt, int facility);参数和返回值：  ident: 添加到日志信息的日期时间之后的字符串，通常为程序的名字  logopt: 控制syslog调用的行为，通常由以下值进行按位或：          #define LOG_PID 0x01: 在日志消息中包含程序PID      #define LOG_CONS 0x02: 如果消息不能记录到日志文件，则打印到终端      #define LOG_ODELAY 0x04: 延迟打开日志功能直到第一次调用syslog      #define LOG_NDELAY 0x08: 不延迟打开日志功能        facility: 修改syslog函数中的默认设施值setlogmasksetlogmask函数用来过滤日志，一般在开发中我们需要输出许多调试信息，但是在发布后，我们需要将这些调试信息关闭。这时候删除这些调试信息不是一个好的办法，因为后续维护时还需要用到这些调试信息。所以我们的解决方法是设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。下面是setlogmask的系统调用，功能是设置日志掩码，其函数原型如下：#include &lt;syslog.h&gt;void setlogmask(int maskpri);参数和返回值：  maskpri: 指定日志掩码值  返回值: 函数始终会成功，返回修改前的日志掩码值closelog下面是closelog的系统调用，功能是关闭日志，其函数原型如下：#include &lt;syslog.h&gt;void closelog();示例#include &lt;stdio.h&gt;#include &lt;syslog.h&gt;#include &lt;string.h&gt;int main(){\tint size = 23;\tchar str[] = \"system warning!\";\topenlog(\"zzf-log\", LOG_PID, LOG_USER);\t//\tDEBUG模式输出\tsyslog(LOG_USER | LOG_DEBUG, \"this is a DEBUG message: size is %d\\n\", size);\t//\tWARNING模式输出\tsyslog(LOG_USER | LOG_WARNING, \"this is a WARNING message: str is %s\\n\", str);\tcloselog();\treturn 0;}日志内容被输出到/var/log/syslog中，输出内容为：Jun 12 10:49:41 ubuntu zzf-log[61498]: this is a DEBUG message: size is 23Jun 12 10:49:41 ubuntu zzf-log[61498]: this is a WARNING message: str is system warning!总结      Linux中提供了一个守护进程来处理系统日志：syslogd。现在一般使用它的升级版：rsyslogd    rsyslogd能接收的日志分为两种：内核日志和用户进程日志    rsyslogd守护进程在接收到用户进程或内核的日志后，会把它们输出到特定的日志文件中    rsyslogd的主配置文件是/etc/rsyslogd.conf    操作系统提供了syslog的系统调用，功能是使用户程序与rsyslogd守护进程进行通信，输出日志内容    操作系统提供了openlog的系统调用，功能是进一步结构化日志内容，改变syslog函数的输出方式    操作系统提供了setlogmask的系统调用，功能是设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略    操作系统提供了closelog的系统调用，功能是关闭日志  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  铺瓷砖",
    "url": "/posts/%E9%93%BA%E7%93%B7%E7%A0%96/",
    "categories": "leetcode",
    "tags": "leetcode, Backtrack",
    "date": "2023-06-08 20:39:00 +0800",
    





    
    "snippet": "回溯  该题是回溯问题，问题规模比较小，所以我们可以创建出数组来模拟铺砖的情况。题目你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。假设正方形瓷砖的规格不限，边长都是整数。请你帮设计师计算一下，最少需要用到多少块方形瓷砖？例子示例1输入：n = 2, m = 3输出：3...",
    "content": "回溯  该题是回溯问题，问题规模比较小，所以我们可以创建出数组来模拟铺砖的情况。题目你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。假设正方形瓷砖的规格不限，边长都是整数。请你帮设计师计算一下，最少需要用到多少块方形瓷砖？例子示例1输入：n = 2, m = 3输出：3解释：3 块地砖就可以铺满卧室。     2 块 1x1 地砖     1 块 2x2 地砖示例2输入：n = 5, m = 8输出：5示例3输入：n = 11, m = 13输出：6条件  1 &lt;= n &lt;= 13  1 &lt;= m &lt;= 13难点分析该题的难点在于如何设计回溯函数，以及如何进行剪枝。我们以4 * 7的问题模型为例，我们知道初始时最大可铺面积的砖是4 * 4，但是贪心方案不一定能得到正确答案(比如示例3)。所以我们需要从1 * 1，2 * 2， 3 * 3， 4 * 4四种情况依次铺设。由于每次都一块砖一块砖铺，需要铺28次，是最慢的方案，所以我们倒序从4 * 4这种方案开始尝试。如下图所示，这是4 * 4铺砖后的情况：接下来我们计算dfs(i, j+1)的情况，即右边的空白部分……铺满所有瓷砖后，我们回溯初始状态，开始铺设3 * 3的情况。铺设3 * 3时，我们只要在原来的基础在，把最底和最右的边去掉即可：接下来我们计算dfs(i, j+1)的情况，即右边的空白部分和橙色部分……所以我们的回溯函数可以先用最大的砖铺设，然后每次去掉两条边，从而回溯所有情况。回溯时我们还需要设计剪枝方案，我们可以用铺设的砖块数作为剪枝条件，如果使用的砖块数大于之前得到方案，那我们就抛弃这种方案。解法解法1：动态规划class Solution {public:    int res, row, col;    int tilingRectangle(int n, int m) {        res = m*n;        row = n;        col = m;        vector&lt;vector&lt;int&gt;&gt; visited(n,vector&lt;int&gt;(m,0));        dfs(0, 0, 0, visited);        return res;    }    void dfs(int i, int j, int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;visited){        if(j == col){   //  这一层都铺完了，看下一层            i++;            j = 0;        }        if(i == row){   //  最后一层也铺完了，得到结果            res = cnt;            return;        }        if(visited[i][j] == 1){     //  这个点铺过砖了，往右看            dfs(i, j+1, cnt, visited);        }else if(cnt + 1 &lt; res){    //  剪枝            //  寻找可铺的最大面积的砖            int h = 0, w = 0;            for(int k = i ; k &lt; row ; k++){                if(visited[k][j] == 1){                    break;                }                h++;            }            for(int k = j ; k &lt; col ; k++){                if(visited[i][k] == 1){                    break;                }                w++;            }            int c = min(h, w);            //  开始铺砖            for(int ii = 0 ; ii &lt; c ; ii ++){                for(int jj = 0 ; jj &lt; c ; jj++){                    visited[i + ii][j + jj] = 1;        //  全部置1，进行铺砖                }            }            //  回溯            for(int ii = c - 1 ; ii &gt;= 0 ; ii--){                dfs(i, j + ii + 1, cnt + 1, visited);   //  回溯过程中，尝试铺砖小于c的情况                for(int jj = c - 1 ; jj &gt;= 0 ; jj--){                    visited[i + ii][j + jj] = 0;        //  去掉最底和最右的边                    visited[i + jj][j + ii] = 0;                }            }        }            }};解法2：使用状态压缩减少内存class Solution {public:    int res, row, col;    int filled[13];    int tilingRectangle(int n, int m) {        res = m*n;        row = n;        col = m;        dfs(0, 0, 0);        return res;    }    void dfs(int i, int j, int cnt){        if(j == col){            i++;            j = 0;        }        if(i == row){            res = cnt;            return;        }        if(filled[i] &gt;&gt; j &amp; 1){            dfs(i, j+1, cnt);        }else if(cnt + 1 &lt; res){            //  寻找可铺的最大面积的砖            int h = 0, w = 0;            for(int k = i ; k &lt; row ; k++){                if(filled[k] &gt;&gt; j &amp; 1){                    break;                }                h++;            }            for(int k = j ; k &lt; col ; k++){                if(filled[i] &gt;&gt; k &amp; 1){                    break;                }                w++;            }            int c = min(h, w);            //  开始铺砖            for(int ii = 0 ; ii &lt; c ; ii ++){                for(int jj = 0 ; jj &lt; c ; jj++){                    filled[i + ii] |= (1 &lt;&lt; (j + jj));                }            }                        //  回溯            for(int ii = c - 1 ; ii &gt;= 0 ; ii--){                dfs(i, j + ii + 1, cnt + 1);                for(int jj = c - 1 ; jj &gt;= 0 ; jj--){                    filled[i + ii] &amp;= ~(1 &lt;&lt; (j + jj));                    filled[i + jj] &amp;= ~(1 &lt;&lt; (j + ii));                }            }        }            }};Reference[1] 铺瓷砖"
  },
  
  {
    "title": "读书笔记 —— 高级IO函数_3",
    "url": "/posts/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, IO function",
    "date": "2023-06-08 10:24:00 +0800",
    





    
    "snippet": "tee/fcntl  本节介绍了剩下两个IO函数。第一个是tee函数，它可以在两个管道文件描述符之间复制数据，同样是零拷贝操作。通过与splice函数结合使用，可以实现高效的文件数据复制。fcntl函数则是修改文件描述符的属性和行为，在网络编程中，我们经常通过fcntl函数将socket设置为非阻塞状态。teetee函数在两个管道文件描述符之间复制数据，它同样是零拷贝操作。而且tee函数不会...",
    "content": "tee/fcntl  本节介绍了剩下两个IO函数。第一个是tee函数，它可以在两个管道文件描述符之间复制数据，同样是零拷贝操作。通过与splice函数结合使用，可以实现高效的文件数据复制。fcntl函数则是修改文件描述符的属性和行为，在网络编程中，我们经常通过fcntl函数将socket设置为非阻塞状态。teetee函数在两个管道文件描述符之间复制数据，它同样是零拷贝操作。而且tee函数不会消耗数据，源文件描述符上的数据仍然可以用于后续的读操作。下面是tee的系统调用，功能是在两个管道文件描述符之间复制数据，其函数原型如下：#include &lt;fcntl.h&gt;ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);参数和返回值：  fd_in: 待读取内容的文件描述符，必须是管道文件描述符  fd_out: 待写入内容的文件描述符，必须是管道文件描述符  len: 指定复制数据的长度  flags: 控制复制数据的行为，取值和splice函数相同，其常用值及含义下表  返回值：成功返回复制的字节数，可能为0，表示没有复制任何数据。失败返回-1，并设置errnotee函数的flags参数的常用值及其含义            常用值      含义                  SPLICE_F_MOVE      如果合适的话，按整页内存移动数据。这只是给内核的一个提示。不过因为它的实现存在BUG，所以自内核2.6.21后，它实际上没有任何效果              SPLICE_F_NONBLOCK      非阻塞的splice操作，但实际效果还会受到文件描述符本身的阻塞状态的影响              SPLICE_F_MORE      给内核一个提示：后续的splice调用将读取更多数据              SPLICE_F_GIFT      对splice没有效果      下面我们举个例子，我们对之前通过splice函数实现的回射服务器进行修改，使客户端发送过来的数据。#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[]){  if(argc != 2){    printf(\"usage: %s &lt;file&gt;\\n\", basename(argv[0]));    return 1;  }  int filefd = open(argv[1], O_CREAT | O_WRONLY | O_TRUNC, 0666);  assert(filefd &gt; 0);  int pipefd_stdout[2];  int ret = pipe(pipefd_stdout);  //  创建输出到终端的管道  assert(ret != -1);  int pipefd_file[2];  ret = pipe(pipefd_file);    //  创建输出到文件的管道  assert(ret != -1);  //  将标准输入内容传递给管道pipefd_stdout  ret = splice(STDIN_FILENO, NULL, pipefd_stdout[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE);  assert(ret != -1);  //  将管道pipefd_stdout的输出复制到管道pipefd_file的输入端  ret = tee(pipefd_stdout[0], pipefd_file[1], 32768, SPLICE_F_NONBLOCK);  assert(ret != -1);  //  将管道pipefd_file的输出定向到文件描述符filefd上，及标准输入的内容写入文件  ret = splice(pipefd_file[0], NULL, filefd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE);  assert(ret != -1);  //  将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致  ret = splice(pipefd_stdout[0], NULL, STDOUT_FILENO, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE);  assert(ret != -1);  close(filefd);  close(pipefd_stdout[0]);  close(pipefd_stdout[1]);  close(pipefd_file[0]);  close(pipefd_file[1]);  return 0;}fcntlfcntl函数是file control的缩写，所以它提供了对文件描述符的各种控制操作。下面是fcntl的系统调用，功能是控制文件描述符的属性和行为，其函数原型如下：#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ...);参数和返回值：  fd: 被操作的文件描述符  cmd: 指定执行的操作类型  …: 根据操作类型的不同，可能需要传入第三个可选参数arg  返回值: 成功时返回值由操作类型决定，失败返回-1，并设置errnofcntl函数常用的命令及其参数            操作分类      操作      含义      第三个参数的类型      成功时的返回值                  复制文件描述符      F_DUPFD      创建一个新的文件描述符，其值大于会等于arg      long      新创建的文件描述符的值              复制文件描述符      F_DUPFD_CLOEXEC      与F_DUPFD类似，不过在创建文件描述符的同时，设置close-on-exec标志      long      新创建的文件描述符的值              获取和设置文件描述符的标志      F_GETFD      获取fd的标志，比如close-on-exec标志      无      fd的标志              获取和设置文件描述符的标志      F_SETFD      设置fd的标志      long      0              获取和设置文件描述符的状态标志      F_GETFL      获取fd的状态标志，这些标志包括可由open系统调用设置的标志(O_APPEND、O_CREAT等)和访问模式(O_RDONLY、O_WRONLY、和O_RDWR)      void      fd的状态标志              获取和设置文件描述符的状态标志      F_SETFL      设置fd的状态标志，但部分标志是不能被修改的(比如访问模式标志)      long      0              管理信号      F_GETOWN      获得SIGIO和SIGURG信号的宿主进程的PID或进程组的组ID      无      信号的宿主进程的PID或进程组的组ID              管理信号      F_SETOWN      设定SIGIO和SIGURG信号的宿主进程的PID或进程组的组ID      long      0              管理信号      F_GETSIG      获取当应用程序被通知fd可读或可写时，是哪个信号通知该事件的      无      信号值，0表示SIGIO              管理信号      F_SETSIG      设置当fd可读或可写时，系统应该触发哪个信号来通知应用程序      long      0              操作管道容量      F_SETPIPE_SZ      设置由fd指定的管道的容量，/proc/sys/fs/pipe-size-max内核参数指定了fcntl能设置的管道容量的上限      long      0              操作管道容量      F_GETPIPE_SZ      获取由fd指定的管道的容量      无      管道容量        另一个常见的控制文件描述符属性和行为的系统调用是ioctl，ioctl能够比fcntl执行更多的控制。但是fcntl函数是POSIX规定指定的首选方法，控制文件描述符常见的属性和行为一般选择使用fcntl。我们通过一个例子说明fcntl函数的用法：在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。int setnonblock(int fd){  int old_option = fcntl(fd, F_GETFL);  int new_option = old_option | O_NONBLOCK;  fcntl(fd, F_SETFL, new_option);  return old_option; }  SIGIO和SIGURG信号与其他Linux信号不同，它们必须与某个文件描述符相关联才可使用。      当被关联的文件描述符可读或可写时，系统会触发SIGIO信号。    当被关联的文件描述符(必须是socket)有带外数据可读时，系统会触发SIGURG信号。    将信号与文件描述符关联的方法是使用fcntl函数，为目标文件描述符指定宿主进程或进程组，这样被指定的宿主进程或进程组将捕获这两个信号。需要注意的是，使用SIGIO信号时，还需要利用fcntl函数将目标文件描述符设置O_ASYNC标志(异步I\\O标志，不过SIGIO信号模型不是真正意义上的异步I\\O模型)总结      操作系统提供了tee的系统调用，功能是在两个管道文件描述符之间复制数据，是零拷贝操作    操作系统提供了fcntl的系统调用，功能是控制文件描述符的属性和行为  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 高级IO函数_2",
    "url": "/posts/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, IO function",
    "date": "2023-06-07 15:54:00 +0800",
    





    
    "snippet": "sendfile/mmap/munmap/splice  本节介绍了另外一些高级IO函数。其中sendfile函数如其名字一样，将文件传输给socket文件描述符，它是专门为网络传输设计的，而且传输过程在内核执行，不需要先拷贝到用户缓冲区中，也不需要调用read函数读取文件，所以它更加高效。mmap函数可以申请一段内存，这段内存既可以作为共享内存，也可以将文件映射其中。当我们使用完毕时，需要...",
    "content": "sendfile/mmap/munmap/splice  本节介绍了另外一些高级IO函数。其中sendfile函数如其名字一样，将文件传输给socket文件描述符，它是专门为网络传输设计的，而且传输过程在内核执行，不需要先拷贝到用户缓冲区中，也不需要调用read函数读取文件，所以它更加高效。mmap函数可以申请一段内存，这段内存既可以作为共享内存，也可以将文件映射其中。当我们使用完毕时，需要用munmap函数释放这段内存。最后我们介绍了splice函数，它的作用是在两个文件描述符之间传递数据，其中一个文件描述符必须是管道文件描述符。由于它同时实现了零拷贝操作，不需要先拷贝到用户缓冲区中，也不需要调用read函数读取文件，所以实现起来更加高效。sendfilesendfile函数用于在两个文件描述符之间直接传递数据，它完全在内核进行操作，避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，一般被称为零拷贝。但是sendfile函数传递数据的两个文件描述符是有限制的，读文件描述符必须指向真实的文件(能支持mmap之类的函数)，也就是说不能是socket或管道。而写文件描述符必须是socket。所以，sendfile几乎是专门为在网络上传输文件而设计的。下面是sendfile的系统调用，功能是将文件中的数据高效地传输给socket，其函数原型如下：#include &lt;sys/sendfile.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);参数和返回值：  out_fd: 待读取内容的文件描述符  in_fd: 待写入内容的文件描述符  offset: 读入文件流的起始位置，如果为空，表示从文件的开头开始读取  count: 指定在两个文件描述符之间传输的字节数  返回值：成功返回传输的字节数，失败返回-1，并设置errno下面我们举个例子，利用sendfile函数将服务器上的文件发送给客户端。#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/sendfile.h&gt;int main(int argc, char *argv[]){  if(argc &lt;= 3){    printf(\"usage: %s ip_address port_number filename\\n\", basename(argv[0]));    return 1;  }  const char *ip = argv[1];  int port = atoi(argv[2]);  const char *file_name = argv[3];  int filefd = open(file_name, O_RDONLY);   //  打开文件，获取文件描述符in_fd  assert(filefd &gt; 0);  struct stat stat_buf;   fstat(filefd, &amp;stat_buf);   //  获取文件属性，得到文件的长度    struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sock = socket(PF_INET, SOCK_STREAM, 0);  assert(sock &gt;= 0);  int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(sock, 5);  assert(ret != -1);  struct sockaddr_in client;  socklen_t client_addrlength = sizeof(client);  int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);  if(connfd &lt; 0){    printf(\"errno is: %d\\n\", errno);  }else{    //  传输文件时，没有为目标文件分配用户空间的缓冲区，也没有读取文件，所以效率更高    sendfile(connfd, filefd, NULL, stat_buf.st_size);    close(connfd);  }  close(sock);  return 0;}mmap/munmapmmap函数可以申请一段内存空间，这段内存空间可以用于进程间通信(作为共享内存)，也可以将文件映射到内存中。munmap函数则是释放由mmap函数创建的内存空间。下面是mmap/munmap的系统调用，功能是申请一段内存空间和释放这段内存空间，其函数原型如下：#include &lt;sys/mman.h&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *start, size_t length);参数和返回值：  start: 允许用户使用某个特定的地址作为这段内存的起始地址，如果该参数为空，则系统会自动分配一个地址  length: 指定内存段的长度  prot: 设置内存段的访问权限，它由下面几个值按位或组成：          PROT_READ: 内存段可读      PROT_WRITE: 内存段可写      PROT_EXEC: 内存段可执行      PROT_NONE: 内存段不可被访问        flags: 控制内存段的内容被修改后程序的行为，具体参数值及含义见下表，某些值可以通过按位或组成  fd: 被映射文件对应的文件描述符，一般通过open系统调用获得  offset: 设置文件的初始映射位置，如果为空，则从文件的开头开始映射  返回值: mmap成功返回指向目标内存区域的指针，失败返回MAP_FAILED(即(void*)-1)，并设置errno。munmap成功返回0，失败返回-1，并设置errnoflags参数的常用值及其含义            常用值      含义                  MAP_SHARED      在进程间共享这段内存。对该内存段的修改将反映到被映射的文件中。它提供了进程间共享内存的POSIX方法              MAP_PRIVATE      内存段为调用进程所私有。对该内存段的修改不会反映到被映射的文件中              MAP_ANONYMOUS      这段内存不是从文件映射而来的，其内存被初始化为全0。这种情况下，mmap函数的最后两个参数将被忽略              MAP_FIXED      内存段必须位于start参数指定的地址处，且start地址必须是内存页面大小(4096字节)的整数倍              MAP_HUGETLB      按照“大内存页面”来分配内存空间，“大内存页面”的大小可通过/proc/meminfo文件来查看      这里需要注意，MAP_SHARED和MAP_PRIVATE是互斥的，所以它们不能以按位或的方式同时指定。  大内存页面是指Linux中允许配置定义更大的页面。大内存页面的作用是减少页表项。比如1GB内存有262144页(Linux页面大小为4096B)，需要262144个页表项。而TBL无法缓存这么多页表项，会出现大量未命中的情况，导致性能下降。如果我们使用2MB的大内存页，那么就只需要512页，也就是只需要512个页表项，可以大大增加TBL的命中率，提高进程性能。splicesplice可以在两个文件描述符之间移动数据，实现零拷贝操作。但需要注意，两个文件描述符必须至少有一个是管道文件描述符。下面是splice的系统调用，功能是在两个文件描述符之间移动数据，其函数原型如下：#include &lt;fcntl.h&gt;ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);参数和返回值：  fd_in: 待输入数据的文件描述符  off_in: 根据fd_in和off_in的不同取值有不同的含义          如果fd_in是管道文件描述符，则off_in必须设为NULL      如果fd_in不是管道文件描述符，且off_in为NULL，表示从当前偏移位置开始读取数据      如果fd_in不是管道文件描述符，且off_in不为NULL，表示从off_in指定位置开始读取数据        fd_out: 待输出数据的文件描述符  off_out: 根据fd_out和off_out的不同取值有不同的含义          如果fd_out是管道文件描述符，则off_out必须设为NULL      如果fd_out不是管道文件描述符，且off_out为NULL，表示从当前偏移位置开始写入数据      如果fd_out不是管道文件描述符，且off_out不为NULL，表示从off_out指定位置开始写入数据        len: 指定移动数据的长度  flags: 控制数据移动行为，具体参数值及含义见下表，参数值也可以通过按位或的方式进行组合  返回值: 成功返回移动字节的数量，可能返回0，表示从管道中读取数据，但是管道中没有任何被写入的数据。失败返回-1，并设置errnosplice函数的flags参数的常用值及其含义            常用值      含义                  SPLICE_F_MOVE      如果合适的话，按整页内存移动数据。这只是给内核的一个提示。不过因为它的实现存在BUG，所以自内核2.6.21后，它实际上没有任何效果              SPLICE_F_NONBLOCK      非阻塞的splice操作，但实际效果还会受到文件描述符本身的阻塞状态的影响              SPLICE_F_MORE      给内核一个提示：后续的splice调用将读取更多数据              SPLICE_F_GIFT      对splice没有效果      splice函数失败时，常见的errno            错误      含义                  EBADF      参数所指文件描述符有错              EINVAL      存在以下四种错误之一： 1.目标文件系统不支持splice; 2.目标文件以追加方式打开; 3.两个文件描述符都不是管道文件描述符; 4.某个offset参数被用于不支持随机访问的设备（比如字符设备）              ENOMEM      内存不够              ESPIPE      参数fd_in(或fd_out)是管道文件描述符，但off_in(或off_out)不为NULL      下面我们通过一个例子来说明splice函数的用法，我们创建一个零拷贝的回射服务器，它会将客户端发送的数据原样地返回给客户端。#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char *ip = argv[1];  int port = atoi(argv[2]);  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sock = socket(PF_INET, SOCK_STREAM, 0);  assert(sock &gt;= 0);  int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(sock, 5);  assert(ret != -1);  struct sockaddr_in client;  socklen_t client_addrlength = sizeof(client);  int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);  if(connfd &lt; 0){    printf(\"error is: %d\", errno);  }else{    int pipefd[2];    ret = pipe(pipefd);   //  创建一对管道    assert(ret != -1);    //  将connfd流入的客户端数据定向的管道中    ret = splice(connfd, NULL, pipefd[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE);    assert(ret != -1);    //  将管道中的输出定向到connfd客户连接的文件描述符中    ret = splice(pipefd[0], NULL, connfd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE);    assert(ret != -1);        close(connfd);  }  close(sock);  return 0;}我们通过splice函数将客户端的内容读入管道pipefd[1]中，再使用splice函数从管道pipefd[0]中读出该内容到客户端中。整个过程未执行read/write操作，也未使用任何缓存区进行数据拷贝，从而实现了简单高效的回射服务。总结      操作系统提供了sendfile的系统调用，功能是将文件中的数据高效地传输给socket，避免内核缓冲区和用户缓冲区之间的数据拷贝    操作系统提供了mmap的系统调用，功能是申请一段内存空间，这段内存空间可以用于进程间通信(作为共享内存)，也可以将文件映射到内存中    操作系统提供了munmap的系统调用，功能是释放由mmap函数创建的内存空间。    操作系统提供了splice的系统调用，功能是在两个文件描述符之间移动数据  Reference[1] 《深入解析高性能服务器编程》  [2] linux内存–大内存页（大页）"
  },
  
  {
    "title": "刷题笔记 ——  132 模式",
    "url": "/posts/132%E6%A8%A1%E5%BC%8F/",
    "categories": "leetcode",
    "tags": "leetcode, Monotonic Stack",
    "date": "2023-06-04 18:50:00 +0800",
    





    
    "snippet": "单调栈  该题也是单调栈的一种，相比之前讲解过的单调栈问题，该题是利用132模式的特点来求解。我们可以从中学到一些技巧：1. 利用单调栈出栈的元素；2. 用数组表示一个过程的最小值。题目给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i]...",
    "content": "单调栈  该题也是单调栈的一种，相比之前讲解过的单调栈问题，该题是利用132模式的特点来求解。我们可以从中学到一些技巧：1. 利用单调栈出栈的元素；2. 用数组表示一个过程的最小值。题目给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。例子示例1输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。示例2输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。示例3输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。条件  n == nums.length  1 &lt;= n &lt;= 2 * 10^5  -10^9 &lt;= nums[i] &lt;= 10^9难点分析我们对该题进行分析，我们需要找到这么一组元组，满足i &lt; j &lt; k，且nums[i] &lt; nums[k] &lt; nums[j]。  单调栈我们可以固定其中一个元素i，然后找到满足nums[k] &lt; nums[j]的一对元素。所以我们可以得到一个时间为O(n^2)的解法。我们固定i元素，然后内层遍历中，遍历过的元素用一个维持一个最大值j，如果存在nums[k] &gt; nums[i] &amp;&amp; nums[k] &lt; j的情况，则返回true。但这个方法会超时，不可行，我们需要把第二层循环优化。因为nums[k] &lt; nums[j]的特性，我们可以使用单调栈来维护。所以我们给出第一种解法：我们从数组尾部开始遍历，尾部第一个元素入栈，如果尾部第二个元素小于栈顶元素（尾部第一个元素），此时满足nums[k] &gt; nums[j]，很明显不是我们要找的，所以继续入栈。如果尾部第二个元素大于栈顶元素（尾部第一个元素），此时满足nums[k] &lt; nums[j]。接下来我们只需要考虑是否存在nums[i]小于nums[j]和nums[k]即可。我们可以将尾部第一个元素出栈(nums[j])，然后用一个变量为维护出栈元素的最大值。因为出栈的情况，说明栈中有比出栈元素值更大的元素，相对于栈中存放了nums[j]，而出栈的元素是nums[k]。如果我们当前遍历的元素小于出栈元素的最大值，即存在nums[i] &lt; nums[k]。而栈中元素更大，自然也满足nums[i] &lt; nums[j]。这样我们可以一次循环的情况下找到目标元组。  有序集合我们考虑j，nums[j]是最大的。当我们遍历时，i出现在j的左边，且nums[i] &lt; nums[j]。我们可以用维护一个最小值变量来保存i。k出现在j的右边，且nums[i] &lt; nums[k] &lt; nums[j]。我们需要找到大于左边最小值的第一个值，然后判断它是否小于nums[j]。那右边我们可以用一个有序集合来存储，通过有序集合，我们可以在O(logn)时间内找到大于左边最小值的第一个值。基于这个思想，我们得到了解法2。  单调栈+前缀最小和我们考虑k，k是最后出现的元素，i和j前面已经出现过了。也就是说，如果前面存在一个元素比nums[k]大，存在一个元素比nums[k]小，就可以找到132模式。由于j &lt; k，只要前面存在一个元素比nums[k]大，那么nums[j] &lt; nums[k]就一定成立。现在的问题在于如果我们维护一个最小值变量，哪怕遇到在nums[k]之前遇到一个比它小的值，也不能保证它出现在j之前。所以我们想到一个解决方法，用一个数组记录每一步遇到的最小值，数组第i个元素表示nums数组第i次循环时遇过的最小值。然后我们同样用单调栈来保持j，如果当前元素大于栈顶元素，则栈顶元素出栈，当前元素入栈。只要栈不为空，就说明栈中一定存在至少一个元素，大于当前元素，满足nums[j] &gt; nums[k]。此时我们取出j的值，带入最小值数组中，判断j之前遇过的最小值是否存在小于nums[k]的，如果小于，就找到了题目所要求的132模式。具体算法见解法3。解法解法1：单调栈class Solution {public:    bool find132pattern(vector&lt;int&gt;&amp; nums) {        stack&lt;int&gt; st;        int  k = INT_MIN;        for(int i = nums.size() - 1 ; i &gt;= 0 ; i--){            if(nums[i] &lt; k){                return true;            }            while(!st.empty() &amp;&amp; nums[i] &gt; st.top()){                k = max(k, st.top());                st.pop();            }            if (nums[i] &gt; k) {  //  优化：小于等于k的nums[i]不需要入栈                st.push(nums[i]);            }        }        return false;    }};解法2：有序集合class Solution {public:    bool find132pattern(vector&lt;int&gt;&amp; nums) {        int k1 = nums[0];        multiset&lt;int&gt; right;        for(int i = 2 ; i &lt; nums.size() ; i++){            right.insert(nums[i]);        }        for(int i = 1 ; i &lt; nums.size() - 1 ; i++){            auto k3 = right.upper_bound(k1);    //  upper_bound函数可以得到大于k1的第一个最接近的值            if(k3 != right.end() &amp;&amp; nums[i] &gt; k1 &amp;&amp; nums[i] &gt; *k3){                return true;            }            k1 = min(k1, nums[i]);            right.erase(right.find(nums[i + 1]));        }        return false;    }};解法3：单调栈+前缀最小和class Solution {public:    bool find132pattern(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();                stack&lt;int&gt; st;        vector&lt;int&gt; pmin(n + 1, 0);        pmin[0] = INT_MAX;      //  用一个数组记录第i步时遇过的最小值        for(int i = 0 ; i &lt; n ; i++){            while(!st.empty() &amp;&amp; nums[st.top()] &lt;= nums[i]){                st.pop();            }               //  如果st栈不为空，说明栈中存在比当前元素nums[i]更大的元素            //  又因为st.top()对应的步数遇到的最小值小于当前元素nums[i]，所以满足132 模式            if(!st.empty() &amp;&amp; pmin[st.top()] &lt; nums[i]){                return true;            }            //  更新遇过的最小值            pmin[i + 1] = min(pmin[i], nums[i]);            st.push(i);        }        return false;    }};Reference[1] 132 模式"
  },
  
  {
    "title": "读书笔记 —— 高级IO函数_1",
    "url": "/posts/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, IO function",
    "date": "2023-06-04 18:49:00 +0800",
    





    
    "snippet": "pipe/socketpair/dup/dup2/readv/writev  本节介绍了Linux中一些高级IO函数。管道是进程间常用的IO方式之一，通过pipe系统调用我们可以创建一对管道。但是需要注意，pipe创建的管道中，fd[0]只能用于读，fd[1]只能用于写，不能反过来。而socket基础API中提供了socketpair调用，它可以创建一对双端管道。此外，我们将标准输入或标准输...",
    "content": "pipe/socketpair/dup/dup2/readv/writev  本节介绍了Linux中一些高级IO函数。管道是进程间常用的IO方式之一，通过pipe系统调用我们可以创建一对管道。但是需要注意，pipe创建的管道中，fd[0]只能用于读，fd[1]只能用于写，不能反过来。而socket基础API中提供了socketpair调用，它可以创建一对双端管道。此外，我们将标准输入或标准输出重定向到某个文件描述符，这样我们可以实现将标准输入输出流向文件、管道或网络连接中。dup和dup2的差别是，dup2的第二个参数可以控制返回的文件描述符的值。最后我们介绍了readv和writev调用，它和普通的read/write调用相比，可以从分散的内存中集中读或分散写，避免了我们读取后需要对不同内存块的数据手动拼接，或者避免了我们多次调用write调用写入不同的内存位置。pipe下面是pipe的系统调用，功能是创建一个管道，实现进程间的通信，其函数原型如下：#include &lt;unistd.h&gt;int pipe(int fd[2]);参数和返回值：  fd: 包含2个int型整数的数组指针，管道打开的文件描述符会填入数组中  返回值：成功返回0，失败返回-1，并设置errnopipe函数打开了两个文件描述符fd[0]和fd[1]，它们构成了管道的两端。这里需要注意，fd[0]只能用于读，fd[1]只能用于写，不能反过来。这意味着管道只能单向流动。如果我们需要实现双向的数据传输，那就需要创建两个管道。默认情况下，这对管道是阻塞的。也就是说如果我们读取一个空的管道，read调用则会被阻塞。反之，如果我们写入一个满的管道，write调用同样会被阻塞，直到管道有空闲空间为止。不过，我们可以设置管道为非阻塞。如果我们关闭文件描述符fd[1]（此时fd[1]的引用计数为0），意味着没有任何进程能向管道中写入数据。此时如果对读端的文件描述符fd[0]的调用read，会返回0，表示读到文件结束标记(End Of File, EOF)。如果我们关闭文件描述符fd[0]（此时fd[0]的引用计数为0），意味着没有任何进程能向管道中读取数据。此时如果对写端的文件描述符fd[1]的调用write，会操作失败，并触发SIGPIPE信号。管道内部传输的是字节流，就如同现实中的管道一样，它也是有容量限制的。Linux内核2.6.11起，管道容量的大小默认是65536字节。但是我们可以通过fcntl函数来修改管道容量。最后我们介绍一个可以快捷创建双向管道的函数——socketpair，该函数打开的一对管道即可读也可写，而pipe打开的一对管道是单向的。它是socket中一个基础API。下面是socketpair的系统调用，功能是创建一个双向管道，实现进程间的通信，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int fd[2]);参数和返回值：  domain: 协议族，这里只能使用UNIX本地域协议族AF_UNIX，因为双向管道只能在本地使用  type: 指定服务类型，SOCK_STREAM流服务或SOCK_UGRAM数据报服务  protocol：在前两个参数构成的协议集合中，再选择一个具体的协议，默认取0  fd: 包含2个int型整数的数组指针，管道打开的文件描述符会填入数组中  返回值：成功返回0，失败返回-1，并设置errnodup/dup2下面是dup/dup2的系统调用，功能是将标准输入重定向到一个文件，或者将标准输出重定向到一个网络连接，其函数原型如下：#include &lt;unistd.h&gt;int dup(int file_descriptor);int dup2(int file_descriptor_one, int file_descriptor_two);参数和返回值：  file_descriptor/file_descriptor_one: 需要重定向的文件描述符  file_descriptor_two: 新创建文件描述符时，取第一个不小于file_descriptor_two的整数值  返回值: 成功返回新创建的文件描述符，失败返回-1，并设置errnodup函数会创建一个新的文件描述符，然后将新的文件描述符和原有的文件描述符指向相同的文件、管道或网络连接。dup总是返回当前系统可用的最小的文件描述符，而dup2则返回第一个不小于file_descriptor_two的整数值。下面我们举个例子，通过dup函数实现CGI服务器模型：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]){  if(argc &lt;= 2){    printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));    return 1;  }  const char *ip = argv[1];  int port = atoi(argv[2]);  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sock = socket(PF_INET, SOCK_STREAM, 0);  assert(sock &gt;= 0);  int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(sock, 5);  assert(ret != -1);  struct sockaddr_in client;  socklen_t client_addrlength = sizeof(client);  int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);  if(connfd &lt; 0){    printf(\"errno is: %d\\n\", errno);  }else{    close(STDOUT_FILENO); //  关闭标准输出STDOUT_FILENO（值为1）    dup(connfd);          //  对文件描述符connfd重定向                          //  由于之前关闭的标准输出的文件描述符的值1是最小的                          //  所以这里返回1    printf(\"abcd\\n\");     //  这里标准输出的内容(abcd)                          //  会字节发送到客户端连接的socket上                          //  不会在本地显示器中显示    close(connfd);  }}  dup和dup2创建的文件描述符不会继承原文件描述符的属性，比如close-on-exec和non-blocking等readv/writev下面是readv/writev的系统调用，功能是从文件描述符读取分散的内存块(分散读)，或将多块分散的内存数据一起写入文件描述符中(集中读)，其函数原型如下：#include &lt;sys/uio.h&gt;ssize_t readv(int fd, const struct iovec *vector, int count);ssize_t writev(int fd, const struct iovec *vector, int count);参数和返回值：  fd: 目标文件描述符  vector: iovec结构体数组，结构体包含内存块地址及块长度  count: vector数组的长度，表示读取或写入多少块内存数据  返回值: 成功返回读取或写入的字节数，失败返回-1，并设置errno我们通过一个例子说明writev的作用：当我们解析完一个HTTP请求后，需要将1个状态行、多个头部字段、1个空行、响应文档的内容返回给客户端。一般前3部分可能被Web服务器放置在某一块内存，而文档则通常从另一块内存中读取。这时候我们不需要手动把这两部分内容进行拼接，而是可以通过writev函数将它们同时写入。该例子的代码如下：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/uio.h&gt;#define BUFFER_SIZE 1024static const char *status_line[2] = {\"200 ok\", \"500 Internal server error\"};int main(int argc, char *argv[]){  if(argc &lt;= 3){    printf(\"usage: %s ip_address port_number filename\\n\", basename(argv[0]));    return 1;  }  const char *ip = argv[1];  int port = atoi(argv[2]);  const char *file_name = argv[3];  //  目标文件  struct sockaddr_in address;  bzero(&amp;address, sizeof(address));  address.sin_family = AF_INET;  inet_pton(AF_INET, ip, &amp;address.sin_addr);  address.sin_port = htons(port);  int sock = socket(PF_INET, SOCK_STREAM, 0);  assert(sock &gt;= 0);  int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));  assert(ret != -1);  ret = listen(sock, 5);  assert(ret != -1);  struct sockaddr_in client;  socklen_t client_addrlength = sizeof(client);  int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);  if(connfd &lt; 0){    printf(\"error is: %d\", errno);  }else{    char header_buf[BUFFER_SIZE]; //  保存HTTP响应报文的状态行、头部字段、空行    memset(header_buf, '\\0', BUFFER_SIZE);    char *file_buf;         //  存放目标文件内容的缓存    struct stat file_stat;  //  获取目标文件的属性（比如是否为目录，文件大小）    bool valid = true;      //  目标文件是否有效    int len = 0;            //  缓存区header_buf已使用空间    if(stat(file_name, &amp;file_stat) &lt; 0){  //  目标文件不存在      valid = false;            }else{      if(S_ISDIR(file_stat.st_mode)){ //  目标文件是目录        valid = false;            }else if(file_stat.st_mode &amp; S_IROTH){  //  目标文件有读权限        int fd = open(file_name, O_RDONLY);   //  打开文件        file_buf = new char[file_stat.st_size + 1]; //  申请缓存区        memset(file_buf, '\\0', file_stat.st_size + 1);        if(read(fd, file_buf, file_stat.st_size) &lt; 0){  //  读取目标文件          valid = false;    //  读取文件失败        }      }else{  //  目标文件没有读权限        valid = false;            }    }    if(valid){    //  如果目标文件有效，则响应http应答      ret = snprintf(header_buf, BUFFER_SIZE - 1, \"%s %s\\r\\n\", \"HTTP/1.1\", status_line[0]); //  状态行      len += ret;      ret = snprintf(header_buf + len, BUFFER_SIZE - 1 - len, \"Content-Length: %d\\r\\n\", int(file_stat.st_size)); //  头部字段      len += ret;      ret = snprintf(header_buf + len, BUFFER_SIZE - 1 - len, \"%s\", \"\\r\\n\");  //  空行      //  利用writev将header_buf和file_buf的内容一起写入connfd      struct iovec iv[2];      iv[0].iov_base = header_buf;      iv[0].iov_len = strlen(header_buf);      iv[1].iov_base = file_buf;      iv[1].iov_len = file_stat.st_size;      ret = writev(connfd, iv, 2);    //  将两块内存同时写入文件描述符connfd      printf(\"writev %d bytes\\n\", ret);\t  delete[] file_buf;\t//\tdelete语句不能放到该if区块之外，否则会释放无效内存    }else{        //  如果目标文件无效，则向客户端发送错误      ret = snprintf(header_buf, BUFFER_SIZE - 1, \"%s %s\\r\\n\", \"HTTP/1.1\", status_line[1]); //  状态行      len += ret;      ret = snprintf(header_buf + len, BUFFER_SIZE - 1 - len, \"%s\", \"\\r\\n\");  //  空行      send(connfd, header_buf, strlen(header_buf), 0);  //  发送响应    }    close(connfd);  }  close(sock);  return 0;}总结      操作系统提供了pipe的系统调用，功能是创建一个管道，实现进程间的通信    pipe创建的管道中，fd[0]只能用于读，fd[1]只能用于写，不能反过来    操作系统提供了socketpair的系统调用，功能是创建一个双向管道，管道的任意一端都可读可写    操作系统提供了dup和dup2的系统调用，功能是将标准输入重定向到一个文件，或者将标准输出重定向到一个网络连接    操作系统提供了readv和writev的系统调用，功能是从文件描述符读取分散的内存块(分散读)，或将多块分散的内存数据一起写入文件描述符中(集中读)  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "刷题笔记 ——  礼盒的最大甜蜜度",
    "url": "/posts/%E7%A4%BC%E7%9B%92%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9C%E8%9C%9C%E5%BA%A6/",
    "categories": "leetcode",
    "tags": "leetcode, Binary Search",
    "date": "2023-06-01 19:41:00 +0800",
    





    
    "snippet": "二分查找  这类问题属于找最大的最小值或找最小的最大值问题，这类问题可以使用二分查找求解。题目给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。返回礼盒的 最大 甜蜜度。例子示例1输入：price = [13,5,1,8,21,2]...",
    "content": "二分查找  这类问题属于找最大的最小值或找最小的最大值问题，这类问题可以使用二分查找求解。题目给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。返回礼盒的 最大 甜蜜度。例子示例1输入：price = [13,5,1,8,21,2], k = 3输出：8解释：选出价格分别为 [13,5,21] 的三类糖果。礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。可以证明能够取得的最大甜蜜度就是 8 。示例2输入：price = [1,3,1], k = 2输出：2解释：选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。可以证明能够取得的最大甜蜜度就是 2 。示例3输入：price = [7,7,7,7], k = 2输出：0解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。条件  1 &lt;= price.length &lt;= 10^5  1 &lt;= price[i] &lt;= 10^9  2 &lt;= k &lt;= price.length难点分析该题是在数组中抽出k个元素，然后计算这k个元素的最小差值。抽出k个元素有不同的抽法，我们需要找到某一种抽法，使得最小差值最大。这是一类求最大的最小值问题，我们不可能使用暴力法一种一种去试。所以我们换种思路，我们进行排序。然后差值最大的是最后一个元素减第一个元素x（当然，这种组合不是正确答案）。接下来我们可以尝试是否能凑出结果为x-1的组合。不行的话，是否能凑出结果为x-2的组合。以此类推，当我们能凑到x-n的组合时，最大的甜蜜度就是x-n。当然这样效率低下，我们可以用二分法来代替这个凑组合的过程。如果存在满足最大甜蜜度为mid的分法，那我们令low=mid，继续二分，直到循环结果。此时的low就是最大甜蜜度。现在只剩一个问题，这么判断是否存在mid的分法。前面我们已经对数组进行排序了，那我们令差值大于mid的为一组。如果有k - 1组，说明有k个点，这k个点的差值都满足大于mid。也就是说存在最大甜蜜度为mid的组合。我们将问题一般化，如果遇到求最大的最小值问题(或最小的最大值问题)，我们可以采用二分法不断逼近那个最值。解法解法1：二分法class Solution {public:    int maximumTastiness(vector&lt;int&gt;&amp; price, int k) {        sort(price.begin(), price.end());        int l = 0, r = price.back() - price[0];        while(l &lt; r){            int mid = (l + r + 1) &gt;&gt; 1; //  这里加1是为了避免死循环                                        //  比如l=0,r=1,如果不加1，mid=0，接着l=mid。l会一直为0            if(check(mid, k, price)){                l = mid;            }else{                r = mid - 1;            }        }        return l;    }        bool check(int mid, int k, vector&lt;int&gt;&amp; price){        int ant = 0, pre = -mid;    //  pre初始值为-mid，这可以让第一个点进入if，即第一个点设为起点        for(auto &amp;e : price){            if(e - pre &gt;= mid){                ant++;                pre = e;            }        }        return ant &gt;= k;    }};解法2：C++11写法class Solution {public:    int maximumTastiness(vector&lt;int&gt;&amp; price, int k) {        sort(price.begin(), price.end());        int l = 0, r = price.back() - price[0];        auto check = [&amp;](int mid) -&gt; bool{            int ant = 0, pre = -mid;            for(auto &amp;e : price){                if(e - pre &gt;= mid){                    ant++;                    pre = e;                }            }            return ant &gt;= k;        };        while(l &lt; r){            int mid = (l + r + 1) &gt;&gt; 1;            if(check(mid, k, price)){                l = mid;            }else{                r = mid - 1;            }        }        return l;    }};Reference[1] 礼盒的最大甜蜜度 [2] 两球之间的磁力"
  },
  
  {
    "title": "刷题笔记 ——  去除重复字母",
    "url": "/posts/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/",
    "categories": "leetcode",
    "tags": "leetcode, Monotonic Stack",
    "date": "2023-05-30 19:41:00 +0800",
    





    
    "snippet": "单调栈  该题是单调栈的经典题目，我们讲解该题的思想，然后结合扩展到其他单调栈问题题目给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。例子示例1输入：s = \"bcabc\"输出：\"abc\"示例2输入：s = \"cbacdcbc\"输出：\"acdb\"条件  1 &lt;= s.length &lt;= 10...",
    "content": "单调栈  该题是单调栈的经典题目，我们讲解该题的思想，然后结合扩展到其他单调栈问题题目给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。例子示例1输入：s = \"bcabc\"输出：\"abc\"示例2输入：s = \"cbacdcbc\"输出：\"acdb\"条件  1 &lt;= s.length &lt;= 10^4  s 由小写英文字母组成难点分析该题需要保证每个字母只出现一次，我们很容易想到用一个哈希表来存储出现次数。但该题的难点在于，要求返回的结果的字典序最小。我们如何用O(n)时间来得到最小的字典序呢？我们以示例一“bcabc”为例：  第一个元素是b，由于初始字符串为空，所以我们插入进去   (b)  第二个元素是c，前面没有出现过c，所以我们也可以插入    (bc)  第三个元素是a，前面也没有出现a，但是我们发现如果要使字典序最小，a应该放在最前面。我们受到启发，如果当前元素a比已经插入的最后一个元素小，且已经插入的最后一个元素后面还会出现，那我们就舍弃掉已经插入的最后一个元素。所以b舍弃。同理a比c小，且c后面还会再次出现，所以c也舍弃。 (a)  第四个元素是b，它比已经插入的最后一个元素a大，且这是它最后一次出现，所以我们插入进去  第五个元素是c，同理它比已经插入的最后一个元素b大，且这是它最后一次出现，所以我们插入进去所以我们的操作是：与最后一个元素对比，如果小于，且最后一个元素还会再次出现，就将最后一个元素舍弃。栈可以帮助我们很好地与最后一个元素对比，同时可以方便地插入或舍弃最后一个元素。而哈希表可以帮助我们判断该元素是否已经插入，是否后面会再次出现该元素。所以此题我们使用栈和哈希表来解决。作为优化，我们可以将字符串看成一个栈，而字符串的find()方法可以很方便地帮助我们判断该元素是否已经插入过。所以解法2中我们使用字符串这种数据结构来缩减我们使用的空间。类似的题目还有移出K位数字，给定一串数字（例如”1432219”），要求移出其中任意k位，使得剩下的数字最小（即字典序最小）。根据上面的思想，只要我们将当前元素与保留的最后一位元素作比较，如果小于保留的最后一位元素，则舍弃最后一个元素。这样就能保证得到的字典序是最小的。类似的题目还有拼接最大数，这是在移出K位数字的基础上，增加一个数组。这时候我们需要第一个数组取保留i位，第二个数组保留k-i位，最后合并。保留i位的过程其实就是用到了上述单调栈的思想。解法解法1：单调栈class Solution {public:    string removeDuplicateLetters(string s) {        stack&lt;char&gt; st;        unordered_map&lt;char, int&gt; dict;        unordered_map&lt;char, int&gt; exist;        for (auto&amp; e : s) {            dict[e]++;        }        for (int i = 0; i &lt; s.size(); i++) {            //  如果没插入，且小于已经插入的最后一个元素，且后面还会再次出现最后一个元素，则舍弃最后一个元素            if (!exist.count(s[i])) {                while (!st.empty() &amp;&amp; dict[st.top()] != 0 &amp;&amp; s[i] &lt; st.top()) {                    exist.erase(st.top());                    st.pop();                }                st.push(s[i]);                exist[s[i]] = 1;            }            dict[s[i]]--;   //  使用次数减少        }        //  由于我们使用的是栈，所以最后还需要倒转过来        vector&lt;char&gt; ans;        while (!st.empty()) {            ans.emplace_back(st.top());            st.pop();        }        return string(ans.rbegin(), ans.rend());    }};解法2：解法1的优化class Solution {public:    string removeDuplicateLetters(string s) {        string ans;        unordered_map&lt;char, int&gt; dict;        for (auto&amp; e : s) {            dict[e]++;        }        for (int i = 0; i &lt; s.size(); i++) {            if(ans.find(s[i]) != ans.npos){ //  如果已经插入了，就跳过                dict[s[i]]--;                continue;            }            //  如果没插入，且小于已经插入的最后一个元素，且后面还会再次出现最后一个元素，则舍弃最后一个元素            while (!ans.empty() &amp;&amp; dict[ans.back()] &gt; 1 &amp;&amp; s[i] &lt; ans.back()) {                 dict[ans.back()]--; //  舍弃的同时，使用次数减少                ans.pop_back();            }            ans.push_back(s[i]);        }        return ans;    }};Reference[1] 去除重复字母 [2] 移掉 K 位数字 [3] 拼接最大数 [4] 一招吃遍力扣四道题"
  },
  
  {
    "title": "刷题笔记 ——  打家劫舍 III",
    "url": "/posts/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/",
    "categories": "leetcode",
    "tags": "leetcode, Dynamic Programming",
    "date": "2023-05-25 15:55:00 +0800",
    





    
    "snippet": "动态规划  该题是树形动态规划的一道经典题目，树形动态规划的解决方法通常找到对应的状态方程，采用递归解决。题目小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给...",
    "content": "动态规划  该题是树形动态规划的一道经典题目，树形动态规划的解决方法通常找到对应的状态方程，采用递归解决。题目小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。例子示例1输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7示例2输入: root = [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9条件  树的节点数在 [1, 10^4] 范围内  0 &lt;= Node.val &lt;= 10^4难点分析树形动态规划需要用递归去解决，这里我们设f(root)是root结点的最大收益。我们有两个选择，抢劫root结点的财产，或者不抢。当我们抢劫root时，root的左右节点我们不能抢劫，我们设g(root)表示不抢劫当前root结点的财产。我们可以得到方程：f(root) = g(root-&gt;left) + g(root-&gt;right) + root-&gt;val当我们不抢劫root时，我们当前的收益等于左、右子结点的最大收益之和，所以我们得到方程：f(root) = f(root-&gt;left) + f(root-&gt;right)最后我们取它们的最大值，所以状态方程为：f(root) = max{ g(root-&gt;left) + g(root-&gt;right) + root-&gt;val, f(root-&gt;left) + f(root-&gt;right) }至于g(root)，我们不抢当前root结点的财产，所以当前root的收益等于左、右子结点的最大收益之和，即：g(root) = f(root-&gt;left) + f(root-&gt;right)我们定义f(root)和g(root)函数，递归得到最后的答案。解法解法1：动态规划class Solution {public:    unordered_map&lt;TreeNode*, int&gt; dict; //  为了避免超时，这里用哈希表做记忆化    int rob(TreeNode* root) {        return f(root);    }    int f(TreeNode* root){        if(root == nullptr){            return 0;        }        if(!dict.count(root)){            int profit = max(f(root-&gt;left) + f(root-&gt;right), root-&gt;val + g(root-&gt;left) + g(root-&gt;right));            dict[root] = profit;        }        return dict[root];            }    int g(TreeNode* root){        if(root == nullptr){            return 0;        }        return f(root-&gt;left) + f(root-&gt;right);    }};解法2：另一种写法class Solution {public:    int rob(TreeNode* root) {        return dfs(root)[0];    }    vector&lt;int&gt; dfs(TreeNode* root){        vector&lt;int&gt; dp(2,0);    //  dp[0]表示f(root),dp[1]表示g(root)        if (root != nullptr) {            vector&lt;int&gt; dpL = dfs(root-&gt;left);            vector&lt;int&gt; dpR = dfs(root-&gt;right);            dp[1] = dpL[0] + dpR[0];            dp[0] = max(dp[1], dpL[1] + dpR[1] + root-&gt;val);        }        return dp;    }};Reference[1] 打家劫舍 III [1] House Robber III"
  },
  
  {
    "title": "刷题笔记 ——  乘积最大子数组",
    "url": "/posts/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/",
    "categories": "leetcode",
    "tags": "leetcode, Dynamic Programming",
    "date": "2023-05-22 11:16:00 +0800",
    





    
    "snippet": "动态规划  求子数组的最大乘积/最大和是一类经典的动态规划题目，只要找到状态方程就能顺利求解。题目给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个 32-位 整数。子数组 是数组的连续子序列。例子示例1输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 ...",
    "content": "动态规划  求子数组的最大乘积/最大和是一类经典的动态规划题目，只要找到状态方程就能顺利求解。题目给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个 32-位 整数。子数组 是数组的连续子序列。例子示例1输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例2输入: nums = [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。条件  1 &lt;= nums.length &lt;= 2 * 10^4  -10 &lt;= nums[i] &lt;= 10  nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数难点分析这类题的难点在于找到状态方程，使得在O(n)时间内得到最大和/最大积的子数组。我们先来看求子数组的最大和问题，当我们遍历到第i个元素，我们可以假设包含第i-1个元素的子数组的最大和已经求得，为dp[i - 1]。此时包含第i个元素的子数组的最大和有两种情况：  只含有第i个元素，即dp[i] = nums[i]  包含前面求得的子数组，即dp[i] = dp[i - 1] + nums[i]所以我们可以得到状态方程dp[i] = max(dp[i - 1] + nums[i], nums[i])。对于子数组的最大积问题，我们同样可以用状态方程dp[i] = max(dp[i - 1] * nums[i], nums[i])。但这里多了一种特殊情况：负数。前面得到的负数可能会在数组后面遇到另一个负数，从而负负得正。而我们每一步都取最大值，就会错过负数得正的情况。为了解决这个问题，我们维护一个最小值（如果存在负数，最小值一定会包含这个负数），当最小值遇到负数时，也可能反过来成为最大值。 所以我们可以修改状态方程:dpMax = max(dpMax[i - 1] * nums[i], nums[i], dpMin[i - 1] * nums[i])。最小值的维护同理，前面得到的最大值乘一个负数，也可能会成为最小值：dpMin = min(dpMin[i - 1] * nums[i], nums[i], dpMax[i - 1] * nums[i])。解法求最大子数组和class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int ans = nums[0];        int maxV = nums[0];        for(int i = 1 ; i &lt; nums.size() ; i++){            maxV = max(maxV + nums[i], nums[i]);            ans = max(maxV, ans);        }        return ans;    }};求最大子数组积class Solution {public:    int maxProduct(vector&lt;int&gt;&amp; nums) {        int maxV = nums[0];        int minV = nums[0];        int ans = nums[0];        for(int i = 1 ; i &lt; nums.size() ; i++){            int tmp = maxV;            maxV = max(max(tmp * nums[i], nums[i]), minV * nums[i]);            minV = min(min(minV * nums[i], nums[i]), tmp * nums[i]);            ans = max(ans, maxV);        }                return ans;    }};Reference[1] 乘积最大子数组 [2] 最大子数组和"
  },
  
  {
    "title": "刷题笔记 ——  数组中的第K个最大元素",
    "url": "/posts/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/",
    "categories": "leetcode",
    "tags": "leetcode, Quick Sort, Heap Sort",
    "date": "2023-05-22 11:16:00 +0800",
    





    
    "snippet": "快速排序/堆排序  这类题要求是返回排序后的前k个元素或第k个元素，而且往往对时间或空间有要求。如果对时间有要求，我们不能全部排序，我们可以选择快排或桶排序。如果对空间有要求，我们只能用堆排序。题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算...",
    "content": "快速排序/堆排序  这类题要求是返回排序后的前k个元素或第k个元素，而且往往对时间或空间有要求。如果对时间有要求，我们不能全部排序，我们可以选择快排或桶排序。如果对空间有要求，我们只能用堆排序。题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。例子示例1输入: [3,2,1,5,6,4], k = 2输出: 5示例2输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4条件  1 &lt;= k &lt;= nums.length &lt;= 10^5  -10^4 &lt;= nums[i] &lt;= 10^4难点分析我们先总结一下，这类题分为两种：  对时间有要求：  快排/堆排序/桶排序这使得我们不能完成整个数组的排序，而是只完成前几次排序。所以我们采用快排，当快排前几次排序到第k个位置，就返回。这样我们就不需要完成整个数组的排序了。我们同样可以用堆排序，堆排序的初始化时间为O(n)，每次取最值后调整堆的时间是O(logn)，最后总时间是O(n+klogn)。它同样不需要对整个数组进行排序，而是只排序前k次(取前k个最大的)。堆排序分为：(a)手撕堆排序代码；(b)利用优先队列实现堆排序(底层原理也是堆)。这里我们还可以用桶排序，将元素放入对应的桶中，然后从最大/最小的桶依次得到前k个元素。桶我们可以用数组或哈希表来实现。  对空间有要求：  堆排序(堆大小为k)如果内存不能存放整个数组，那我们只能创建一个大小为k的堆，然后将数组中的元素依次进堆和出堆，最后堆剩余的元素是最大/最小的k个元素，最后处理得到最终结果。时间复杂度O(nlogk)，空间复杂度O(k)。解法解法1：快速排序class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        const int len = nums.size();        int left = 0, right = len - 1;        //  如果数组是有序的，快排的效率会退化为O(n^2)。所以我们随机选取当前排序的元素        srand(time(0)); //  取随机数种子        while(left &lt;= right){            //  获取本轮正确排序的元素的位置            int index = partiton(nums, left, right);            if(index == len - k){                return nums[index];            }else if(index &gt; len - k){                right = index - 1;            }else{                left = index + 1;            }        }        return -1;  //  查询失败    }    int partiton(vector&lt;int&gt;&amp; nums, int left, int right){        int randindex = rand()%(right - left + 1) + left;   //  随机选取一个元素        //  这里我们采用双指针的做法，ti保存大于tn(参照值)的位置        swap(nums[right], nums[randindex]);        int tn = nums[right];        int ti = left;         for(int i = left ; i &lt; right ; i++){            if(nums[i] &lt; tn){                swap(nums[i], nums[ti]);                ti++;            }        }        swap(nums[ti], nums[right]);        return ti;    }};解法2：手撕堆排序class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int len = nums.size();        //  i的左叶子节点：2i+1；        //  i的右叶子节点：2i+2；        //  i的父母节点：（i-1）/2        //  所以这里才最后一个非叶子结点开始调整堆        for(int i = (len - 2) / 2 ; i &gt;= 0 ; i--){            adjust(nums, len, i);        }        //  求第k个元素就是出k-1次堆        for(int i = 0 ; i &lt; k - 1 ; i++){            swap(nums[0], nums[len - 1]);            len--;            adjust(nums, len, 0);        }        //  最后返回堆顶元素        return nums[0];    }    void adjust(vector&lt;int&gt;&amp; nums, int len, int idx){        //  调整堆，将堆顶元素与左、右叶子结点的最大值交换，然后迭代调整左/右叶子结点        while(idx &lt; len){            int left = 2 * idx + 1;            int right = 2* idx + 2;            int ti = idx;            if(left &lt; len &amp;&amp; nums[left] &gt; nums[ti]){                ti = left;            }            if(right &lt; len &amp;&amp; nums[right] &gt; nums[ti]){                ti = right;            }            if(ti != idx){                swap(nums[ti], nums[idx]);                idx = ti;            }else{                break;  //  左右叶子结点不存在，结束调整            }        }    }};解法3：优先队列实现堆排序class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        priority_queue&lt;int&gt; qu; //  创建优先队列        for(auto &amp;e : nums){            qu.push(e);        }        //  退出前k-1个元素        int count = 1;        while(!qu.empty() &amp;&amp; count &lt; k){            qu.pop();            count++;        }        return qu.top();    //  返回第k个元素    }};解法4：堆大小为k的堆排序class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        //  前k个元素个元素建立最小堆        for(int i = (k - 1) / 2 ; i &gt;= 0 ; i--){            adjust(nums, k, i);        }                for(int i = k ; i &lt; nums.size() ; i++){            //  如果当前元素大于堆顶元素，则入堆，并进行调整            if(nums[i] &gt; nums[0]){                swap(nums[0], nums[i]);                adjust(nums, k, 0);            }                    }        //  堆顶元素就是第k大的元素        return nums[0];    }    void adjust(vector&lt;int&gt;&amp; nums, int len, int idx){        while(idx &lt; len){            int left = 2 * idx + 1;            int right = 2* idx + 2;            int ti = idx;            if(left &lt; len &amp;&amp; nums[left] &lt; nums[ti]){                ti = left;            }            if(right &lt; len &amp;&amp; nums[right] &lt; nums[ti]){                ti = right;            }            if(ti != idx){                swap(nums[ti], nums[idx]);                idx = ti;            }else{                break;            }        }    }};解法5：桶排序(数组)/* 这里题目要求是求前k个频率最大的元素例如：输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] */class Solution {public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {        //  先用哈希表计算频率        unordered_map&lt;int, int&gt; dict;        int _max = 1;        for(auto &amp;e : nums){            dict[e]++;            _max = max(dict[e], _max);                    }        //  用数组创建桶        vector&lt;vector&lt;int&gt;&gt; bucket(_max + 1, vector&lt;int&gt;());        //  将元素放到不同的桶中        for(auto &amp;e : dict){            bucket[e.second].emplace_back(e.first);        }                //  从最大的桶开始取元素        int count = 0;        vector&lt;int&gt; res;        for(int i = bucket.size() - 1 ; i &gt;= 0 &amp;&amp; count &lt; k ; i--){            for(auto &amp;e : bucket[i]){                if(count &lt; k){                    count++;                    res.emplace_back(e);                }            }        }        return res;    }};解法6：桶排序(哈希表)/* 这里题目要求是求前k个频率最大的元素例如：输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] */class Solution {public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {        //  先用哈希表计算频率        unordered_map&lt;int, int&gt; dict;        for(auto &amp;e : nums){            if(dict.count(e)){                dict[e]++;            }else{                dict[e] = 1;            }        }        //  用哈希表创建桶，并将元素插入桶中        map&lt;int, vector&lt;int&gt;&gt; bucket;        for(auto &amp;e : dict){            bucket[e.second].emplace_back(e.first);        }        //  由于map是有序的，所以才频率最大的桶开始取数据        vector&lt;int&gt; res;        int count = 0;        for (auto it = bucket.rbegin(); it != bucket.rend(); it++){            for(auto &amp;e : it-&gt;second){                if(count &gt;= k){                    break;                }                count++;                res.emplace_back(e);            }            if(count &gt;= k){                break;            }        }        return res;    }};Reference[1]  数组中的第K个最大元素 [2] 前 K 个高频元素[3] 数据流中的第 K 大元素[4] 前K个高频单词 [5] 最接近原点的 K 个点[6] 最小K个数"
  },
  
  {
    "title": "刷题笔记 —— 单词拆分",
    "url": "/posts/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/",
    "categories": "leetcode",
    "tags": "leetcode, Dynamic Programming, Backtrack, Trie Tree",
    "date": "2023-05-17 20:23:00 +0800",
    





    
    "snippet": "动态规划/回溯/字典树  该题属于完全背包问题，可以采用回溯和动态规划两种方法解决，回溯法递归了所有的可能性，运行时间更慢，需要剪枝才能避免超时。题目给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。例子示例1输入: s = \"leetcode\", word...",
    "content": "动态规划/回溯/字典树  该题属于完全背包问题，可以采用回溯和动态规划两种方法解决，回溯法递归了所有的可能性，运行时间更慢，需要剪枝才能避免超时。题目给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。例子示例1输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]输出: true解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。示例2输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]输出: true解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。     注意，你可以重复使用字典中的单词。示例3输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]输出: false条件  1 &lt;= s.length &lt;= 300  1 &lt;= wordDict.length &lt;= 1000  1 &lt;= wordDict[i].length &lt;= 20  s 和 wordDict[i] 仅有小写英文字母组成  wordDict 中的所有字符串 互不相同难点分析本题难点在于判断前缀。比如单词表[a,abc,b,cd]，对于字符串acd，对应单词是a和cd。对于字符串abccd，对应单词是abc和cd。这两者第一个对应单词都是a开头，选择哪一个前缀是该题的难点所在。我们提出三种解决方法：  哈希表+动态规划我们用哈希表存储所有的单词，然后用一个数组表示字符串对应的前缀。第i个数组如果为true，说明字符串第i个位置之前的所有字符都存在于哈希表中。接下来我们依次判断str[i,j)(i &lt; j &lt; len(str))是否存在哈希表中，如果存在则继续判断下一个位置的字符串，直到到达字符串末尾或哈希表未命中。  哈希表+回溯第二种方法是用回溯来代替动态规划的过程，我们依次判断s[i, j)是否能与哈希表匹配，如果能，我们递归判断s[:i)。递归过程中，我们通过dfs() || res的方式保存中间结果，只有整个字符串都匹配了（即当前字符串为空串），我们才返回true，然后将结果一层一层往上传递。回溯法递归了所有的可能性，所以很可能超时，为了避免超时，我们增加了一个备忘录。备忘录数组用于基于子字符串s*是否可以拆分，免去重复性的递归计算。  字典树+回溯第三种方法是在第二种方法的基础上，用字典树来代替哈希表，相比哈希表更节省空间。回溯的思想和第二种方法一致，先判断子串是否能被字典树匹配，如果不能匹配，返回false。如果可以匹配，则继续判断后面的部分。解法解法1：哈希表+动态规划class Solution {public:     bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        //  用哈希表存储单词        unordered_map&lt;string, int&gt; dict;        for(auto &amp;e :wordDict){            dict[e] = 1;        }        vector&lt;bool&gt; dp(s.size() + 1, false);        dp[0] = true;        for(int i = 0 ; i &lt; s.size() ; i++){            for(int j = i + 1 ; j &lt; s.size() + 1 ; j++){                //  第i个字符之前都匹配且s[i,j)存在哈希表中                if(dp[i] &amp;&amp; dict.find(s.substr(i, j - i)) != dict.end()){                    dp[j] = true;   //  标记第j个字符之前都匹配                }            }        }        return dp.back();   //  返回最后一个字符的匹配情况    }};解法2：哈希表+回溯class Solution {public:     unordered_map&lt;string, int&gt; memo;    //  直接回溯会超时，所以增加一个备忘录    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        unordered_map&lt;string, int&gt; dict;        for(auto &amp;e :wordDict){            dict[e] = 1;        }        return dfs(s, dict);    }    bool dfs(string s, unordered_map&lt;string, int&gt;&amp; dict){        if(s.size() == 0){            return true;        }        if(memo[s] == -1) return false;        bool res = false;        for(int j = s.size() - 1 ; j &gt;= 0 ; j--){            if(dict.count(s.substr(j, s.size() - j))){                res = dfs(s.substr(0, j), dict) || res;                if(res) return true;                memo[s] = -1;            }        }               return res;    }};解法3：字典树+回溯class Solution {public:     //  字典树结构体    struct Trie{        unordered_map&lt;char, Trie*&gt; children;        bool isEnd = false;    };    unordered_map&lt;string, int&gt; memo;    //  备忘录数组，避免超时    //  字典树插入    void insert(Trie *root, string &amp;str){        Trie *p = root;        for(auto &amp;e : str){            if(!p-&gt;children.count(e)){                p-&gt;children[e] = new Trie();            }            p = p-&gt;children[e];        }        p-&gt;isEnd = true;    }    //  字典树查询    bool search(string s, Trie *root){        if(s.size() == 0){            return true;        }        if(memo[s] == -1){            return false;        }        Trie *p = root;        bool res = false;        for(int i = 0 ; i &lt; s.size() ; i++){            if(!p-&gt;children.count(s[i])){   //  字典不匹配，返回false，并标记该子串无法匹配                memo[s] = -1;                return false;            }            p = p-&gt;children[s[i]];  //  因为插入时，是在下一个结点设置isEnd，所以先迭代到子结点            if(p-&gt;isEnd == true){   //  如果isEnd为真，说明该词在字典中，判断字符串之后的部分                res = search(s.substr(i + 1), root) || res;            }            if(res){    //  及时跳出循环                return true;            }        }        return res;    }    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        Trie *root = new Trie();        for(auto &amp;e :wordDict){            insert(root, e);        }        return search(s, root);            }    };Reference[1] 计数质数"
  },
  
  {
    "title": "刷题笔记 —— 计数质数",
    "url": "/posts/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/",
    "categories": "leetcode",
    "tags": "leetcode, Number Theory",
    "date": "2023-05-17 16:56:00 +0800",
    





    
    "snippet": "数论  该题比较简单，要求找出n以内的所有质数，但是枚举的解法会导致超时，所以需要运用数论知识，找到规律进行求解题目给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。例子示例1输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。示例2输入：n = 0输出：0示例3输入：n = 1输出：0条件  0 &lt;= n &lt;= 5 * ...",
    "content": "数论  该题比较简单，要求找出n以内的所有质数，但是枚举的解法会导致超时，所以需要运用数论知识，找到规律进行求解题目给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。例子示例1输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。示例2输入：n = 0输出：0示例3输入：n = 1输出：0条件  0 &lt;= n &lt;= 5 * 10^6难点分析本题难点在于通过数学知识找到快速求解的方法。      最简单的解法是枚举暴力法，为了让暴力法能通过测试用例，我们先余2或3。        第二种解法是埃氏筛，由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。核心思想是如果x是质数，那么x的倍数2x,3x,…一定不是质数。所以我们可以用一个数组表示对应下标的数是不是质数，如果是质数则计数加一，然后将该数的倍数全部标记为非质数。这种做法的正确性是，因为一个质数只能被1或它本身整除，所以质数不会被标记。 当然这里还可以继续优化，对于一个质数x，其倍数2x,3x会被2~(x-1)标记过，所以我们可以从x*x开始标记。        第三种解法是线性筛，在埃氏筛中，例如12会被2的倍数标记，也会被3的倍数标记，重复了多次。而线性筛的核心思想是让每一个数只遍历一次。 由于每一个合数都可以以唯一形式被写成质数的乘积，所以遇到质数，我们存放到数组中记录下来，遇到合数我们可以看成合数*质数=质数*质数*…*质数的形式。  所以质数相乘一定可以标记所以的合数。现在的问题是如何保证只遍历一次元素。所以每个合数都可以唯一地拆分为不同的质数组合，所以我们每遇到一个数，按顺序乘以质数数组中的元素。如果该合数有相同的质数（我们可以通过取余来判断），不同顺序的组合可能得到相同的合数，比如2*6=3*4=12。所以如果遇到相同的质数，我们停止相乘。比如4*2时，由于4 % 2 = 0，有相同的质数，所以我们停止相乘。后面的数4*3，我们可以通过6*2得到。即质数A、B(B&gt;A)，合数A*A*B我们不需要遍历，因为后面一定会由A*B*A再次得到。解法解法1：暴力法class Solution {public:    int countPrimes(int n) {        int ans = 0;        for(int i = 2 ; i &lt; n ; i++){            if(isPrime(i)){                ans++;            }        }        return ans;    }    bool isPrime(int n) {        if (n &lt;= 3) {            return n &gt; 1;        } else if (n % 2 == 0 || n % 3 == 0) {  //  为了避免超时，我们先余2或3            return false;        } else {            for (int i = 5; i * i &lt;= n; i += 2) {                if (n % i == 0) {                    return false;                }            }            return true;        }    }};解法2：埃氏筛class Solution {public:    int countPrimes(int n) {        int ans = 0;        vector&lt;int&gt; isPrime(n, 0);        for(int i = 2 ; i &lt; n ; i++){            if(isPrime[i] == 0){                ans++;                if ((long long)i * i &lt; n) { //  防止最大的测试用例溢出                    for(int j = i * i ; j &lt; n ; j += i){                        isPrime[j] = 1;                    }                }            }        }        return ans;    }};解法3：线性筛class Solution {public:    int countPrimes(int n) {        int ans = 0;        vector&lt;int&gt; prime;        vector&lt;int&gt; isPrime(n, 0);        for(int i = 2 ; i &lt; n ; i++){            if(isPrime[i] == 0){                prime.emplace_back(i);                ans++;            }            for(int j = 0, t ; j &lt; prime.size() &amp;&amp; (t = prime[j] * i) &lt; n ; j++){                isPrime[t] = 1;                if(i % prime[j] == 0){                    break;                }            }        }        return ans;    }};Reference[1] 计数质数"
  },
  
  {
    "title": "刷题笔记 —— 两个非重叠子数组的最大和",
    "url": "/posts/%E4%B8%A4%E4%B8%AA%E9%9D%9E%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/",
    "categories": "leetcode",
    "tags": "leetcode, Sliding Window, Dynamic Programming",
    "date": "2023-05-16 10:49:00 +0800",
    





    
    "snippet": "滑动窗口/动态规划  该题是找出两个不重叠的子数组，计算两个子数组的最大元素和。该题的难点在于需要同时控制两个子数组移动，而且两个子数组的前后顺序会影响最终结果。题目给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。长度为 firstLen 的子数组可以出...",
    "content": "滑动窗口/动态规划  该题是找出两个不重叠的子数组，计算两个子数组的最大元素和。该题的难点在于需要同时控制两个子数组移动，而且两个子数组的前后顺序会影响最终结果。题目给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。子数组是数组的一个 连续 部分。例子示例1输入：nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2输出：20解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。示例2输入：nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2输出：29解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。示例3输入：nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3输出：31解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。条件  1 &lt;= firstLen, secondLen &lt;= 1000  2 &lt;= firstLen + secondLen &lt;= 1000  firstLen + secondLen &lt;= nums.length &lt;= 1000  0 &lt;= nums[i] &lt;= 1000难点分析本题难点在于我们有两个同时移动的数组，同时考虑两个数组的最大值，而且在O(n)时间内实现，是比较困难的。而且由于firstLen和secondLen大小可能不同，所以如果我们先找出secondLen的最大子数组，再找出firstLen的最大子数组，最后的元素和可能并不是最大的。例如示例1，如果我们先secondLen的最大子数组，我们会找到[9, 4]，然后我们找firstLen的最大子数组，我们会找到[6]，最后的元素和是19，但答案是20。所以，我们需要分成两种情况寻找最大子数组。下面是使用滑动窗口+动态规划的解法： 既然有两个同时移动的数组，我们可以固定其中一个，改变另一个。如下图所示：我们先假设最终答案是first段在前，second段在后。我们记录first段的最大长度，每次移动的时候，我们都判断最大值。这样我们可以认为左边部分的子数组始终是最大的，近似认为它是一个固定值（每次都是最大值）。然后我们滑动右边的second段，每次滑动都将second段的元素和加上这个’固定值’，然后进行最大值判断。我们只看second段，可以发现second段遍历了所有的情况，所以一定能得到两个子数组元素和的最大值。接着只要我们重复同样的操作，查找second段在前，first段在后的最大值情况，就能得到答案。这种做法的时间复杂度是O(n)，空间复杂度是O(1)。解法解法1：滑动窗口+动态规划class Solution {public:    int maxSumTwoNoOverlap(vector&lt;int&gt; &amp;nums, int firstLen, int secondLen) {        return max(trace(nums, firstLen, secondLen), trace(nums, secondLen, firstLen));    }    int trace(vector&lt;int&gt; &amp;nums, int firstLen, int secondLen){        int v1 = 0, v2 = 0;        //  计算first段元素和        for(int i = 0 ; i &lt; firstLen ; i++){            v1 += nums[i];        }        //  计算second段元素和        for(int i = firstLen ; i &lt; firstLen + secondLen ; i++){            v2 += nums[i];        }        int maxAns = v1 + v2;        int maxFirst = v1;        for(int i = firstLen + secondLen ; i &lt; nums.size() ; i++){            //  更新first段，并维持first段的最大值            v1 = v1 + nums[i - secondLen] - nums[i - firstLen - secondLen];            maxFirst = max(maxFirst, v1);            //  更新second段，并维持first段+second段的最大值            v2 = v2 + nums[i] - nums[i - secondLen];            maxAns = max(maxAns, maxFirst + v2);        }        return maxAns;    }};Reference[1] 两个非重叠子数组的最大和"
  },
  
  {
    "title": "刷题笔记 —— 存在寻找重复数 III",
    "url": "/posts/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A03/",
    "categories": "leetcode",
    "tags": "leetcode, Red-black Tree, Bucket Sorting",
    "date": "2023-05-12 15:15:00 +0800",
    





    
    "snippet": "红黑树/桶排序  该题是在一个数组中查找一对元素，难点在于(1)元素保持前后顺序，所以我们不能使用排序；(2)要求前后元素的差值在某个范围内，所以我们需要一一进行比较，需要想办法将时间复杂度降低到O(logn)或O(n)题目给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同...",
    "content": "红黑树/桶排序  该题是在一个数组中查找一对元素，难点在于(1)元素保持前后顺序，所以我们不能使用排序；(2)要求前后元素的差值在某个范围内，所以我们需要一一进行比较，需要想办法将时间复杂度降低到O(logn)或O(n)题目给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。如果存在则返回 true，不存在返回 false。例子示例1输入：nums = [1,2,3,1], k = 3, t = 0输出：true示例2输入：nums = [1,0,1,1], k = 1, t = 2输出：true示例3输入：nums = [1,5,9,1,5,9], k = 2, t = 3输出：false条件  0 &lt;= nums.length &lt;= 2 * 10^4  -2^31 &lt;= nums[i] &lt;= 2Z^31 - 1  0 &lt;= k &lt;= 10^4  0 &lt;= t &lt;= 2^31 - 1难点分析本题要求在某个范围(abs(i - j) &lt;= k)的元素值存在差值在某个范围(abs(nums[i] - nums[j]) &lt;= t)的一对元素。对于前一个条件，我们一个朴素的想法是通过一个滑动窗口来实现。滑动窗口有k个元素，正好保证了条件abs(i - j) &lt;= k，当我们向后滑动的时候，不断推出最早插入的元素，然后插入新的元素。  红黑树现在的问题是第二个条件，怎么在一组值中找到差值小于t的元素。如果我们对这组值一一比较，每次滑动都需要比较k次，时间复杂度为O(kn)，程序必然会超时。如果滑动窗口是有序的，那我们可以在O(logk)的时间内判断是否满足要求。而保持滑动窗口有序的数据结构，可以使用红黑树，而且树在滑动窗口的增加和删除时也是O(logk)的时间复杂度。这就是我们的解法一，用C++中的multiset来构成滑动窗口。然后我们需要找到当前元素nums[i]最接近的两个元素(一个大于nums[i]，一个小于nums[i])，判断这两个元素和nums[i]的差值是否小于等于t。通过lower_bound函数我们可以得到最接近的大于等于nums[i]的元素，但是multiset中没有提供搜索最接近的小于nums[i]的元素的函数。所以这里我们转换一下：|nums[i] - nums[j]| &lt;= t         //  这里nums[i]和t是已知的，所以拆开绝对值==&gt; -t &lt;= nums[i] - nums[j] &lt;= t==&gt; nums[j] &lt;= nums[i] + t 或者 nums[j] &gt;= nums[i] - t我们画出数轴，如图所示，我们要求的是阴影部分。所以我们调用lower_bound方法，找出第一个大于等于nums[i] - t 的元素，然后判断该元素是否满足小于等于nums[i] + t。如果满足，就返回true，否则返回false。  桶排序如果想用更短的时间，我们想到了哈希表来作为滑动窗口，但是哈希表没办法定位到nums[i]最接近的元素。这时候我们受到桶排序的启发：如果值跨度小于t的放在一个桶里，那桶里有两个元素，就必然满足条件。如果桶里只有一个元素，我们可以与相邻桶的元素作比较。相邻桶也就是我们需要找的最接近的元素，只不过不需要一个一个元素去遍历，我们将哈希表存放的元素的值跨度变大，就可以只需要查询一个元素就可以了。这里有个小细节，我们用nums[i] / valueDiff来作为桶编号（即哈希地址），存在下述两种特殊情况：  valueDiff为0，此时除以0会报异常。所以我们将公式改为nums[i] / (valueDiff + 1)。这里加1可行是因为题目中&lt;= t，比如valueDiff为5，nums[i]为0，那[0,5]都符合条件，包括5。  nums[i]为负数。假如valueDiff为5，那元素[0,5]应该扔到一个桶，[6,11]应该扔到一个桶，以此类推。可以看出一个桶内的元素差值必然小于等于t。但是nums[i]为负数的话，会导致元素[0,5]扔到一个桶，元素[-5,-1]也被扔到同一个桶，很明显，5 - (-5) &gt; valueDiff。所以对于负数的情况，我们将公式改为(nums[i] / valueDiff + 1) - 1。解法解法1：红黑树class Solution {public:    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int indexDiff, int valueDiff) {        if(indexDiff &lt; 0 || valueDiff &lt; 0) return false;                multiset&lt;int&gt;  h;        for(int i = 0 ; i &lt; nums.size() ; i++){            auto lower = h.lower_bound(nums[i] - valueDiff);            if(lower != h.end() &amp;&amp; (*lower) - nums[i] &lt;= valueDiff){                return true;            }            h.insert(nums[i]);            if(i &gt;= indexDiff){                h.erase(nums[i - indexDiff]);            }        }        return false;    }};解法2：桶排序class Solution {public:    int size;    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int indexDiff, int valueDiff) {        unordered_map&lt;int, int&gt; bucket;        size = valueDiff + 1;        for(int i = 0 ; i &lt; nums.size() ; i++){            int index = getIndex(nums[i], valueDiff);            if(bucket.find(index) != bucket.end()){                return true;            }            int uIndex = index + 1, lIndex = index - 1;            if(bucket.find(uIndex) != bucket.end() &amp;&amp; abs(bucket[uIndex] - nums[i]) &lt;= valueDiff){                return true;            }            if(bucket.find(lIndex) != bucket.end() &amp;&amp; abs(bucket[lIndex] - nums[i]) &lt;= valueDiff){                return true;            }            bucket[index] = nums[i];            if(i &gt;= indexDiff){                bucket.erase(getIndex(nums[i - indexDiff], valueDiff));            }        }        return false;    }    int getIndex(int u, int valueDiff){        return u &gt;= 0 ? u / size : (u / size) - 1;    }};Reference[1] 存在重复元素 III"
  },
  
  {
    "title": "刷题笔记 —— 寻找重复数",
    "url": "/posts/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/",
    "categories": "leetcode",
    "tags": "leetcode, Fast Slow Pointer, Bitwise Operation, Binary Search",
    "date": "2023-05-11 14:57:00 +0800",
    





    
    "snippet": "快慢指针/位运算/二分查找  该题是在一个数组中查找重复元素，难点在于不能修改数组，且只能用O(1)的额外空间题目给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。例...",
    "content": "快慢指针/位运算/二分查找  该题是在一个数组中查找重复元素，难点在于不能修改数组，且只能用O(1)的额外空间题目给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。例子示例1输入：nums = [1,3,4,2,2]输出：2示例2输入：nums = [3,1,3,4,2]输出：3条件  1 &lt;= n &lt;= 10^5  nums.length == n + 1  1 &lt;= nums[i] &lt;= n  nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次难点分析该题先是想到用哈希表来存储次数，但是题目要求O(1)的额外空间，所以该方法不行。第二个想到的思路是可以排序或者原地哈希，但是题目要求不能改变数组原顺序，该方法也不可行。这就增加了本题的难度。本题有三种解法，分别为快慢指针、位运算、二分查找。下面分别讲解这三种解法的思路：  快慢指针对于数组中的一组数[1,3,4,2,2]，如果存在循环，它的映射会是这个样子：下标 -&gt; 值  0   -&gt;  1  1   -&gt;  3  2   -&gt;  4  3   -&gt;  2  4   -&gt;  2  如果我们将下标到值的映射视为一个链表，则该链表为：0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 2 -&gt; 4 -&gt; ...我们发现如果存在两个以上的重复元素，则对应链表中的某个结点会有两个以上的指针指向它，所以该链表会形成一个环。接下来该问题可以等价于找环入口处的问题，通过快慢指针来解决。如图所示：查找环入口处通过快指针和慢指针同时遍历，当他们相遇时，根据条件有：慢指针     快指针2(a + b) = a + b + nr-&gt;a = nr - b-&gt;a = (n - 1)*r - (r - b)此时我们另一个指针在相遇处，另一个指针在起点，然后同样速度进行遍历。起点处的指针走到入口处的步数是a，刚好是我们所求的答案。而相遇处的指针根据上述公式，先是走了(r - b)步回到入口处，然后不断循环一圈(对应(n-1)*r)，最后两个指针会在入口处相遇。  位运算根据题目，n + 1个元素的数组，元素值范围为[1, n]。我们先假设其中一个元素出现了2次，其他元素都只出现1次。此时我们统计每一位中1的个数，元素[1, n]中第i位为1的个数假设为y，那n + 1个元素第i位为1的个数假设为x，那x一直大于y，因为重复的那个元素提供了多一个1。所以我们统计每一位1的个数，找出所有x大于y的的位，就能还原出重复的那个数字。如果其中一个元素出现了2次以上，说明在统计位为1的过程中，该元素代替了其他数。此时：  如果被代替的数第i位为1，且target第i位为1，则x不变，最终满足x &gt; y；  如果被代替的数第i位为0，且target第i位为1，则x变大，最终满足x &gt; y；  如果被代替的数第i位为1，且target第i位为0，则x变小，最终满足x &lt;= y；  如果被代替的数第i位为0，且target第i位为0，则x不变，最终满足x &lt;= y；我们可以看到如果target第i位为1，那x大于y依然满足，我们依然可以通过统计x大于y的位来还原重复的数字。当target第i位为0的情况不是我们所关心的，所以该算法的正确性仍然成立。  二分查找可能你比较疑惑，该数组无序，为什么能用二分查找。根据题目要求，数组元素都在 [1, n] 范围内，那么我们可以对[1, n]这个数组进行二分查找（不是原数组）。当我们计算mid时，对原数组小于等于mid的值进行统计，原数组大小为n + 1，所以肯定有一个元素的个数大于2。如果元素都不重复，小于等于mid的元素个数应该刚好有mid个。而重复情况下，我们统计的元素个数大于mid个，就说明重复元素的范围在[low, mid]之中。我们通过二分查找不断逼近，就能找到答案。解法解法1：快慢指针class Solution {public:    int findDuplicate(vector&lt;int&gt;&amp; nums) {        int slow = nums[0], fast = nums[nums[0]];        while(slow != fast){            slow = nums[slow];            fast = nums[nums[fast]];        }        int pre1 = 0, pre2 = slow;        while(pre1 !=  pre2){            pre1 = nums[pre1];            pre2 = nums[pre2];        }        return pre1;    }};解法2：位运算class Solution {public:    int findDuplicate(vector&lt;int&gt;&amp; nums) {        int n = nums.size(), ans = 0;        //  n最大值为10^5次方，所以我们只看前17位        for(int i = 0 ; i &lt;= 17 ; i++){            int x = 0, y = 0;            for(int j = 0 ; j &lt; n ; j++){                if(nums[j] &amp; (1 &lt;&lt; i)){ //  计算nums[j]的第i位为1的个数                    x++;                }                if(j &amp; (1 &lt;&lt; i)){ //  计算j的第i位为1的个数                    y++;                }            }            if(x &gt; y){                ans |= (1 &lt;&lt; i);            }        }        return ans;    }};解法3：二分查找class Solution {public:    int findDuplicate(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int l = 1, h = n, ans = 0;        while(l &lt;= h){            int cnt = 0;            int mid = (l + h) &gt;&gt; 1;            for(int i = 0 ; i &lt; nums.size() ; i++){                if(nums[i] &lt;= mid){                    cnt++;                }            }            if(cnt &lt;= mid){                l = mid + 1;            }else{                h = mid - 1;                ans = mid;            }        }        return ans;    }};Reference[1] 寻找重复数"
  },
  
  {
    "title": "读书笔记 —— 多进程编程_5",
    "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B_5/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Multiprocess",
    "date": "2023-05-10 16:57:00 +0800",
    





    
    "snippet": "消息队列  本节介绍了3种System V IPC进程间的通信方式的最后一种——消息队列。消息队列相比前面两种通信方式，可以指定消息的类型，读取特定类型的消息，而前两种通信方式都是按先进先出顺序的。消息队列通过类似的msgget调用来创建和打开消息队列，然后通过msgsnd和msgrcv调用来发送和读取消息，最后通过msgctl调用直接操作消息队列相关的内核数据结构。此外进程间的通信还可以采...",
    "content": "消息队列  本节介绍了3种System V IPC进程间的通信方式的最后一种——消息队列。消息队列相比前面两种通信方式，可以指定消息的类型，读取特定类型的消息，而前两种通信方式都是按先进先出顺序的。消息队列通过类似的msgget调用来创建和打开消息队列，然后通过msgsnd和msgrcv调用来发送和读取消息，最后通过msgctl调用直接操作消息队列相关的内核数据结构。此外进程间的通信还可以采用UNIX域的socket，我们以子进程向父进程传递文件描述符为例，讲解了UNIX域的socket的运用。消息队列消息队列是两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有特定的类型，接收方可以根据类型有选择地来接收数据，而管道和共享内存必须以先进先出的方式接收数据。Linux中，消息队列的API定义在sys/msg.h头文件中，包括4个系统调用：msgget、msgsnd、msgrcv和msgctl。下面我们依次讨论。msgget下面是msgget的系统调用，功能是创建一个新的消息队列或获取一个已经存在的消息队列，其函数原型如下：#include &lt;sys/msg.h&gt;int msgget(key_t key, int msgflg);参数和返回值：  key: 键值，用来标识一个全局唯一的消息队列  msgflg: 一组标志，低位的9 bit表示消息队列的权限，其格式和含义与open系统调用的mode参数相同  返回值：成功返回一个正整数，它是消息队列的标识符。失败返回-1，并设置errno当我们调用msgget创建消息队列后，相关联的内核数据结构msqid_ds将被创建并初始化，msqid_ds结构体的定义如下：struct msqid_ds{    struct ipc_perm msg_perm;   //  消息队列的操作权限    time_t msg_stime;           //  最后一次调用msgsnd的时间    time_t msg_rtime;           //  最后一次调用msgrcv的时间    time_t msg_ctime;           //  最后一次被修改的时间    unsigned long __msg_cbytes; //  消息队列中已有的字节数    msgqnum_t msg_qnum;         //  消息队列中已有的消息数    msglen_t msg_qbytes;        //  消息队列允许的最大字节数    pid_t msg_lspid;            //  最后执行msgsnd的进程的PID    pid_t msg_lrpid;            //  最后执行msgrcv的进程的PID};msgsnd下面是msgsnd的系统调用，功能是将一条消息添加到消息队列中，其函数原型如下：#include &lt;sys/msg.h&gt;int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);参数和返回值：  msqid: 由msgget调用返回的消息队列标识符  msg_ptr: 指向一个准备发送的消息  msg_sz: 消息数据部分(mtext)的长度，这个长度可以为0，表示没有消息数据  msgflg: msgflg参数用来控制msgsnd的行为，通常仅支持IPC_NOWAIT标记，表示以非阻塞的方式发送数据。默认情况下，如果发送消息时，消息队列满了，msgsnd则会阻塞。若指定了IPC_NOWAIT标记，消息队列满了则会立即返回，并设置errno为EAGAIN  返回值: 成功返回0，失败返回-1，并设置errno。shmdt成功返回0，失败返回-1，并设置errnomsg_ptr参数指向的消息，其类型必须为msgbuf结构体，其定义如下：struct msgbuf{  long mtype;       //  消息类型  char mtext[512];  //  消息数据};其中：  mtype指定消息的类型，它必须是一个正整数  mtext是消息数据如果msgsnd处于阻塞状态，则它可能被以下两种异常情况中断：  如果消息队列被移除，则msgsnd调用将立即返回，并设置errno为EIDRM  如果程序接收到信号，则msgsnd调用将立即返回，并设置errno为EINTRmsgsnd执行成功后会将消息添加到消息队列中，同时它还会修改对应的内核数据结构，具体包括：  将msg_qnum加1  将msg_lspid设置为调用进程的PID  将msg_stime设置为当前时间msgrcv下面是msgrcv的系统调用，功能是从消息队列中获取一条消息，其函数原型如下：#include &lt;sys/msg.h&gt;int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, int msgtype, int msgflg);参数和返回值：  msqid: 由msgget调用返回的消息队列标识符  msg_ptr: 用于存储接收的消息  msg_sz: 接收的消息的数据部分(mtext)的长度  msgtype: 指定接收何种类型的消息          msgtype等于0: 读取消息队列中的第一个消息      msgtype大于0: 读取消息队列中第一个类型为msgtype的消息      msgtype小于0: 读取消息队列中第一个类型值比msgtype的绝对值小的消息        msgflg: msgflg参数用来控制msgrcv的行为，有以下几种标志，且这些标志可以通过按位或的方式组合          IPC_NOWAIT: 消息队列中如果没有消息，则msgrcv调用立即返回，并设置errno为ENOMSG      MSG_EXCEPT: 如果msgtype大于0，则接收消息队列中第一个非msgtype类型的消息      MSG_NOERROR: 如果消息的数据部分长度超过了msg_sz，则将它截断        返回值: 成功返回0，失败返回-1，并设置errno。shmdt成功返回0，失败返回-1，并设置errno同样地，处于阻塞状态的msgrcv调用能被以下两种异常情况中断：  如果消息队列被移除，则msgrcv调用将立即返回，并设置errno为EIDRM  如果程序接收到信号，则msgrcv调用将立即返回，并设置errno为EINTRmsgrcv执行成功后会从消息队列中读取一条消息，同时它还会修改对应的内核数据结构，具体包括：  将msg_qnum减1  将msg_lrpid设置为调用进程的PID  将msg_rtime设置为当前时间msgctl下面是msgctl的系统调用，功能是直接控制消息队列的某些属性，其函数原型如下：#include &lt;sys/msg.h&gt;int msgctl(int msqid, int command, struct msqid_ds* buf);参数和返回值：  msqid: 由msgget调用返回的消息队列标识符  command: 指定要执行的命令。其命令和含义见下表所示。  buf: 用来获取或赋值消息队列相关的数据结构  返回值: 成功时的返回值取决于command参数，失败返回-1，并设置errnocommand支持的命令及其含义如下表所示：            command      含义      成功时返回值                  IPC_STAT      将消息队列相关的内核数据结构复制到buf中      0              IPC_SET      将buf中的部分成员复制到消息队列相关的内核数据结构中，同时内核数据结构中的msqid_ds.msg_ctime被更新      0              IPC_RMID      立即移除消息队列，唤醒所有等待读消息和写消息的进程（这些进程的调用会立即返回，并设置errno为EIDRM）      0              IPC_INFO      获取系统消息队列资源配置信息，将结果存储在buf中。应用程序需要将buf转换成msginfo结构体类型来读取这些系统信息，msginfo结构体和seminfo类似      内核消息队列信息数组中已被使用的项的最大索引值              MSG_INFO      和IPC_INFO类似，不过返回的是已经分配的消息队列占用的资源信息。应用程序需要将buf转换成msginfo结构体类型来读取这些系统信息。      内核消息队列信息数组中已被使用的项的最大索引值              MSG_STAT      与IPC_STAT类似，不过此时msqid参数不是用来表示消息队列标识符的，而是内核中消息队列信息数组的索引（每个消息队列的信息都是该数组中的一项）      内核消息队列信息数组中索引值为msqid的消息队列的标识符        信号量、共享内存、消息队列这3种System V IPC进程间的通信方式都是使用一个全局唯一的key来描述共享资源的。在Linux中，可以通过ipcs命令来查看当前系统有哪些共享资源实例。还可以通过ipcrm命令来删除遗留在系统中的共享资源实例。在进程间传递文件描述符最后我们探讨一下进程间的文件描述符的传递。在fork()之后，父进程的文件描述符在子进程中是保持打开的，此时文件描述符可以从父进程传递到子进程。这里需要注意的是传递文件描述符不是传递文件描述符的值，而是接收进程创建一个新的文件描述符，然后与原来的文件描述符指向内核中相同的文件表项。如果我们需要反过来将子进程打开的文件描述符传递到父进程，则可以利用UNIX域socket来实现。具体过程和代码如下：#include &lt;sys/socket.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;static const int CONTROL_LEN = CMSG_LEN(sizeof(int));//  发送文件描述符void send_fd(int fd, int fd_to_send){  struct iovec iov[1];    //  分散的内存块结构体  struct msghdr msg;  char buf[0];  iov[0].iov_base = buf;  //  指定内存块  iov[0].iov_len = 1;     //  指定内存块长度  msg.msg_name = NULL;    //  指定socket地址为NULL  msg.msg_namelen = 0;    //  指定socket地址长度  msg.msg_iov = iov;      //  指定内存块  msg.msg_iovlen = 1;     //  指定内存块长度  cmsghdr cm;  cm.cmsg_len = CONTROL_LEN;    //  指定附属数据的字节计数  cm.cmsg_level = SOL_SOCKET;   //  指定原始的协议级别  cm.cmsg_type = SCM_RIGHTS;    //  指定控制信息类型  *(int *)CMSG_DATA(&amp;cm) = fd_to_send;  msg.msg_control = &amp;cm;            //  指定辅助数据  msg.msg_controllen = CONTROL_LEN; //  指定辅助数据长度  sendmsg(fd, &amp;msg, 0);         //  发送文件描述符}//  接收目标文件描述符int recv_fd(int fd){  struct iovec iov[1];    //  分散的内存块结构体  struct msghdr msg;  char buf[0];  iov[0].iov_base = buf;  //  指定内存块  iov[0].iov_len = 1;     //  指定内存块长度  msg.msg_name = NULL;    //  指定socket地址为NULL  msg.msg_namelen = 0;    //  指定socket地址长度  msg.msg_iov = iov;      //  指定内存块  msg.msg_iovlen = 1;     //  指定内存块长度  cmsghdr cm;  msg.msg_control = &amp;cm;            //  指定辅助数据  msg.msg_controllen = CONTROL_LEN; //  指定辅助数据长度  recvmsg(fd, &amp;msg, 0);   //  接收目标文件描述符  int fd_to_read = *(int *)CMSG_DATA(&amp;cm);  return fd_to_read;}//  主函数int main(){  int pipefd[2];  int fd_to_pass = 0;  //  创建父子进程之间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket  int ret = socketpair(PF_UNIX, SOCK_DGRAM, 0, pipefd);  assert(ret != -1);  pid_t pid = fork();   //  创建子进程  assert(pid &gt;= 0);  if(pid == 0){   //  子进程    close(pipefd[0]);    fd_to_pass = open(\"test.txt\", O_RDWR, 0666);    //  子进程通过管道将文件描述符发送给父进程    //  如果test.txt文件打开失败，则子进程将标准输入文件描述符发送给父进程    send_fd(pipefd[1], (fd_to_pass &gt; 0) ? fd_to_pass : 0);    close(fd_to_pass);    exit(0);  }  //  父进程  close(pipefd[1]);  fd_to_pass = recv_fd(pipefd[0]);  //  父进程从管道接收目标文件描述符  char buf[1024];  memset(buf, '\\0', 1024);  read(fd_to_pass, buf, 1024);      //  读取目标文件描述符，验证有效性  printf(\"I got fd %d and data %s\\n\", fd_to_pass, buf);  close(fd_to_pass);  return 0;}总结      消息队列是两个进程之间传递二进制块数据的一种简单有效的方式。    不同于共享内存和管道必须以先进先出的方式传递数据，消息队列中的每个数据块都有特定的类型，接收方可以根据类型有选择地来接收数据    操作系统提供了msgget的系统调用，功能是创建一段新的消息队列或获取一段已经存在的消息队列    操作系统提供了msgsnd和msgrcv的系统调用，功能是对消息队列中写入或读取一条消息    操作系统提供了msgctl的系统调用，功能是直接控制消息队列的某些内核属性    在Linux中，可以通过ipcs命令来查看当前系统打开了哪些共享资源实例，可以通过ipcrm命令来删除遗留在系统中的共享资源实例    可以利用UNIX域socket来实现文件描述符从子进程到父进程的传递  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多进程编程_4",
    "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B_4/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Multiprocess",
    "date": "2023-05-08 14:43:00 +0800",
    





    
    "snippet": "共享内存  本节介绍了另一种进程之间通信的方式——共享内存。共享内存是最高效的进程间通信方式，但是往往需要和其他通信方式一起使用实现进程间的同步。共享内存通过shmget调用来创建或打开共享内存对象，通过shmat和shmdt调用来绑定或解绑进程的地址空间，还可以通过shmctl调用来直接控制共享内存的某些属性。最后我们讲解了mmap函数可以通过POSIX共享内存对象来实现无关进程间的通信，...",
    "content": "共享内存  本节介绍了另一种进程之间通信的方式——共享内存。共享内存是最高效的进程间通信方式，但是往往需要和其他通信方式一起使用实现进程间的同步。共享内存通过shmget调用来创建或打开共享内存对象，通过shmat和shmdt调用来绑定或解绑进程的地址空间，还可以通过shmctl调用来直接控制共享内存的某些属性。最后我们讲解了mmap函数可以通过POSIX共享内存对象来实现无关进程间的通信，其中shm_open和shm_unlink调用分别为打开和删除POSIX共享内存对象。共享内存共享内存是进程间通信的几种方法中，最高效的一种。因为它不涉及进程间的任何数据传输。但是这种高效也带来了竞争问题，所以共享内存往往和其中进程间通信方式一起使用。Linux中，共享内存的API定义在sys/shm.h头文件中，包括4个系统调用：shmget、shmat、shmdt和shmctl。下面我们一一讨论。shmget下面是shmget的系统调用，功能是创建一段新的共享内存或获取一段已经存在的共享内存，其函数原型如下：#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);参数和返回值：  key: 键值，用来标识一段全局唯一的共享内存  size: 指定共享内存的大小，单位是字节。如果是创建共享内存，该字段必须指定，如果是获取已有的共享内存，该字段可以设0  shmflg: 指定一组标志。它低位的9 bit表示共享内存的权限，其格式和含义与open系统调用的mode参数相同。shmflg还可以与下列标志通过”或”运算的方式传参，其标志及含义：          IPC_CREAT: 表示即使共享内存已存在，shmget创建新的共享内存也不会报错      IPC_CREAT和IPC_EXL: 表示创建一组新的、唯一的共享内存。如果共享内存已存在，则会报错并将errno设置位EEXIST      SHM_HUGETLB: 类似于mmap的MAP_HUGETLB标志，系统将使用大页面来为共享内存分配空间      SHM_NORESERVE: 类似于mmap的MAP_NORESERVE标志，不为共享内存保留交换分区（swap空间），当物理内存不足时，对该共享内存执行写操作会触发SIGSEGV信号        返回值：成功返回一个正整数，它是共享内存的标识符。失败返回-1，并设置errno当我们调用shmget创建共享内存后，其共享内存的所有字节都会被初始化为0，并且创建内核数据结构shmid_ds。shmid_ds结构体定义如下：struct shmid_ds{    struct ipc_perm shm_perm;   //  共享内存的操作权限    size_t shm_segsz;           //  共享内存大小，单位是字节    __time_t shm_atime;         //  对共享内存最后一次调用shmat的时间    __time_t shm_dtime;         //  对共享内存最后一次调用shmdt的时间    __time_t shm_ctime;         //  对共享内存最后一次调用shmctl的时间    __pid_t shm_cpid;           //  创建者的PID    __pid_t shm_lpid;           //  最后一次执行shmat或shmdt操作的进程的PID    shmatt_t shm_nattach;       //  目前关联到共享内存的进程数量    ...                         //  一些填充字段};shmget对shmid_ds结构体的初始化包括：  将shm_perm.cuid和shm_perm.uid设置为调用进程的用户ID  将shm_perm.cgid和shm_perm.gid设置为调用进程的组ID  将shm_perm.mode的低9位设置为shmflg参数的低9位  将shm_segsz设置为size参数的值  将shm_lpid、shm_nattach、shm_atime、shm_dtime设置为0  将shm_ctime设置为当前时间shmat/shmdt当我们通过shmget创建或获取共享内存后，不能立即访问它，必须先将它关联到进程的地址空间中。使用完共享内存后，我们需要将它从进程的地址空间中分离出来。下面是shmat和shmdt的系统调用，功能是将共享内存与进程的地址空间进行关联或分离，其函数原型如下：#include &lt;sys/shm.h&gt;void *shmat(int shm_id, const void *shm_addr, int shmflg);int shmdt(const void *shm_addr);参数和返回值：  shm_id: 由shmget调用返回的共享内存标识符  shm_addr: 指定共享内存关联到进程的哪块地址空间中  shmflg: 影响操作行为的标志，其取值和含义如下：          SHM_RND: 如果shm_addr为NULL，则被关联的地址由操作系统决定。如果shm_addr不为NULL，被关联的的地址为shm_addr - (shm_addr % SHMLBA)。其中SHMLBA为段低端边界地址倍数(Segment Low Boundary Address Multiple)，它必须是内存页面大小的整数倍。SHM_RND中RND的含义是round，表示圆整，即要求共享内存被关联的地址向下圆整到离shm_addr最近的SHMLBA整数倍的地址处      SHM_RDONLY: 进程仅能读取共享内存中的内容      SHM_REMAP: 如果地址shm_addr已被关联到一段共享内存上，则重新关联      SHM_EXEC: 指定对共享内存段的执行权限。实际上，共享内存的执行权限和读权限是一样的        返回值: shmat成功返回共享内存被关联的地址，失败返回(void*)-1，并设置errno。shmdt成功返回0，失败返回-1，并设置errno。shmat成功时会修改内核数据结构的shmid_ds的部分字段，包括：  将shm_nattach加1  将shm_lpid设置为调用进程的PID  将shm_atime设置为当前时间shmdt成功时也会修改内核数据结构的shmid_ds的部分字段，包括：  将shm_nattach减1  将shm_lpid设置为调用进程的PID  将shm_dtime设置为当前时间shmctl下面是shmctl的系统调用，功能是直接控制共享内存的某些属性，其函数原型如下：#include &lt;sys/shm.h&gt;int shmctl(int shm_id, int command, struct shmid_ds* buf);参数和返回值：  shm_id: 由shmget调用返回的共享内存标识符  command: 指定要执行的命令。其命令和含义见下表所示。  buf: 用来获取或赋值共享内存相关的数据结构  返回值: 成功时的返回值取决于command参数，失败返回-1，并设置errnocommand支持的命令及其含义如下表所示：            command      含义      成功时返回值                  IPC_STAT      将共享内存相关的内核数据结构复制到buf中      0              IPC_SET      将buf中的部分成员复制到共享内存相关的内核数据结构中，同时内核数据结构中的shmid_ds.shm_ctime被更新      0              IPC_RMID      将共享内存打上删除标记，这样当最后一个使用它的进程调用shmdt将它从进程中分离时，该共享内存会被删除      0              IPC_INFO      获取系统共享内存资源配置信息，将结果存储在buf中。应用程序需要将buf转换成shminfo结构体类型来读取这些系统信息，shminfo结构体和seminfo类似      内核共享内存信息数组中已被使用的项的最大索引值              SHM_INFO      和IPC_INFO类似，不过返回的是已经分配的共享内存占用的资源信息。应用程序需要将buf转换成shminfo结构体类型来读取这些系统信息。      内核共享内存信息数组中已被使用的项的最大索引值              SHM_STAT      与IPC_STAT类似，不过此时shm_id参数不是用来表示共享内存标识符的，而是内核中共享内存信息数组的索引（每个共享内存的信息都是该数组中的一项）      内核共享内存信息数组中索引值为shm_id的共享内存的标识符              SHM_LOCK      禁止共享内存被移动到交换分区      0              SHM_UNLOCK      允许共享内存被移动到交换分区      0      共享内存的POSIX方法mmap函数通过打开同一个文件，可以实现无关进程之间的内存共享。Linux提供了另一种利用mmap在无关进程之间共享内存方式，即使用POSIX共享内存对象。下面是shm_open的系统调用，功能是创建或打开一个POSIX共享内存对象，其函数原型如下：#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int shm_open(const char *name, int oflag, mode_t mode);参数和返回值：  name: 指定要创建或打开的共享内存对象，长度不超过NAME_MAX(通常为255)  oflag: 指定创建方式，可以通过标志按位或的方式传参，包括以下方式          O_RDONLY: 只读方式打开共享内存对象      O_RDWR: 可读可写的方式打开共享内存对象      O_CREAT: 如果共享内存对象不存之，则创建它。此时mode参数的低9位指定该共享内存对象的访问权限。创建共享内存对象时，其初始长度为0      O_EXCL: 和O_CREAT一起用，如果name指定的共享内存对象已存在，则返回错误      O_TRUNC: 如果共享内存对象已存在，则截断它，使其长度为0        mode: 指定新建共享内存对象的访问权限。它低位的9 bit表示共享内存的权限，其格式和含义与open系统调用的mode参数相同  返回值: 成功返回一个文件描述符，该文件描述符可用于mmap调用；失败返回-1，并设置errno当我们结束使用时，创建或打开POSIX共享内存对象需要通过shm_unlink调用进行删除。下面是sem_unlink的系统调用，功能是删除使用完毕的POSIX共享内存对象，其函数原型如下：#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int shm_unlink(const char *name);参数和返回值：  name: 指定要删除的共享内存对象  返回值: 成功返回0，失败返回-1，并设置errno该函数将指定的共享内存对象标志为等待删除，只有所有使用该共享内存对象的进程都使用ummap将它从进程分离后，才会真正销毁该共享内存对象所占的资源。最后需要注意，如果代码中使用了POSIX共享内存函数，编译时需要指定链接选项-lrt。总结      共享内存是最高效的进程间通信方式，但是往往需要和其他通信方式一起使用实现进程间的同步    操作系统提供了shmget的系统调用，功能是创建一段新的共享内存或获取一段已经存在的共享内存    操作系统提供了shmat和shmdt的系统调用，功能是将共享内存与进程的地址空间进行关联或分离    操作系统提供了shmctl的系统调用，功能是直接控制共享内存的某些属性    操作系统提供了shm_open的系统调用，功能是创建或打开一个POSIX共享内存对象    操作系统提供了sem_unlink的系统调用，功能是删除使用完毕的POSIX共享内存对象  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多进程编程_3",
    "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Multiprocess",
    "date": "2023-05-06 19:36:00 +0800",
    





    
    "snippet": "信号量  前面介绍了多进程之间的一种通信方式——管道。但是管道利用了子进程继承父进程的文件描述符的特点，所以只能用于父、子进程间的通信。本节介绍了无关联的进程间的一种通信方式——信号量。信号量是是一种特殊的变量，用来控制进程间的同步与并发。它支持PV操作，通过semget、semop和semctl系统调用来操作信号量。由于信号量、共享内存和消息队列都是通过一个全局唯一的键值来标识的，所以可以...",
    "content": "信号量  前面介绍了多进程之间的一种通信方式——管道。但是管道利用了子进程继承父进程的文件描述符的特点，所以只能用于父、子进程间的通信。本节介绍了无关联的进程间的一种通信方式——信号量。信号量是是一种特殊的变量，用来控制进程间的同步与并发。它支持PV操作，通过semget、semop和semctl系统调用来操作信号量。由于信号量、共享内存和消息队列都是通过一个全局唯一的键值来标识的，所以可以在无关联的进程之间进行通信。最后我们讲解了一种特殊的键值IPC_PRIVATE，它可以用于上面三种通信方式中。它并不像名字所示是私有的，而是表示无论目标信号量（或共享内存、消息队列）是否存在，都会创建一个新的信号量（或共享内存、消息队列）。信号量在多进程程序中，如果多个进程访问某个独占式资源，往往需要确保同一时间段只有一个进程能够占用该资源。通常，程序对该共享资源的访问代码只有很短一段，我们称这段代码为关键代码段，或临界区。进程间的同步，就是确保任一时间段只有一个进程能进入关键代码段。信号量，是一种特殊的变量，用来控制进程间的同步与并发。它的值是自然数值，支持两种操作：等待(wait)和信号(signal)。假设有信号量SV，两种操作如下：  P(SV)：如果SV的值大于0，则减1；如果SV的值为0，则挂起进程  V(SV)：如果有其他进程因为等待SV而挂起，则唤醒；如果没有，则SV加1  在Linux/UNIX中，等待和信号都具有特殊的含义，所以通常用P和V来表示信号量的两种操作。这两个单词来自荷兰语单词passeren(传递，表示进入临界区)和vrijgeven(释放，表示退出临界区)。我们以一个简单的二进制信号量为例，如下图所示：二进制信号量SV的值为1，进程A、B都有机会访问关键代码段。  假设进程A竞争成功，此时进程A会先执行P(SV)操作，信号量SV减1  若进程B再执行P(SV)操作则会被挂起，直到进程A离开关键代码段  进程A执行V(SV)操作，将SV加1  进程B由等待SB状态被唤醒，进入关键代码段  同样，如果这时进程A再执行P(SV)操作，将会被操作系统挂起，直到进程B退出关键代码段  这里信号量之所以是一个特殊的变量，是因为普通变量无法将以下两个操作原子化：1.检测变量是否为true/false；2.设置变量值为true/false。所以使用一个普通变量来模拟二进制信号是不行的。Linux信号量的API都定义在sys/sem.h头文件中，主要由3个系统调用：semget、semop和semctl。接下来我们将一一介绍。semget下面是semget的系统调用，功能是创建一个新的信号量集，或获取一个已存在的信号量集，其函数原型如下：#include &lt;sys/sem.h&gt;int semget(key_t key, int num_sems, int sem_flags);参数和返回值：  key：键值，用来标识一个全局唯一的信号量集。要通过信号量进行通信的进程需要使用相同的key来创建和获取信号量  num_sems：指定要创建/获取信号量的数目。如果是创建信号量，该值必须被指定，如果是获取已存在的信号量，该值可以置0  sem_flags：指定一组标志。它低位的9 bit表示信号量的权限，其格式和含义与open系统调用的mode参数相同          sem_flags可以与IPC_CREAT标志”或”运算，此时表示即使信号量已存在，semget创建新的信号量集也不会报错      sem_flags可以与IPC_CREAT和IPC_EXL标志”或”运算，此时表示创建一组新的、唯一的信号量集。如果信号量集已存在，则会报错并将errno设置位EEXIST        返回值：成功返回一个正整数，它是信号量集的标识符；失败返回-1，并设置errnosemget创建信号量集，并且会创建和初始化对应的内核数据结构体semid_ds。其中结构体semid_ds的定义如下：#include &lt;sys/sem.h&gt;struct ipc_perm{\tkey_t key;\t\t\t//\t标识键值\tuid_t uid;\t\t\t//\t所有者的用户ID\tgid_t gid;\t\t\t//\t所有者的组ID\tuid_t cuid;\t\t\t//\t创建者的用户ID\tgid_t cgid;\t\t\t//\t创建者的组ID\tmode_t mode;\t\t//\t访问权限\t...\t\t\t\t\t//\t其他填充字段};struct semid_ds{\tstruct ipd_perm sem_perm;\t\t//\t信号量的操作权限\tunsigned long int sem_nsems;\t//\t该信号量集中的信号量的数目\ttime_t sem_otime;\t\t\t\t//\t最后一次调用semop的时间\ttime_t sem_ctime;\t\t\t\t//\t最后一次调用semctl的时间\t...\t\t\t\t\t\t\t\t//\t其他填充字段};semget对semid_ds结构体的初始化包括：  将sem_perm.cuid和sem_perm.uid设置为调用进程的用户ID  将sem_perm.cgid和sem_perm.gid设置为调用进程的组ID  将sem_perm.mode的低位的9 bit设置为sem_flags参数的低位的9 bit  将sem_nsems设置为num_sems  将sem_otime设置为0  将sem_ction设置为当前系统时间semopsemget系统调用创建了信号量集，接着我们使用semop系统调用来操作这些信号量，即执行P、V操作。semop调用通过对信号量对应的内核变量进行读、写来操作信号量，一些重要的信号量内核变量如下：unsigned short semval;\t\t//\t信号量的值unsigned short semzcnt;\t\t//\t等待信号量值变为0的进程数量unsigned short semncnt;\t\t//\t等待信号量值增加的进程数量pid_t sempid;\t\t\t\t//\t最后一次执行semop操作的进程ID下面是semop的系统调用，功能是对信号量相关的内核变量进行操作，其函数原型如下：#include &lt;sys/sem.h&gt;int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);参数和返回值：  sem_id: 指定被操作的目标信号量集，该标识符是semget调用的返回值  sem_ops: 指向一个sembuf结构体的数组指针，sembuf结构体定义见下面  num_sem_ops: sem_ops数组的元素个数，即执行的操作个数  返回值: 成功返回0，失败返回-1，并设置errno，并且失败时sem_ops数组中所有的操作都不会被执行sembuf结构体定义如下：struct sembuf{\tunsigned short int sem_num;\tshort int sem_op;\tshort int sem_flg;};其中：  sem_num: 表示信号量集中信号量的编号，0表示信号量集中的第一个信号量  sem_op: 表示操作类型，取值由正整数、0、负整数  sem_flg: 影响操作行为的标志，可以有以下取值：          IPC_NOWAIT: 无论信号量操作是否成功，semop调用都立即返回，类似于非阻塞I/O操作      SEM_UNDO: 当进程退出时，取消正在进行的semop操作      具体的操作行为：  如果sem_op大于0，则semop调用会将目标信号量的值semval增加sem_op。该操作要求调用的进程对目标信号量拥有写权限。若设置了SEM_UNDO标志，则系统更新进程的semadj变量，用以回溯信号量的修改  如果sem_op等于0，表示这是一个“等待0”操作。该操作要求调用的进程对目标信号量拥有读权限。如果此时信号量为0，则立即成功返回；否则信号量不为0，则根据sem_flg参数执行以下操作：          如果指定IPC_NOWAIT标志，semop立即返回一个错误，并设置errno为EAGAIN      如果未指定IPC_NOWAIT标志，则信号量对应的semzcnt的值加1，进程被挂起，直到满足以下三个条件之一：                  信号量的值semval变为0，进程唤醒，同时信号量对应的semzcnt的值减1          或目标信号量所在的信号量集被进程移除，此时返回失败，errno被设置为EIDRM          或调用被信号中断，此时返回失败，errno被设置为EINTTR，同时信号量对应的semzcnt的值减1                      如果sem_op小于0，则表示对信号量值进行减操作，即进程获得信号量。该操作要求调用的进程对目标信号量拥有写权限。如果信号量的值semval大于等于sem_op的值，则操作成功，调用进程立即获得信号量，同时修改信号量值semval。如果设置了SEM_UNDO标志，则系统更新进程的semadj变量。否则，信号量的值semval小于sem_op，则根据sem_flg参数执行以下操作：          如果指定IPC_NOWAIT标志，semop立即返回一个错误，并设置errno为EAGAIN      如果未指定IPC_NOWAIT标志，则信号量对应的semncnt的值加1，进程被挂起，直到满足以下三个条件之一：                  信号量的值semval大于等于sem_op的值，进程唤醒，同时信号量对应的semncnt的值减1，修改信号量值semval。如果设置了SEM_UNDO标志，则系统更新进程的semadj变量          或目标信号量所在的信号量集被进程移除，此时返回失败，errno被设置为EIDRM          或调用被信号中断，此时返回失败，errno被设置为EINTTR，同时信号量对应的semncnt的值减1                    semop对数组sem_ops中每个成员按顺序执行操作，并且该过程是原子的，避免其他进程对该信号量集执行操作导致的竞争。semctlsemctl系统调用允许调用者对信号量进行直接控制。下面是semctl的系统调用，功能是使调用者对信号量进行直接控制，其函数原型如下：#include &lt;sys/sem.h&gt;int semctl(int sem_id, int sem_num, int command, ...);参数和返回值：  sem_id: 指定被操作的目标信号量集，该标识符是semget调用的返回值  sem_num: 表示信号量集中信号量的编号，0表示信号量集中的第一个信号量  command: 指定要执行的命令  …: 有的命令需要调用者提供第4个参数，参数类型由用户自定义，但sys/sem.h头文件给出了推荐格式，推荐格式见下面  返回值: 成功时的返回值取决于command参数，失败返回-1，并设置errnosemctl调用第4个参数的推荐格式如下：union semun{\tint val;\t\t\t\t\t//\t用于SETVAL命令\tstruct semid_ds *buf;\t\t//\t用于IPC_STAT和IPC_SET命令\tunsigned short* array;\t\t//\t用于GETALL和SETALL命令\tstruct seminfo *__buf;\t\t//\t用于IPC_INFO命令};struct seminfo{\tint semmap;\t\t\t\t\t//\tLinux内核没有使用\tint semmni;\t\t\t\t\t//\t系统最多可以拥有的信号量集数目\tint semmns;\t\t\t\t\t//\t系统最多可以拥有的信号量数目\tint semmnu;\t\t\t\t\t//\tLinux内核没有使用\tint semmsl;\t\t\t\t\t//\t一个信号量集最多包含的信号量数目\tint semopm;\t\t\t\t\t//\tsemop一次最多能执行的sem_op操作数目\tint semume;\t\t\t\t\t//\tLinux内核没有使用\tint semusz;\t\t\t\t\t//\tsem_undo结构体的大小\tint semvmx;\t\t\t\t\t//\t最大允许的信号量值\tint semaem;\t\t\t\t\t//\t最多允许的undo次数(带SEM_UNDO标志的semop操作次数)};semctl操作支持的操作如下：            command      含义      成功时返回值                  IPC_STAT      将信号量集关联的内核数据结构复制到semun.buf中      0              IPC_SET      将semun.buf中的部分成员复制到信号量集关联的内核数据结构中，同时内核数据中的semid_ds.sem_ctime更新      0              IPC_RMID      立即移除信号量集，唤醒所有等待该信号量集的进程（scmop返回错误，并设置errno为EIDRM）      0              IPC_INFO      获取系统信号量资源配置信息，将结果存储在semun.__buf中。这些信息含义见结构体seminfo的注释部分      内核信号量集中已被使用的项的最大索引值              SEM_INFO      与IPC_INFO类似，不过semun.__buf.semusz被设置为系统目前拥有的信号量集的数目，而semun.__buf.semaem被设置为系统目前拥有的信号量的数目      内核信号量集中已被使用的项的最大索引值              SEM_STAT      与IPC_STAT类似，不过此时sem_id参数不是用来表示信号量集标识符的，而是内核中信号量集数组的索引（系统的所有信号量集都是该数组中的一项）      内核信号量集数组中索引为sem_id的信号量集的标识符              GETALL      将由sem_id标识的信号量集中的所有信号量的semval值导出到semun.array中      0              GETNCNT      获取信号量的semncnt值      信号量的semncnt值              GETPID      获取信号量的sempid值      信号量的sempid值              GETVAL      获取信号量的semval值      信号量的semval值              GETZCNT      获取信号量的semzcnt值      信号量的semzcnt值              SETALL      用semun.array中的数据填充由sem_id标识的信号量集中的所有信号量的semval值，同时内核数据中的semid_ds.sem_ctime被更新      0              SETVAL      将信号量的semval值设置为semun.val，同时内核数据中的semid_ds.sem_ctime被更新      0        这些操作中，GETNCNT、GETPID、GETVAL、GETZCNT和SETVAL操作的是单个信号量，由sem_id指定信号量集中的第sem_num个信号量；其他操作针对的是整个信号量集，此时semctl的参数sem_num可以忽略。特殊键值IPC_PRIVATEsemget调用时，可以给key参数传递一个特殊的键值IPC_PRIVATE（其值为0）。IPC_PRIVATE表示无论该信号量是否存在，semget都将创建一个新的信号量。下面是父、子进程使用信号量的示例。该示例通过IPC_PRIVATE创建信号量，同时演示semget、semop、semctl调用的用法。#include &lt;sys/sem.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;union semun\t\t//\tsemctl调用第四个参数的推荐格式{\tint val;\tstruct semid_ds *buf;\tunsigned short int *array;\tstruct seminfo *__buf;};//\t执行PV操作，当op为正数时为P，负数时为Vvoid pv(int sem_id, int op){\tstruct sembuf sem_b;\tsem_b.sem_num = 0;\tsem_b.sem_op = op;\tsem_b.sem_flg = SEM_UNDO;\tsemop(sem_id, &amp;sem_b, 1);}int main(int argc, char *argv[]){\tint sem_id = semget(IPC_PRIVATE, 1, 0600);\t//\t创建信号量集\t\tunion semun sem_un;\tsem_un.val = 1;\tsemctl(sem_id, 0, SETVAL, sem_un);\t//\t给信号量赋值\t\tpid_t id = fork();\t\tif(id &lt; 0){\t\t//\t创建子进程失败\t\treturn 1;\t}else if(id == 0){\t\t//\t子进程访问资源\t\tprintf(\"child try to get binary sem\\n\");\t\tpv(sem_id, -1);\t\tprintf(\"child get the sem and would release it after 5 second\\n\");\t\tsleep(5);\t\tpv(sem_id, 1);\t\texit(0);\t}else{\t\t\t\t\t//\t父进程访问资源\t\tprintf(\"parent try to get binary sem\\n\");\t\tpv(sem_id, -1);\t\tprintf(\"parent get the sem and would release it after 5 second\\n\");\t\tsleep(5);\t\tpv(sem_id, 1);\t}\t\twaitpid(id, NULL, 0);\t//\t等待子进程退出\tsemctl(sem_id, 0, IPC_RMID, sem_un);\t//\t删除信号量\treturn 0;}/* 输出parent try to get binary semparent get the sem and would release it after 5 secondchild try to get binary sem(间隔5s)child get the sem and would release it after 5 second(间隔5s)*/  注：共享内存和消息队列在创建资源的时候，也支持IPC_PRIVATE键值，其含义相同总结      信号量，是一种特殊的变量，用来控制进程间的同步与并发。它的值是自然数值，支持两种操作：等待(wait)和信号(signal)    操作系统提供了semget的系统调用，可以创建一个新的信号量集，或获取一个已存在的信号量集    操作系统提供了semop的系统调用，可以对信号量相关的内核变量进行操作，从而实现PV操作    操作系统提供了semctl的系统调用，可以使调用者对信号量进行直接控制    semget系统调用中可以传递给key参数一个特殊键值IPC_PRIVATE，表示无论该信号量是否存在，semget都将创建一个新的信号量  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多进程编程_2",
    "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Multiprocess",
    "date": "2023-05-05 16:39:00 +0800",
    





    
    "snippet": "wait/waitpid/pipe  本节探讨了父、子进程中的状态问题，有两种情况子进程会进入僵尸态：1.子进程结束，父进程读取其退出状态前；2.父进程结束或异常，子进程被init进程接管时也会处于僵尸态。操作系统提供了wait和waitpid两个系统调用来立即结束子进程的僵尸状态。然后，文章介绍了父、子进程之间可以通过管道pipe来进行通信。wait/waitpid在多进程程序中，父进程往...",
    "content": "wait/waitpid/pipe  本节探讨了父、子进程中的状态问题，有两种情况子进程会进入僵尸态：1.子进程结束，父进程读取其退出状态前；2.父进程结束或异常，子进程被init进程接管时也会处于僵尸态。操作系统提供了wait和waitpid两个系统调用来立即结束子进程的僵尸状态。然后，文章介绍了父、子进程之间可以通过管道pipe来进行通信。wait/waitpid在多进程程序中，父进程往往需要追踪子进程的退出状态。因此，当子进程结束时，内核不会立即释放子进程的进程表表项，以满足父进程后续对子进程退出信息的查询。所以在子进程退出后，父进程读取其退出状态前，子进程会处于僵尸态。还有一种情况会造成子进程僵尸态：如果父进程结束或异常终止，而子进程继续运行，此时子进程的PPID会被操作系统设置为1，即pid为1的进程是init进程。init进程接管了子进程，并等待它结束。所以父进程退出后，子进程退出前，子进程也会处于僵尸态。如果父进程没有正确处理子进程的返回信息，子进程会处于僵尸态，占据内核资源。这时我们需要在父进程中调用wait/waitpid函数，等待子进程结束，并获取子进程的返回信息，从而使子进程立即从僵尸态中结束。下面是wait/waitpid的系统调用，功能是等待子进程结束，并获取子进程的返回信息，使子进程立即从僵尸态中结束，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *stat_loc);pid_t waitpid(pid_t pid, int *stat_loc, int options);参数和返回值：  stat_loc：存储子进程退出状态信息  pid：指定等待的子进程，如果pid取-1，则等待任意一个子进程结束  optios：控制waitpid函数的行为。一般取WNOHANG，表示waitpid调用是非阻塞的，如果pid指定的目标子进程未结束或意外终止，返回0；如过目标子进程正常退出，返回子进程的PID  返回值：返回结束运行的子进程PID，如果调用失败返回-1，并设置errnowait函数是等待任意子进程结束，而waitpid函数是等待特定的子进程结束。在sys/wait.h头文件中，定义了一些用来帮助结束子进程退出状态信息的宏。如下表所示：            宏      含义                  WIFEXITED(stat_val)      如果子进程正常结束，返回一个非0值              WEXITSTATUS(stat_val)      如果WIFEXITED非0，返回子进程的退出码              WIFSIGNALED(stat_val)      如果子进程是因为一个未捕获信号而终止，返回一个非0值              WTERMSIG(stat_val)      如果WIFSIGNALED非0，返回信号值              WIFSTOPPED(stat_val)      如果子进程意外终止，返回一个非0值              WSTOPSIG(stat_val)      如果WIFSTOPPED非0，返回信号值      例子如下：static void handle_child(int sig){\tpid_t pid;\tint stat;\twhile((pid = waitpid(-1, &amp;stat, WNOHAND)) &gt; 0){\t\t//\t对结束的子进程进行善后处理\t}}管道父/子进程之间可以通过管道pipe来传递数据下面是pipe的系统调用，功能是创建一条管道，通过一对文件描述符对管道进行读写，其函数原型如下：#include &lt;unistd.h&gt;int pipe(int fd[2]);参数和返回值：  fd[2]：包含两个int型整数的数组指针，存储创建的文件描述符  返回值：成功返回0，失败返回-1，并设置errnopipe函数构建的两个文件描述符fd[0]和fd[1]构成管道的两端，其中fd[1]用于往管道写入数据，fd[0]用于往管道读取数据，并且它们不能反过来使用。所以一对文件描述符只能保证父、子进程间一个方向的数据传输。父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。就像下面这样：关闭fd[0]           关闭fd[1]父进程 --&gt; 管道 --&gt; 子进程  写入\t            读取如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。  管道提供的这一对文件描述符默认是阻塞的，即我们用read系统调用读取一个空管道时会发生阻塞，直到管道内有数据可读；我们用write系统调用往一个满的管道写入时，也会发生阻塞，直到管道有足够多的空闲空间为止。当然，管道也可以设置为非阻塞的，此时read和write的行为会有不同的行为。socket编程接口提供了一个创建全双工管道的系统调用socketpair。下面是socketpair的系统调用，功能是创建一条双向管道，这条管道对应的一对文件描述符即可读也可写，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int fd[2]);参数和返回值：  domain：指定协议，只能指定UNIX本地域协议族AF_UNIX  type：指定服务类型，取值有：流服务SOCK_STREAM，数据报服务SOCK_UGRAM  protocol：在前两个参数构成的协议集合中，再选择一个具体的协议，默认0  fd[2]：包含两个int型整数的数组指针，存储创建的文件描述符  返回值：成功返回0，失败返回-1，并设置errno不过，管道只能用于有关联的两个进程，比如父子进程，子进程会继承父进程打开的文件描述符，从而实现管道通信。  管道的容量是有限制的。自Linux 2.6.11内核起，管道容量大小默认是65536字节。可以通过fcntl函数修改管道容量。当父、子进程关闭管道时，对应的引用计数为减1，只有引用计数减至0时才会真正地关闭文件描述符。如果管道写端的文件描述符fd[1]的引用计数为0，则对fd[0]调用read函数时会返回0，即读取文件结束标记(EOF)。反之，如果管道读端的文件描述符fd[0]的引用计数为0，则对fd[1]调用write函数则会失败，引发SIGPIPE信号。总结      操作系统提供了wait/waitpid的系统调用，功能是等待子进程结束，并获取子进程的返回信息，使子进程立即从僵尸态中结束    操作系统提供了pipe的系统调用，功能是创建一条管道，通过一对文件描述符对管道进行读写    socket网络编程接口提供了socketpair的系统调用，可以创建一条全双工管道  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 多进程编程_1",
    "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, Multiprocess",
    "date": "2023-05-05 11:00:00 +0800",
    





    
    "snippet": "fork/exec  本节介绍了多进程中最重要的fork系统调用，它可以创建一个新的进程。然后介绍了exec族的系统调用，它可以将当前进程替换为目标可执行文件，代码段和数据段都会被替换。forkLinux中创建新的进程的系统调用是fork。下面是fork的系统调用，功能是创建一个新进程，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;unis...",
    "content": "fork/exec  本节介绍了多进程中最重要的fork系统调用，它可以创建一个新的进程。然后介绍了exec族的系统调用，它可以将当前进程替换为目标可执行文件，代码段和数据段都会被替换。forkLinux中创建新的进程的系统调用是fork。下面是fork的系统调用，功能是创建一个新进程，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);参数和返回值：  返回值：该函数每次调用都会有两个返回值，在父进程中返回子进程的PID，在子进程中则返回0。所以返回值是后续代码判断父/子进程的依据。调用失败则返回-1，并设置errno。fork系统调用执行后：  申请子进程的PID  在内核进程表中创建一个新的表项（即PCB）  用原进程的PCB初始化子进程的PCB  将子进程的运行状态设置为不可执行的  将子进程中的属性清零、保留或修改 其中子进程的PCB中堆指针、栈指针和标志寄存器等的值和原进程的PCB相同。但是子进程的PCB中PPID会被设置为原进程的PID，信号位图也会被清除（原进程设置的信号处理函数不再对子进程起作用）  复制父进程的页（用到了写时拷贝技术） 子进程会复制父进程的代码段、堆数据、栈数据和静态数据。数据的复制采用写时复制策略(copy on write)，即初始阶段共用内存数据，并将该区域设置为只读。当父/子进程执行写操作时，才会发生复制。复制时会先触发缺页中断，然后操作系统给子进程分配内存，并复制父进程的数据。此外，创建子进程后，父进程打开的文件描述符默认在子进程中也是打开的，即文件描述符会复制一份给子进程，然后此文件描述符的引用计数加1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数都会加1。下面是关于fork调用的一个示例：#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int agrc, char *argv[]){\tpid_t fpid;\tint count = 0;\tfpid = fork();\tif(fpid &lt; 0){\t\tprintf(\"error in fork!/n\");\t}else if(fpid == 0){\t\tprintf(\"这是父进程，进程号为: %d\\n\",getpid());\t\tcount++;\t}else{\t\tprintf(\"这是子进程，进程号为：%d\\n\",getpid());\t\tcount++;\t}\tprintf(\"返回了%d次\\n\",count);\treturn 0;\t}/*\t输出这是子进程，进程号为：44653返回了1次这是父进程，进程号为: 44654返回了1次*/可以看到fork系统调用返回了两次，而且count变量也复制了一份。getpid()函数可以获取当前进程的PID。exec我们可以将创建的子进程执行其他应用程序，此时该进程被完全替换为新程序。但并不创建新的进程，前后进程的PID没有发生改变。下面是exec族的系统调用，功能是将当前进程替换成其他应用程序，其函数原型如下：#include &lt;unistd.h&gt;extern char **environ;int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char* const envp[]);int execv(const char *path, char* const argv[]);int execvp(const char *file, char* const argv[]);int execve(const char *path, char* const argv[], char* const envp[]);参数和返回值：  path：可执行文件的完整地址  file：可执行文件名，如果file参数中包含/，则视为路径名，否则在环境变量PATH中搜索该文件  arg：传递给新程序main函数的可变参数  argv：传递给新程序main函数的参数列表  envp：设置新程序的环境变量，如果未设置则使用全局变量environ指定的环境变量  返回值：一般情况下不返回，除非出错，出错时返回-1，并设置errnoexec调用不返回的原因是原程序会被指定程序完全替换（包括代码段和数据段），所以原程序中exec调用之后的代码不会执行，只有调用失败时才会往下继续执行。但是exec函数不会关闭原程序打开的文件描述符，除非该文件描述符设置了SOCK_CLOEXEC的属性。exec族函数可以分为四类：  带l的exec函数，l表示使用可变参数列表，列表中的参数将作为新程序的命令行参数，而且要求参数列表以NULL结尾。例子如下：```c++#include #include int main(int agrc, char argv[]){\tpid_t fpid;\tfpid = fork();\tif(fpid &lt; 0){\t\tprintf(“error in fork!/n”);\t}else if(fpid &gt; 0){\t\t//\t子进程调用其他程序\t\texecl(“./a.out”,”-a”,”100”,”-l”,NULL);\t\t//\t./a.out可执行文件的作用是输出命令行参数\t\tprintf(“子进程后面的部分不会再执行\\n”);\t}\treturn 0;}/ 输出传入的参数有 3 个传入的参数有：-a100-l*/2. 带p的exec函数，p表示使用path环境寻找可执行文件。如果参数file中包含/，则就将其视为路径名，否则将在PATH环境变量中寻找可执行文件。  例子如下：  ```c++#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void){\t//\t调用ps -l命令    if(execlp(\"ps\",\"ps\",\"-l\",NULL) == -1)    {        printf(\"execlp 调用失败\\n\");    }    printf(\"子进程后面的部分不会再执行\\n\");    return 0;}/* 输出F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 S  1006  51839  51838  0  80   0 -  5743 wait   pts/11   00:00:00 bash0 R  1006 136958  51839  0  80   0 -  7214 -      pts/11   00:00:00 ps*/execl和execlp的区别在于是否会到PATH环境变量中搜索文件，如果我们将上述程序改为execl，则会调用失败。例子如下：int main(void){\t//\t调用ps -l命令    if(execl(\"ps\",\"ps\",\"-l\",NULL) == -1)    {        printf(\"execl 调用失败\\n\");    }    printf(\"子进程后面的部分不会再执行\\n\");    return 0;}/* 输出execl 调用失败子进程后面的部分不会再执行*/  带v的exac函数，v表示使用参数的指针数组argv，然后将指针数组传入新程序的main函数中。同样地，最后一个元素必须是NULL。例子如下：    int main(void){ //\t调用ps -l命令 char* argv[] = {\"ps\",\"-l\", NULL}; if(execvp(\"ps\",argv) == -1) {     printf(\"execvp 调用失败\\n\"); } printf(\"子进程后面的部分不会再执行\\n\"); return 0;}/* 输出F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 S  1006  51839  51838  0  80   0 -  5743 wait   pts/11   00:00:00 bash0 R  1006 157028  51839  0  80   0 -  7214 -      pts/11   00:00:00 ps*/        带e的exec函数，e表示使用给定环境变量environ，而不使用PATH全局环境变量。此时我们需要传递一个指向环境字符串指针数组的指针。例子如下：首先我们编写一个echoenv.cpp文件，输出当前环境的环境变量//\techoenv.cpp文件#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;extern char** environ;\t\t//\t默认使用path环境int main(int argc , char *argv[]){    int i;    char **ptr;    for(ptr = environ;*ptr != 0; ptr++)        printf(\"%s\\n\",*ptr);\t//\t输出环境变量    return 0;}/* 输出XDG_SESSION_ID=3106TERM=xtermSHELL=/bin/bashSSH_CLIENT=172.31.72.187 59782 22SSH_TTY=/dev/pts/11MATLAB_HOME=/usr/local/matlab2019bUSER=zhangzfLIBVIRT_DEFAULT_URI=qemu:///systemMAIL=/var/mail/zhangzfPATH=/home/zhangzf/bin:/home/zhangzf/.local/bin:/opt/anaconda3/bin:/usr/local/matlab2019b/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/jdk1.8.0_212/bin:/home/yuancj/opt/module/flink-1.10.1/binPWD=/home/zhangzf/tmpJAVA_HOME=/opt/jdk1.8.0_212...*/接着我们传递一个环境变量数组的指针给execle函数，然后exec调用echoenv.cpp文件对应的可执行程序。int main(void){\tchar *env_init[] = {\"A1=123\",\"A2=b45\",NULL};    if(execle(\"./echoenv\",\"echoenv\",NULL,env_init) == -1)    {        printf(\"execle 调用失败\\n\");    }    printf(\"子进程后面的部分不会再执行\\n\");    return 0;}/* 输出A1=123A2=b45*/可见给定环境变量后，将不再使用PATH系统环境变量。总结      操作系统提供了fork的系统调用，可以创建一个新的进程    操作系统提供了exec族的系统调用，可以将当前进程替换成其他应用程序  Reference[1] 《深入解析高性能服务器编程》  [2] Linux系统——fork()函数详解[3] linux进程—exec族函数"
  },
  
  {
    "title": "刷题笔记 —— 找出游戏的获胜者",
    "url": "/posts/%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%83%9C%E5%88%A9%E8%80%85/",
    "categories": "leetcode",
    "tags": "leetcode, Queue, Formula",
    "date": "2023-04-27 19:58:00 +0800",
    





    
    "snippet": "队列/递推公式  该问题是著名的约瑟夫环问题，我们可以通过队列来模拟，也可以通过递推公式来得到结果。题目共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。游戏遵循如下规则：从...",
    "content": "队列/递推公式  该问题是著名的约瑟夫环问题，我们可以通过队列来模拟，也可以通过递推公式来得到结果。题目共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。游戏遵循如下规则：从第 1 名小伙伴所在位置 开始 。沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。否则，圈子中最后一名小伙伴赢得游戏。给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。例子示例1输入：n = 5, k = 2输出：3解释：游戏运行步骤如下：(1) 从小伙伴 1 开始。(2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。(3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。(4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。(5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。(6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。(7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。(8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。(9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。示例2输入：n = 6, k = 5输出：1解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。条件  1 &lt;= k &lt;= n &lt;= 500难点分析该题最简单的方法是采用循环队列进行模拟，直到最后一个人存活。其实这个问题是著名的约瑟夫环问题，最后的存活者是可以根据规律推导出来的。下面我们一步步推导出这个公式。我们假设有11个人轮流报数，报到3的人被淘汰，过程如下图所示：  第一轮：队头是1号，报数轮到3号，3号被淘汰  第二轮：队头是4号，报数轮到6号，6号被淘汰  第三轮：队头是7号，报数轮到9号，9号被淘汰  …  第九轮：队头是2号，报数轮到2号，2号被淘汰  最后存活者是7号根据上图我们可以发现一个规律，如果报数到3号被淘汰，那第二轮队头就是4，所以人的下标都会往前移动3位。也就是说，当前有11个人，如果下标为6的（编号为7）是最后的存活者，那下一轮10个人时，它的下标应该是3。因为编号为3的人淘汰了，编号为4的人变成队头，所以人对应下标都往前移动3位。那反过来，如果当前有10个人，最后的存活者下标为3，那上一轮11人，该存活者的下标为多少呢？答案是6，我们把被淘汰的第3个人补回来，那所有人的下标都要往后移动3位。位于最后的两个人需要移动到队头去，所以我们模上当前人数。现在我们把问题一般化，如果有n-1个人，最后的存活者下标为f(n-1,M)。那上一轮n个人，也就是需要把所有人的下标都往后移动m位，然后模n。也就是说该存活者下标为 f(n,m)= ( f(n-1,m) + m )% n。现在我们从头推起最后一轮，只剩最后一个人，那他就是存活者，即：  f(1,3) = 0倒数第二轮，还剩两个人，存活者的下标为：  f(2,3) = (f(1,3) + 3) % 2倒数第三轮，还剩三个人，存活者的下标为：  f(3,3) = (f(2,3) + 3) % 3…以此类推，我们得到递推公式：f(n,m)= ( f(n-1,m) + m )% n解法解法1：队列class Solution {public:    int findTheWinner(int n, int k) {        int *arr = new int[n];        for(int i = 0 ; i &lt; n ; i++){            arr[i] = i + 1;        }        //   life为当前生存人数，next为当前队首下标        int life = n, next = 0;            while(life != 1){            int t = (next + k - 1) % life;            for(int i = t + 1 ; i &lt; life ; i++){                arr[i - 1] = arr[i];            }            life--;            next = t  % life;        }        return arr[0];    }};解法2：递推公式class Solution {public:    int findTheWinner(int n, int k) {        int p = 0;        for (int i = 2 ; i &lt;= n ; i++){            p = (p + k) % i;        }        return p + 1;    }};Reference[1] 找出游戏的获胜者 [2] 约瑟夫环——公式法（递推公式）"
  },
  
  {
    "title": "读书笔记 —— 网络编程API_5",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BAPI_5/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, socket",
    "date": "2023-04-27 11:15:00 +0800",
    





    
    "snippet": "网络信息api  本节介绍了关于获取网络信息的一些api。对于我们只有域名的情况，我们可以通过gethostbyname系统调用来获取主机信息，从而实现socket连接。同样地，通过gethostbyaddr系统调用，也可以根据ip地址获得主机信息。对于端口对应的服务，我们可以通过getservbyname系统调用，传入服务名参数来获取具体的服务信息。也可以通过getservbyport系统...",
    "content": "网络信息api  本节介绍了关于获取网络信息的一些api。对于我们只有域名的情况，我们可以通过gethostbyname系统调用来获取主机信息，从而实现socket连接。同样地，通过gethostbyaddr系统调用，也可以根据ip地址获得主机信息。对于端口对应的服务，我们可以通过getservbyname系统调用，传入服务名参数来获取具体的服务信息。也可以通过getservbyport系统调用，传入端口号来获取具体的服务信息。getaddrinfo是整合了gethsotbyname和getservbyname函数的功能，可以传入主机名和服务名，获取具体的ip地址和端口号。反过来，我们已知ip地址和端口号，可以通过getnameinfo系统调用，获取对应的主机名和服务名。gethostbyname/gethostbyaddr在客户端某些场景中，我们可能只知道域名而不知道具体的ip地址，这时候需要通过一些网络信息api来获取主机信息。下面是gethostbyname和gethostbyaddr的系统调用，功能是通过域名或ip获取主机的完整信息，其函数原型如下：#include &lt;netdb.h&gt;struct hostent* gethostbyname(const char *name);struct hostent* gethostbyaddr(const void* addr, size_t len, int type);参数和返回值：  name：目标主机的域名  addr：目标主机的ip地址  len：目标主机的ip地址的长度  type：指定addr所指ip地址的协议类型，一般取值AF_INET(IPv4)或AF_INET6(IPv6)  返回值：主机的网络信息，存储在hostent结构体中hostent结构体定义如下：#include &lt;netdb.h&gt;struct hostend{  char *h_name;       //  主机名  char **h_aliases;   //  主机别名，可能有多个  int h_addrtype;     //  地址类型（地址族）  int h_length;       //  地址长度  char **h_addr_list; //  主机ip地址列表（网络字节序）};在调用gethostbyname之后，程序会现在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。getservbyname/getservbyport服务器中每个端口号都对应一项服务，我们可以通过getservbyname和getservbyport系统调用获取这些服务信息。它们实际上是通过读取/etc/services文件来获取服务的信息的。下面是getservbyname和getservbyport的系统调用，功能是根据服务名称或端口号获取某个服务的完整信息，其函数原型如下：#include &lt;netdb.h&gt;struct servent *getservbyname(const char *name, const char *proto);struct servent *getservbyport(int port, const char *proto);参数和返回值：  name：指定目标服务的名字  port：指定目标服务对应的端口号  proto：指定服务类型，取值tcp表示获取流服务，取值udp表获取数据报服务，取值NULL表示获取所有类型的服务  返回值：成功指定服务的完整信息，存储在servent结构体中servent结构体定义如下：#include &lt;netdb.h&gt;struct servent{  char *s_name;     //  服务名称  char **s_aliases; //  服务别名，可能有多个别名  int s_port;       //  端口号  char *s_proto;    //  服务类型，通常为tcp或udp};下面我们通过一个例子来获取目标服务器上的daytime服务，代码如下：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;int main(int argc, char *argv[]){\tassert(argc == 2);\tchar *host = argv[1];\tstruct hostent *hostinfo = gethostbyname(host);\tassert(hostinfo);\tstruct servent *servinfo = getservbyname(\"daytime\", \"tcp\");\tassert(servinfo);\tprintf(\"daytime port is %d\\n\", ntohs(servinfo-&gt;s_port));\tstruct sockaddr_in address;\taddress.sin_family = AF_INET;\taddress.sin_port = servinfo-&gt;s_port;\taddress.sin_addr = *(struct in_addr *)*hostinfo-&gt;h_addr_list;\tint sockfd = socket(AF_INET, SOCK_STREAM, 0);\tint result = connect(sockfd, (struct sockaddr *)&amp;address, sizeof(address));\tassert(result != -1);\t\tchar buffer[128];\tresult = read(sockfd, buffer, sizeof(buffer));\tassert(result &gt;= 0);\tbuffer[result] = '\\0';\tprintf(\"the day time is: %s\\n\", buffer);\tclose(sockfd);\treturn 0;}运行结果：$ ./getservbyname 127.0.0.1daytime port is 13the day time is: 27 APR 2023 15:28:33 CST   //  如果连接失败，可能是daytime服务没有开启  getservbyname、getservbyport、gethostbyname、gethostbyaddr函数是非线程安全的，netdb.h头文件提供了线程安全的版本（可重入的），这些版本的函数名在原函数名尾部加上_r(re_entrant)getaddrinfogetaddrinfo函数技能通过主机名获得IP地址（内部调用gethostbyname函数），也可以通过服务名获得端口号（内部调用getservbyname函数）。下面是getaddrinfo的系统调用，功能是通过主机名获取IP地址或通过服务名获取端口号，其函数原型如下：#include &lt;netdb.h&gt;int getaddrinfo(const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result);参数和返回值：  hostname：可以传入主机名，也可以传入字符串表示的IP地址  service：可以传入服务名，也可以传入字符串表示的十进制端口号  hints：应用程序用来对getaddrinfo的输出进行更精确的控制，可以设置为NULL，表示应用程序允许getaddrinfo反馈任何有用的结果  result：指向一个链表，该链表存储getaddrinfo反馈的结果  返回值：成功返回0，失败返回错误码，错误码如下表所示            错误码      含义                  EAI_AGAIN      调用临时失败，提示应用程序过后再试              EAI_BADFLAGS      非法的ai_flags值              EAI_FAIL      名称解析失败              EAI_FAMILY      不支持的ai_family参数              EAI_MEMORY      内存分配失败              EAI_NONAME      非法的主机名或服务名              EAI_OVERFLOW      用户提供的缓冲区溢出，仅发生在getnameinfo调用中              EAI_SERVICE      没有支持的服务，比如用数据报类型来查找ssh服务，而ssh只有流服务              EAI_SOCKTYPE      不支持的服务类型，如果hints.ai_socktype和hints.ai_protocol不一致，比如前者指定SOCK_DGRAM，而后者指定IPROTO_TCP，则会触发该类错误              EAI_SYSTEM      系统错误，错误值存储在errno中        在Linux中，可以通过strerror函数将错误码errno转化为易读的字符串形式，而netdb.h中也提供了类似功能的函数，将错误码转换为字符串形式，函数定义如下：  #include &lt;netdb.h&gt;const char *gai_strerror(int error);  getaddrinfo反馈的每一条结果都用addrinfo结构体存储，addrinfo结构体的定义如下：struct addrinfo{  int ai_flags;             //  取值和含义见下表  int ai_family;            //  地址族  int ai_socktype;          //  服务类型：SOCK_STREAM或SOCK_DGRAM  int ai_protocol;          //  具体的网络协议，和socket()系统调用第三个参数相同，通常取0  socklen_t ai_addrlen;     //  socket地址ai_addr的长度  char *ai_canonname;       //  主机别名  struct sockaddr *ai_addr; //  指向socket地址  struct addrinfo *ai_next; //  指向下一个sockinfo结构体的对象};ai_flags的取值和含义如下表，它可以通过按位或的方式组合多个选项。            选项      含义                  AI_PASSIVE      在hints参数中设置，表示调用者是否会将取得的socket地址用于被动打开。服务器通常需要设置它，表示接受任何本地socket地址上的服务请求。客户端不能设置它              AI_CANONNAME      在hints参数中设置，告诉getaddrinfo函数返回主机的别名              AI_NUMERICHOST      在hints参数中设置，告诉hostname必须是用字符串表示的ip地址，避免DNS查询              AI_NUMERICSERV      在hints参数中设置，强制service参数使用十进制端口号的字符串形式，不能使用服务名              AI_V4MAPPED      在hints参数中设置，如果ai_family被设置为AF_INET6，那么当没有满足条件的IPv6地址被找到是，将IPv4地址映射得到IPv6地址              AI_ALL      必须和AI_V4MAPPED同时使用，否则被忽略。表示同时返回符合条件的IPv6地址以及由IPv4地址映射得到的IPv6地址              AI_ADDRCONFIG      仅当至少配置由一个IPv4地址（除了回路地址）时，才返回IPv4地址信息。同理，仅当至少配置由一个IPv6地址（除了回路地址）时，才返回IPv6地址信息。它和AI_V4MAPPED是互斥的      当我们使用hints参数时，ai_flags、ai_family、ai_socktype和ai_protocol这四个字段是可以设置的，其他字段必须设置为NULL。下面我们通过一个例子来获取主机ernest-laptop上的daytime服务：struct addrinfo hints;struct addrinfo *res;bzero(&amp;hints, sizeof(hints));hints.ai_socktype = SOCK_STREAM;getaddrinfo(\"ernest-laptop\", \"daytime\", &amp;hints, &amp;res);注意，上述代码中res返回一个存储结果的链表，也就是说getaddrinfo会隐式分配堆内存，所以在结束调用后，我们需要手动释放这块内存。释放内存采用freeaddrinfo函数，其函数定义如下：#include &lt;netdb.h&gt;void freeaddressinfo(struct addrinfo *res);getnameinfogetaddrinfo是通过主机名和服务名来获取ip及端口信息，而getnameinfo反过来通过ip及端口号来获取主机名和服务名信息。其中获取主机名是通过内部调用gethostbyaddr函数，获取服务名是通过内部调用getservbyport函数。下面是getnameinfo的系统调用，功能是通过socket地址获取主机名和服务名，其函数原型如下：#include &lt;netdb.h&gt;int getnameinfo(const struct sockaddr * sockaddr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);参数和返回值：  sockaddr：socket信息，包括ip地址和端口号  host：目标socket的主机名  hostlen：存储主机名的缓存长度  serv：目标socket的服务名  servlen：存储服务名的缓存长度  flags：精确控制getnameinfo行为，具体取值和含义见下表  返回值：成功返回0，失败返回错误码，错误码与getaddrinfo调用的返回值相同flags参数的取值及其含义如下表所示：            选项      含义                  NI_NAMEREQD      如果通过socket地址不能获得主机名，则返回一个错误              NI_DGRAM      返回数据报服务，大部分同时支持流和数据报的服务使用相同的端口号来提供这两种服务。但端口512-514例外。比如TCP的514端口提供shell登录服务，而upd的514端口提供syslog服务              NI_NUMERICHOST      返回字符串表示的IP地址，而不是主机名              NI_NUMERICSERV      返回字符串表示的十进制端口号，而不是服务名              NI_NOFQDN      仅返回主机域名的第一部分。比如对主机名nebula.testing.com，getnameinfo只将nebula写入host缓存中      总结      网络编程接口提供了gethostbyname和gethostbyaddr的系统调用，通过域名或ip获取主机的完整信息    网络编程接口提供了getservbyname和getservbyport的系统调用，通过服务名称或端口号获取某个服务的完整信息    网络编程接口提供了getaddrinfo的系统调用，通过主机名获取IP地址或通过服务名获取端口号    网络编程接口提供了getnameinfo的系统调用，功能是通过socket地址获取主机名和服务名  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程API_4",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BAPI_4/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, socket",
    "date": "2023-04-25 20:09:00 +0800",
    





    
    "snippet": "地址信息函数/socket选项  本节介绍了在某些场景中，程序可以通过getsockname和getpeername系统调用来获取本端和远端的socket地址信息。接下来我们介绍了程序可以通过setsockopt和getsockopt修改或读取socket选项。我们列出了socket选项的值及其含义。其中，SO_REUSEADDR可以使服务端关闭连接后立即释放端口，便于我们重启服务器并重用原...",
    "content": "地址信息函数/socket选项  本节介绍了在某些场景中，程序可以通过getsockname和getpeername系统调用来获取本端和远端的socket地址信息。接下来我们介绍了程序可以通过setsockopt和getsockopt修改或读取socket选项。我们列出了socket选项的值及其含义。其中，SO_REUSEADDR可以使服务端关闭连接后立即释放端口，便于我们重启服务器并重用原来的端口。SO_RCVBUF和SO_SNDBUF选项用于控制TCP接收缓冲区和发送缓冲区的大小。SO_RCVLOWAT和SO_SNDLOWAT选项用于控制TCP接收缓冲区和发送缓冲区的低水位标记。SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。getsockname/getpeername由于客户端可以不调用bind绑定ip地址和端口，由操作系统自动分配，所以当我们想要知道系统分配的ip地址和端口时，可以使用getsockname系统调用得到本端的socket地址信息。 而getpeername可以获取远端的socket地址信息，一般用于某个进程accpet之后，又调用了exec执行程序的场景。如下图所示：inetd进程执行accept调用，获得客户端(远端)的socket地址信息。接着fork子进程，由于没有写入之前，子进程和父进程是同一个内存映射，所以子进程也可以访问远端的socket地址信息。然而当子进程调用exec执行程序，子进程的内存就会被替换为新的内存。这时，socket描述符依然可以跨exec传递，但是如果要获取远端的socket地址信息，必须通过getpeername调用获得。下面是getsockname和getpeername的系统调用，功能是获取本端或远端的socket地址信息，其函数原型如下：#include &lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr *address, socklen_t *address_len);int getpeername(int sockfd, struct sockaddr *address, socklen_t *address_len);参数和返回值：  sockfd：getsockname传入本端的socket文件描述符，getpeername传入远端的socket文件描述符  address：获取目标socket地址  address_len：目标socket地址的长度，如果实际内存长度大于该值，会被截断  flags：读/写函数的额外控制选项，具体取值如下表所示，通常设为0  返回值：成功返回0，失败则返回-1并设置errnogetsockopt/setsockoptsocket有许多的参数和选项，网络编程接口提供了getsockopt和setsockopt两个系统调用，通过socket文件描述符来读取和修改这些选项信息。下面是getsockname和getpeername的系统调用，功能是读取或修改socket选项，其函数原型如下：#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int option_name, void *option_value, socklen_t *restrict option_len);int setsockopt(int sockfd, int level, int option_name, const void *option_value, socklen_t *option_len);参数和返回值：  sockfd：socket的文件描述符  level：指定要操作哪个协议的选项  option_name：选项名  option_value：选项参数值  option_len：选项参数值的长度  返回值：成功返回0，失败则返回-1并设置errnolevel及选项的取值如下表所示：  level = SOL_SOCKET (通用socket选项，与协议无关)            option_name      数据类型      说明                  SO_DEBUG      int      打开调试信息              SO_REUSEADDR      int      重用本地地址              SO_TYPE      int      获取socket类型              SO_ERROR      int      获取并取出socket错误状态              SO_DONTROUTE      int      不查看路由表，直接将数据发送给本地局域网内的主机，含义和send系统调用的MSG_DONTROUTE标志类似              SO_RCVBUF      int      TCP接收缓冲区大小              SO_SNDBUF      int      TCP发送缓冲区大小              SO_KEEPALIVE      int      发送周期性保活报文以维持连接              SO_OOBINLINE      int      接收到的带外数据将存留在普通数据的输入队列中（在线存留），此时我们不能使用带MSG_OOB标志的读操作来读取带外数据，而应该像读取普通数据那样读取带外数据              SO_LINGER      linger      若有数据待发送，则延迟关闭              SO_RCVLOWAT      int      TCP接收缓冲区低水位标记              SO_SNDLOWAT      int      TCP发送缓冲区低水位标记              SO_RCVTIMEO      timeval      接收数据超时              SO_SNDTIMEO      timeval      发送数据超时        level = IPPROTO_IP (IPv4选项)            option_name      数据类型      说明                  IP_TOS      int      服务类型              IP_TTL      int      存活时间        level = IPPROTO_IPV6 (IPv4选项)            option_name      数据类型      说明                  IPV6_NEXTHOP      sockaddr_in6      下一跳ip地址              IPV6_RECVPKTINFO      int      接收分组信息              IPV6_DONTFRAG      int      禁止分片              IPV6_RECVTCLASS      int      接收通信类型        level = IPPROTO_TCP (TCP选项)            option_name      数据类型      说明                  TCP_MAXSEG      int      TCP最大报文段大小              TCP_NODELAY      int      禁止Nagle算法      对于服务器而言，有些socket选项只能在调用listen系统调用前对监听socket设置才生效。这是因为连接socket由accept调用返回，而accpet从listen监听队列中获取的连接至少完成了TCP三次握手的前两次握手这说明服务器已经发送了TCP同步报文段。而有些socket选项需要在TCP同步报文段中设置，比如TCP最大报文段选项。当我们在监听socket中设置这些选项，accept返回的连接socket也会自动继承这些选项。这些选项包括：SO_DEBUG, SO_DONTROUTE, SO_KEEPALIVE, SO_LINGER, SO_OOBINLINE, SO_RCVBUF, SO_RCVLOWAT, SO_SNDBUF, SO_SNDLOWAT, TCP_MAXSEG, TCP_NODELAY。同理，客户端中，这些socket选项需要在调用connect函数之前设置，因为connect调用成功返回后，TCP三次握手已完成。SO_REUSEADDRSO_REUSEADDR选项是允许服务端程序立即重用本地的socket地址。用例如下：int sock = socket(PF_INET, SOCK_STREAM, 0);int reuse = 1;setsockopt(sock, SOL_SOCKET, SO_REUSERADDR, &amp;reuse, sizeof(reuse));...首先我们来介绍一下TIME_WAIT状态：如图所示，当客户端将要断开连接，向服务端发送确认报文段过后，并没有直接进入CLOSED状态，而是进入了TIME_WAIT状态。TIME_WAIT状态是指客户端程序要等待2MSL(Maximum Segment Life，报文段最大生存时间)的时间，才能完全关闭连接。存在TIME_WAIT状态的原因有以下两点：  可靠地终止TCP连接如上图所示，如果客户端发送的报文段7丢失了，那么服务器将重发报文段6。这时候客户端应该停留在TIME_WAIT状态一段时间，以处理重复收到的报文段6。  保证让迟来的TCP报文段有足够的时间被识别并丢弃如果TCP连接没有经过TIME_WAIT状态而直接关闭，当我们立即发起新的连接（新的连接与原来的连接有相同的socket），新的连接可能接收到原来的连接迟到的TCP报文段。这显然会导致数据出错，所以我们令TCP连接关闭后先处于TIME_WAIT状态，此时该连接占用的端口无法被使用。由于TCP报文段的最大生存时间为MSL，考虑到往返，所以只要坚持2MSL时间的TIME_WAIT状态，就能确保迟到的TCP报文段都被路由器丢弃。新的连接也能在2MSL时间之后安全建立，而绝对不会收到原来的连接的数据。一般来说，客户端的端口是由操作系统随机分配的，所以新建立的连接不会和上次连接的端口（处于TIME_WAIT状态的端口）相同。但是服务端总是用同一个端口号，在某些场景下，我们可能需要立即重启服务器，但是TIME_WAIT状态占用的端口会导致重启失败。这时我们可以用SO_REUSEADDR选项来跳过TIME_WAIT状态，从而立即重用socket地址。  我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使TCP连接根本不会进入TIME_WAIT状态。SO_RCVBUF和SO_SNDBUF选项SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送缓冲区的大小。不过当我们用setsockopt设置TCP和接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。例如TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是2048字节（不同系统有不同的默认最小值）。这样做的原因是确保TCP连接有足够的空闲缓冲区处理拥塞（例如快速重传算法就期望TCP连接缓冲区能至少容纳4个大小为SMSS的TCP报文段）。  我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制取消TCP接收缓冲区和发送缓冲区的最小值限制。下面是修改服务端TCP接收缓冲区大小的例子int sockfd = socket(PF_INET, SOCK_STREAM, 0);assert(sockfd &gt;= 0);int recvbuf = 50;       //  将接收缓冲区大小改为50int len = sizeof(recvbuf);//  修改接收缓冲区大小setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, sizeof(recvbuf));//  修改后我们重新读取接收缓冲区大小getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, (socklen_t *)&amp;len);cout&lt;&lt; \"the tcp receive buffer size after setting is \"&lt;&lt;recvbuf&lt;&lt;endl;//  输出结果： the tcp receive buffer size after setting is 2304可以看到接收缓冲区大小的最小值限制是2304字节。下面我们再查看修改发送缓冲区的例子：int sockfd = socket(PF_INET, SOCK_STREAM, 0);assert(sockfd &gt;= 0);int sendbuf = 2048;     // 设置发送缓冲区的大小为2048 int len = sizeof(sendbuf);//  修改发送缓冲区大小setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, sizeof(sendbuf));//  修改后我们重新读取发送缓冲区大小getsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, (socklen_t *)&amp;len);cout&lt;&lt; \"the tcp send buffer size after setting is \"&lt;&lt;sendbuf&lt;&lt;endl;//  输出结果： the tcp send buffer size after setting is 4608可以看到发送缓冲区的大小翻了一倍。SO_RCVLOWAT和SO_SNDLOWAT选项SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记。当TCP接收缓冲区中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据。当TCP发送缓冲区中的空闲空间大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写入数据。默认情况下，TCP接收缓冲区和发送缓冲区的低水位标记都是1字节。SO_LINGER选项SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该sokcet对应的TCP缓冲区中残留的数据发送出去。我们可以通过修改SO_LINGER选项的值来修改这种行为，此时我们需要给setsockopt系统调用传递一个linger类型的结构体，结构体定义如下：#include &lt;sys/socket.h&gt;struct linger{    int l_onoff;    //  是否开启该选项，0关闭，非0开启    int l_linger;   //  滞留时间}这两个成员变量不同的取值对应的行为如下：  l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为关闭socket  l_onoff不等于0，l_linger等于0。此时close系统调用立即返回，且丢弃对应的TCP发送缓冲区中的残留数据，同时给对方发送一个复位报文段。这种情况给服务器提供了异常终止一个连接的方法。  l_onoff不等于0，l_linger大于0。这时分为两种情况：          如果socket是阻塞的，close将会等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据或没有得到对方确认，close将会返回-1并设置errno为EWOULDBLOCK      如果socket是非阻塞的，close将立即返回，此时我们根据close的返回值和errno来判断残留数据是否已经发送完毕      总结      网络编程接口提供了getsockname和getpeername的系统调用，可以获取本端或远端的socket地址信息    网络编程接口提供了getsockopt和setsockopt的系统调用，通过socket文件描述符来读取和修改socket选项    SO_REUSEADDR选项是允许服务端程序立即重用本地的socket地址    SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送缓冲区的大小    SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记    SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为  Reference[1] 《深入解析高性能服务器编程》  [2] UNP编程：05—地址获取函数"
  },
  
  {
    "title": "刷题笔记 —— 使数组按非递减顺序排列",
    "url": "/posts/%E4%BD%BF%E6%95%B0%E7%BB%84%E6%8C%89%E9%9D%9E%E9%80%92%E5%87%8F%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97/",
    "categories": "leetcode",
    "tags": "leetcode, LinkList, Monotonic Stack",
    "date": "2023-04-25 14:57:00 +0800",
    





    
    "snippet": "链表/单调栈  该问题是迭代地使数组成为非递减顺序，由于时间限制，不能用N次迭代的方式解决。该问题的解法分为两种，一种是通过链表模拟，多点向后推进。另一种方法是用单调栈记录前一个最大元素的状态题目给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] &gt; nums[i] 的 nums[i] ，其中 0 &lt; i &lt; nums.len...",
    "content": "链表/单调栈  该问题是迭代地使数组成为非递减顺序，由于时间限制，不能用N次迭代的方式解决。该问题的解法分为两种，一种是通过链表模拟，多点向后推进。另一种方法是用单调栈记录前一个最大元素的状态题目给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] &gt; nums[i] 的 nums[i] ，其中 0 &lt; i &lt; nums.length 。重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。例子示例1输入：nums = [5,3,4,4,7,3,6,11,8,5,11]输出：3解释：执行下述几个步骤：- 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]- 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]- 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11][5,7,11,11] 是一个非递减数组，因此，返回3。示例2输入：nums = [4,5,7,7,13]输出：0解释：nums 已经是一个非递减数组，因此，返回0。条件  1 &lt;= nums.length &lt;= 10^5  1 &lt;= nums[i] &lt;= 10^9难点分析该题难点在于：(1)数组通过N次迭代获得结果，如果我们也通过N次迭代模拟程序行为，则会超时，这就要求我们需要在O(n)时间内计算出结果；(2)例如[4,14,13,2,6,13],14会吞噬13，而13会吞噬2，如果从左往右一次判断，可能错误认为14通过两次吞噬消除13和2；(3)例如[10,1,2,3,4,5,6,1,2,3]，10吞噬6次，而最后三个元素是6吞噬的，这要求我们记录每个元素吞噬次数的结果。但由于迭代过程数组下标会发生变化，吞噬次数的中间结果记录比较困难。该问题提出两种解法，首先介绍最优的单调栈解法。我们以示例一[5,3,4,4,7,3,6,11,8,5,11]为例，红色部分对应最后的结果，即最后得到的非递减数组[5,7,11,11]。我们可以发现以下规律：  每一次迭代对应元素就会被删除，也就是说迭代的次数等价于元素被删除的最大次数  一个元素如果被吞噬，则最终会被左边最大的元素吞噬  如果当前元素大于左边所有元素，那右边的所有元素都不会被左边的元素吞噬，也就是说左边的删除次数不需要再计算受到启发，单调栈存储左边的元素，而且保证左边元素是当前遇到最大的(5)。当我们遇到第二个红色的元素(7)时。由于右边元素不会被左边的元素吞噬，也就是元素7之前的吞噬次数我们是可以确定的。所以出栈进行计算。然后把当前最大的元素(7)入栈。如果接下来的元素都比它小，吞噬次数不断加1。以此类推，直到遍历完整个数组。我们可以看到，[5,3,4,4,7,3,6,11,8,5,11]中，遍历元素3,4,4时，只要栈中还有元素，说明前面有更大的元素(5)，这些元素都会被吞噬，所以依次出栈，且吞噬次数等于上一个元素的吞噬次数加1。第二种解法是链表模拟。第一步我们先找出可以吞噬的候选元素，如下图所示：我们用数组next来代替链表中的next指针。每个候选元素都模拟吞噬行为向右移动一步，如下图所示：对于每个候选元素而言：  要么它吞噬掉后续元素，那么我们将当前元素的next指向下个元素  要么它被其他元素吞噬，我们用一个数组rem标识是否被吞噬吞噬掉后续元素的集合进行下轮吞噬，直到没有发生任何吞噬行为，说明此时已经是非递减数组。最后我们进行了多少轮吞噬，即为结果迭代次数。原始的迭代方案会从头到尾判断是否能进行吞噬，非递减元素会遍历N次。相比之下，该解法每一个元素只经历了一次吞噬（删除），不会重复判断非递减元素。解法解法1：单调栈class Solution {public:    int totalSteps(vector&lt;int&gt;&amp; nums) {        int res = 0, f[nums.size()];        stack&lt;int&gt; st;        for(int i = 0; i &lt; nums.size(); ++i) {            int cur = 0;            //  如果遇到比栈中元素更大的元素，说明需要进行清算(出栈)            while(st.size() &amp;&amp; nums[st.top()] &lt;= nums[i]) {                cur = max(cur, f[st.top()]);                st.pop();            }            //  如果栈中有值，说明左边有更大的元素可以吞噬当前元素，所以吞噬次数+1            if(st.size()) {                res = max(res, cur + 1);                f[i] = cur + 1;            }            st.push(i);        }        return res;    }};解法2：链表模拟class Solution {public:    int totalSteps(vector&lt;int&gt;&amp; nums) {        nums.push_back(1e9 + 8);    //  方便处理边界        vector&lt;int&gt; next;        vector&lt;int&gt; cur;        vector&lt;int&gt; rem;        //  next数组记录当前元素nums[i]指向的下一个元素，模拟链表行为        //  rem数组表示当前元素nums[i]是否被吞噬        for(int i = 0 ; i &lt; nums.size() ; i++){            next.emplace_back(i + 1);            rem.emplace_back(1);        }                //  先筛选一次候选元素，缩小搜索范围        for(int i = nums.size() - 2 ; i &gt;= 0 ; i--){            if(nums[i] &gt; nums[i + 1]){                cur.emplace_back(i);            }        }                for(int res = 0;; ++res){            vector&lt;int&gt; tmp;            for(auto &amp;i : cur){                //  如果候选元素可用且可以吞噬下一个元素，则更新信息并加入下一轮吞噬                if(rem[i] &amp;&amp; nums[i] &gt; nums[next[i]]){                    //  next[i]已经被吞噬了，设置为不可用状态                    rem[next[i]] = 0;                    //  模拟链表将next指针指向下一个元素                    next[i] = next[next[i]];                    //  加入下一轮吞噬                    tmp.emplace_back(i);                }            }            //  如果这一轮候选元素没有吞噬任何值，则返回结果            if(tmp.size()){                tmp.swap(cur);            }else{                return res;            }        }        return -1;    }};Reference[1] 使数组按非递减顺序排列 [2] 最优解：单调栈 | 次优解：单链表模拟 + 优化"
  },
  
  {
    "title": "读书笔记 —— 网络编程API_3",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BAPI_3/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, socket",
    "date": "2023-04-22 20:27:00 +0800",
    





    
    "snippet": "recv/send  本节主要介绍了网络编程接口中服务端和客户端之间读/写相关的系统调用。首先socket是一个文件，所以文件操作相关的函数（如read/write）也可以直接用于socket中。但是socket编程接口提供了专门的读写调用，它们相比原始的读/写函数提供了对数据的读写控制。针对UDP数据报，网络编程接口提供了一对recvfrom/sendto系统调用。网络编程还提供了通用的读...",
    "content": "recv/send  本节主要介绍了网络编程接口中服务端和客户端之间读/写相关的系统调用。首先socket是一个文件，所以文件操作相关的函数（如read/write）也可以直接用于socket中。但是socket编程接口提供了专门的读写调用，它们相比原始的读/写函数提供了对数据的读写控制。针对UDP数据报，网络编程接口提供了一对recvfrom/sendto系统调用。网络编程还提供了通用的读写调用recvmsg/sendmsg。recv/send在服务端和客户端成功建立连接后，可以通过文件读写的api(read/write)对socket进行读写操作。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，这些系统调用相比原始的read/write，增加了对数据读写的控制。下面是recv和send的系统调用，功能是对流数据进行读/写，然后发送到网络或从网络中接受，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t send(int sockfd, const void *buf, size_t len, int flags);参数和返回值：  sockfd：socket的文件描述符  buf：读缓冲区/写缓冲区  len：缓冲区长度  flags：读/写函数的额外控制选项，具体取值如下表所示，通常设为0  返回值：revc成功时返回实际读到的数据长度，当通信对方关闭连接时返回0，如果失败则返回-1并设置errno；send成功时返回实际写入的数据长度，失败则返回-1并设置errno            选项名      含义      send      recv                  MSG _CONFIRM      指示数据链路层协议持续监听对方的回应，直到得到答复。仅适用于SOCK_DGRAM和SOCK_RAW类型的socket      Y      N              MSG_DONTROUTE      不查看路由表，总结将数据发送给本地局域网内的主机。这表示发送者确切地知道目标主机在本地网络上      Y      N              MSG_DONTWAIT      对socket的此次操作是非阻塞的      Y      Y              MSG_MORE      告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送。这样可以防止TCP发送过多短报文段，提供传输效率      Y      N              MSG_WAITALL      读操作仅在读取到指定数量的字节后才返回      N      Y              MSG_PEEK      窥探读缓存中的数据，此次读操作不会导致这些数据被清除      N      Y              MSG_OOB      发送或接受紧急数据      Y      Y              MSG_NOSIGNAL      往读端关闭的管道或socket连接中写数据时不引用SIGPIPE信号      Y      N      flags参数可以取上面某个选项，也可以通过或的形式取多个选项。下面以MSG_OOB为例展示如何使用这些参数：//  服务端代码#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;iostream&gt;#define BUF_SIZE 1024using std::cout;using std::endl;int main(int argc, char *argv[]){\tconst char *ip = argv[1];\tint port = atoi(argv[2]);\t\tstruct sockaddr_in address;\tbzero(&amp;address, sizeof(address));\taddress.sin_family = AF_INET;\tinet_pton(AF_INET, ip, &amp;address.sin_addr);\taddress.sin_port = htons(port);\t\tint sockfd = socket(PF_INET, SOCK_STREAM, 0);\tassert(sockfd &gt;= 0);\t\tint ret = bind(sockfd, (struct sockaddr*)&amp;address, sizeof(address));\tassert(ret != -1);\t\tret = listen(sockfd, 5);\tassert(ret != -1);\t\tstruct sockaddr_in client;\tsocklen_t client_addrlength = sizeof(client);\tint connfd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;client_addrlength);\tif(connfd &lt; 0)\t{\t\tcout&lt;&lt;\"errno is :\" &lt;&lt; errno &lt;&lt; endl;\t}\telse\t{\t\tchar buffer[BUF_SIZE];\t\t\t\tmemset(buffer, '\\0', BUF_SIZE);\t\tret = recv(connfd, buffer, BUF_SIZE - 1, 0);\t\tcout&lt;&lt; \"got \" &lt;&lt; ret &lt;&lt; \"bytes of normal data \" &lt;&lt; buffer &lt;&lt;endl;\t\t\t\tmemset(buffer, '\\0', BUF_SIZE);\t\tret = recv(connfd, buffer, BUF_SIZE - 1, MSG_OOB);\t\tcout&lt;&lt; \"got \" &lt;&lt; ret &lt;&lt; \"bytes of oob data \" &lt;&lt; buffer &lt;&lt;endl;\t\t\t\tmemset(buffer, '\\0', BUF_SIZE);\t\tret = recv(connfd, buffer, BUF_SIZE - 1, 0);\t\tcout&lt;&lt; \"got \" &lt;&lt; ret &lt;&lt; \"bytes of normal data \" &lt;&lt; buffer &lt;&lt;endl;\t\t\t\tclose(connfd);\t}\t\tclose(sockfd);\treturn 0;}//  客户端代码#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using std::cout;using std::endl;int main(int argc, char *argv[]){\tconst char *ip = argv[1];\tint port = atoi(argv[2]);\t\tstruct sockaddr_in server_address;\tbzero(&amp;server_address, sizeof(server_address));\tserver_address.sin_family = AF_INET;\tinet_pton(AF_INET, ip, &amp;server_address.sin_addr);\tserver_address.sin_port = htons(port);\t\tint sockfd = socket(PF_INET, SOCK_STREAM, 0);\tassert(sockfd &gt;= 0);\tif(connect(sockfd, (struct sockaddr *)&amp;server_address, sizeof(server_address)) &lt; 0){\t\tcout&lt;&lt;\"connection failed\"&lt;&lt;endl;\t}\telse{\t\tconst char *obb_data = \"abc\";\t\tconst char *normal_data = \"123\";\t\tsend(sockfd, normal_data, strlen(normal_data), 0);\t\tsend(sockfd, obb_data, strlen(obb_data), MSG_OOB);\t\tsend(sockfd, normal_data, strlen(normal_data), 0);\t}\tclose(sockfd);\treturn 0;}输出结果如下所示：$ g++ recv.cpp -o recv$ g++ send.cpp -o send$ ./recv 127.0.0.1 12345$ ./send 127.0.0.1 12345got 5bytes of normal data 123abgot 1bytes of oob data cgot 3bytes of normal data 123这里使用了MSG_OOB(out of band)的参数，意思是可以让报文携带紧急信息，立即发送出去，不论发送缓冲区中是否有排队等待发送的普通数据。在TCP中，紧急数据是通过映射到普通数据的传输实现的。TCP在待发送的报文段头部设置URG标志，然后将紧急指针指向最后一个带外数据的下一个字节，如下图所示：当发送端一次发送了多字节的带外数据时，只有最后一个字节会被当作带外数据（字母c），其他数据（字母a和b）会被当作普通数据。当TCP接收端在接受时检查到紧急指针标志时，会检查紧急指针，根据紧急指针所指的位置确定带外数据的位置，然后将带外数据读入特殊的缓存中。这个缓存只有1字节，称为带外缓存。这也解释了为什么上述输出结果带外数据只有c。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据会覆盖它。并且带外数据会截断报文，即如果发送没有带外数据abc，两次send发送的正常数据123是可以被一个recv调用全部读取的。我们获取刚刚发送的报文：IP 127.0.0.1.60460 &gt; 127.0.0.1.12345: Flags [P.U], seq 4:7, ack 1, win 92, urg 3, options [nop,nop,TS val 102794322 ecr 154703423]，length 3我们可以看到Flags设置了紧急标志U，urg 3是紧急偏移值，它指出紧急指针的位置是7（3+4，4是TCP报文段的序号值相对于初始序号值的偏移）。所以带外数据是字节流的第6个字节，即字符’c’。  这里的flags参数只对当前调用的send/recv有效，后面章节我们将探讨如何通过setsockopt调用永久修改socket的某些属性  我们可以通过sockatmark系统调用判断读取的数据是否是带外数据，函数原型如下：#include &lt;sys/socket.h&gt;int sockatmart(int sockfd);如果读取的数据携带带外数据，则返回1，然后返回0。UDP数据读写socket编程接口还提供了UDP数据报的读写调用。下面是recvfrom和sendto的系统调用，它是用于UDP数据报的读写系统调用，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t *addrlen);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t *addrlen);参数和返回值：  sockfd：socket的文件描述符  buf：读缓冲区/写缓冲区  len：缓冲区长度  flags：读/写函数的额外控制选项，取值与recv/send的flags参数相同  src_addr/dest_addr：由于UDP没有连接的概念，所以每次读写数据都要发送端或接收端的socket地址  addrlen：发送端或接收端的socket地址的长度  返回值：recvfrom成功时返回实际读到的数据长度，如果失败则返回-1并设置errno；sendto成功时返回实际写入的数据长度，失败则返回-1并设置errno该调用也可以用于面向连接（TCP）的socket数据读写，此时后面两个参数设置为NULL，表示忽略发送端/接收端的socket地址（因为建立连接时已经知道双方的socket地址了）通用数据读写函数socket编程接口还提供了一对通用的数据读写系统调用，它们既可以用于TCP流数据，也可以用于UDP数据报。下面是recvmsg和sendmsg的系统调用，它是通用的数据读写系统调用，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);参数和返回值：  sockfd：socket的文件描述符  msg：  flags：读/写函数的额外控制选项，取值与recv/send的flags参数相同  返回值：recvmsg成功时返回实际读到的数据长度，如果失败则返回-1并设置errno；sendmsg成功时返回实际写入的数据长度，失败则返回-1并设置errnomsghdr结构体类型的具体定义如下：struct msghdr{    void *msg_name;             //  socket地址    socklen_t msg_namelen;      //  socket地址的长度    struct iovec *msg_iov;      //  分散的内存块    int msg_iovlen;             //  分散内存块的数量    void *msg_control;          //  指向辅助数据的起始位置    socklen_t msg_controllen;   //  辅助数据的大小    int msg_flags;              //  赋值函数中的flags参数，并在调用过程中更新};其中msghdr结构体各变量含义如下：  msg_name：指向一个socket地址结构体变量，指定通信对方的socket地址。但是在面向连接的TCP协议中没有意义，需设置为NULL  msg_namelen：指定了msg_name所指socket地址的长度  msg_iov： iovec结构体类型的数组，该结构体存放读写数据的内存信息，结构体定义如下所示  msg_iovlen：msg_iov数组的长度  msg_control：指向辅助数据的起始地址，用于实现在进程间传递文件描述符  msg_controllen：辅助数据的大小  msg_flags：该成员无须定义，它会赋值recvmsg/sendmsg的flags参数，在recvmsg调用结束前，会将某些更新的标志设置到msg_flags中iovec结构体的具体定义如下：struct iovec{    void *iov_base;     //  内存起始地址    size_t iov_len;     //  这块内存的大小}iovec结构体封装了一块内存的起始位置和大小。对于revcmsg，数据将被读取，并存放在msg_iov所指的分散的内存中，这称为分散读(scatter read)。对于sendmsg，msg_iov所指的分散的内存块中的数据会被一并发送，这称为集中写(gather write)。总结      socket编程接口提供了用于TCP流数据读写的系统调用recv和send    socket编程接口提供了用于UDP数据报读写的系统调用recvfrom和sendto    socket编程接口提供了一对通用的数据读写系统调用recvmsg和sendmsg，既可以用于TCP流数据，也可以用于UDP数据报    原始的文件读写调用read和write也可用于sockfd，但socket编程接口提供了专门用于socket数据读写的系统调用，相比原始的读写调用，提供了更精细的控制功能  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程API_2",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BAPI_2/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, socket",
    "date": "2023-04-21 20:23:00 +0800",
    





    
    "snippet": "socket/bind/listen/accept/connect/close/shutdown  本节主要介绍了网络编程中用到的一些api。连接开始之前，我们需要创建一个socket，它是一个文件描述符，保存了地址、协议、端口等信息，我们需要用这个socket来标识连接。我们通过socket系统调用创建socket后，再通过bind系统调用将socket和地址值进行绑定。接着，服务端需要通...",
    "content": "socket/bind/listen/accept/connect/close/shutdown  本节主要介绍了网络编程中用到的一些api。连接开始之前，我们需要创建一个socket，它是一个文件描述符，保存了地址、协议、端口等信息，我们需要用这个socket来标识连接。我们通过socket系统调用创建socket后，再通过bind系统调用将socket和地址值进行绑定。接着，服务端需要通过listen系统调用开启监听队列，被动接受连接。而客户端需要通过connect系统调用主动连接服务端。服务端在获取客户端的连接后，通过accept调用接受连接，同时将客户端的socket信息存储在sockaddr结构体中。最后我们可以通过close系统调用或shutdown系统调用关闭连接，它们虽然功能相同，但是在某些细节上存在差异。socketUNIX/Linux中所有东西都是文件，socket也不例外。所以socket是一个可读、可写、可控制、可关闭的文件描述符。下面是用socket系统调用，创建一个socket，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);参数和返回值：  domain：指定协议。IPv4协议为PF_INET，IPv6协议为PF_INET6，UNIX本地域协议为PF_UNIX  type：指定服务类型。服务器类型主要有SOCK_STREAM流服务，表示传输层使用TCP协议；SOCK_UGRAM数据报服务，表示传输层使用UDP协议  protocol：在前两个参数构成的协议集合中，再选择一个具体的协议。一般该值是唯一的，几乎所有情况下，都设置为0，表示使用默认协议  返回值：成功返回一个文件描述符，失败则返回-1，并设置errnobind创建socket之后，我们只是指定了协议，还没有绑定具体的地址。在服务端，我们需要通过bind将socket和具体的地址值绑定，这样客户端才知道该如何进行连接。但在客户端，我们不需要绑定地址值。因为客户端采用匿名方式，由操作系统自动分配socket地址。下面是bind的系统调用，将socket和具体的地址值进行绑定，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int bind(int sockfd, cosnt struct sockaddr *my_addr, socklen_t addrlen);参数和返回值：  sockfd：socket的文件描述符  my_addr：socket地址，里面含有地址、其端口等信息  addrlen：socket地址的长度，通常为sizeof(sockaddr)  返回值：成功返回0，失败返回-1，并设置errnobind函数常见的errno有两种：  EAECCES：表示被绑定的地址是受保护的地址，需要root权限。例如普通用户将socket绑定到系统服务端口(0-1023)上，bind会返回EACCES错误  EADDRINUSE：表示被绑定的地址正在使用中listen在服务端，socket绑定后还不能马上接受客户的连接，需要创建一个监听队列来存放待处理的客户连接。下面是listen的系统调用，为绑定后的socket创建一个监听队列存储客户的连接，其函数原型如下：#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);参数和返回值：  sockfd：socket的文件描述符  backlog：表示内核监听队列最大长度，如果监听队列超过最大长度，服务器将不受理新的客户连接，客户端将收到ECONNREFUSED错误信息  返回值：成功返回0，失败返回-1，并设置errno  内核版本2.2之前，backlog参数指所有处于半连接状态(SYN_RCVD)和完全连接状态(ESTABLISHED)的socket上限。内核版本2.2之后，backlog参数表示所有只处于完全连接状态的socket上限。处于半连接状态的socket上限可以由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义accept目前为止，我们执行了listen调用，使服务端的socket处于监听状态。完成三次握手的连接会存放在监听队列中，接下来我们通过accpet调用从监听队列中取出连接。取出连接的同时会返回一个新的socket文件描述符，我们对客户端的通信在这个新的文件描述符上进行。并且accept调用还会获取客户端的端口、协议及地址信息，这些信息存储在sockaddr结构体中。 下面是accept的系统调用，从监听队列中取出一个客户端连接，并将客户端的socket信息封装到结构体，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);参数和返回值：  sockfd：socket的文件描述符  addr：用来获取被接受连接的远端的socket地址  addrlen：socket地址的长度  返回值：成功返回一个新的socket文件描述符，失败则返回-1，并设置errno我们将执行了listen调用、处于LISTEN状态的socket称为监听socket。监听socket是原来通过socket调用得到的，它只用于监听并建立连接，而不能用于与某个具体的连接进行通信。accept调用会返回一个新的socket文件描述符，我们称之为连接socket。连接socket是用来与某个具体的连接读写数据的。程序结束时，我们需要close两个socket。  accept调用只是从监听队列中取出连接，而不论连接处于何种状态（比如ESTABLISHED状态或CLOSE_WAIT状态，更不关心如何网络状况的变化。也就是说accept取出的socket信息可能由于网络中断而不可用，也可能由于客户端程序退出而不可用。connect服务端通过listen调用启动监听状态，然后被动接受客户端的连接。这时客户端需要通过connect主动连接服务端。下面是connect的系统调用，功能是客户端主动与服务端建立连接，其函数原型如下：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);参数和返回值：  sockfd：socket的文件描述符  serv_addr：服务端监听的socket地址  addrlen：服务端监听的socket地址的长度  返回值：成功返回0，失败则返回-1，并设置errno客户端的connect方法执行成功后，sockfd会唯一地标识这个连接，接着可以通过读写sockfd来与服务端通信。客户端的connect方法有两种常见的失败情况：  ECONNREFUSED：目标端口不存在，连接被拒绝  ETIMEDOUT：连接超时close当我们完成网络通信时，由于socket在UNIX/Linux中是一个文件，所以需要手动关闭socket。下面是close的系统调用，功能是关闭打开的socket连接，其函数原型如下：#include &lt;unistd.h&gt;int close(int fd);参数和返回值：  fd：socket的文件描述符  返回值：成功返回0，失败则返回-1，并设置errno这里需要注意的是，close系统调用并不是立即关闭一个链接，而是将fd的引用计数减1.只有fd的引用计数为0时，才真正关闭连接。比如多进程中，调用fork系统调用，生成子进程，会使父进程打开的socket引用计数加1，所以我们必须在父进程和子进程中都执行close调用才能关闭连接。shutdownclose有时候不能立即关闭连接，可能给我们的程序带来许多不便。为了解决这个问题，可以使用shutdown系统调用，它是专门为网络编程设计的。下面是shutdown的系统调用，功能是立即关闭socket连接，其函数原型如下：#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int howto);参数和返回值：  sockfd：socket的文件描述符  howto：shotdown函数的行为，可取值如下表所示  返回值：成功返回0，失败则返回-1，并设置errno            可选值      含义                  SHUT_RD      关闭sockfd上的读，应用程序不能再针对socket文件描述符执行读操作，并且将该socket接收缓冲区上的数据都丢弃              SHUT_WR      关闭sockfd上的写，socket发送缓冲区上的数据会在真正关闭前全部发送出去，应用程序不能再针对socket文件描述符执行写操作。这种情况连接处于半关闭状态              SHUT_RDWR      同时关闭sockfd上的读和写      由此可见，shutdown可以分别关闭sockfd上的读或写，而close只能在关闭连接上同时关闭读写。总结      socket系统调用会创建一个socket，它是一个文件描述符，保存了地址、协议、端口等信息    bind系统调用将socket和地址、协议、端口等信息进行绑定    listen系统调用使服务端通过开启监听队列，被动接受连接    connect系统调用使客户端主动连接服务端    accept系统调用使客户端从监听队列中接受一个连接，同时将客户端的socket信息存储在sockaddr结构体中    close系统调用会关闭socket，但是只有该socket引用计数为0时，才真正关闭连接    shutdown系统调用会立即关闭连接，而且它可以实现关闭sockfd的读或写  Reference[1] 《深入解析高性能服务器编程》"
  },
  
  {
    "title": "读书笔记 —— 网络编程API_1",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BAPI_1/",
    "categories": "Reading Notes, Linux高性能服务器编程",
    "tags": "C++, socket",
    "date": "2023-04-21 16:48:00 +0800",
    





    
    "snippet": "网络编程结构体/转换函数  本节主要介绍了网络编程中表示socket的结构体，分为通用结构体和专用结构体。这些结构体在使用时都比如强制转换为sockaddr类型。接着介绍了IP地址的转换函数，它们将字符串和网络字节序形式的整数互相转换。最后介绍了网络字节序和主机字节序之间相互转换的函数。结构体网络编程的接口中，通常采用结构体表示socket地址。sockaddr#include &lt;bi...",
    "content": "网络编程结构体/转换函数  本节主要介绍了网络编程中表示socket的结构体，分为通用结构体和专用结构体。这些结构体在使用时都比如强制转换为sockaddr类型。接着介绍了IP地址的转换函数，它们将字符串和网络字节序形式的整数互相转换。最后介绍了网络字节序和主机字节序之间相互转换的函数。结构体网络编程的接口中，通常采用结构体表示socket地址。sockaddr#include &lt;bits/socket.h&gt;struct sockaddr{  sa_family_t sa_family;  char sa_data[14];};sockaddr是最常用的结构体，所有的socket编程接口都使用该结构体类型的参数作为地址。  sa_family_tsa_family_t表示地址族类型，它通常和协议族(protocol family)类型一一对应，如下表所示：            协议族      地址族      描述                  PF_UNIX      AF_UNIX      UNIX本地域协议族              PF_INET      AF_INET      TCP/IPv4协议族              PF_INET6      AF_INET6      TCP/IPv6协议族      这些PF_和AF_定义在bits/socket.h头文件中，而且地址族类型和协议族类型由相同的值，所以二者通常混用。  sa_datasa_data用于存放socket的地址值，不同的协议族的地址值由不同的含义和长度，如下表所示：            协议族      地址值含义和长度                  PF_UNIX      文件的路径名，长度最大可达108字节              PF_INET      16 bit端口号和32 bit IPv4地址，共6字节              PF_INET6      16 bit端口号，32 bit流标识，128 bit IPv6地址，32 bit范围ID，共26字节      可见14字节的sa_data字段无法容纳多数协议族的地址值，所以Linux定义了新的通用socket结构体sockadd_storage。sockaddr_storage#include &lt;bits/socket.h&gt;struct sockaddr_storage{  sa_family_t sa_family;  unsigned long int __ss_align;  char __ss_padding[128-sizeof(__ss_align)];}这个结构体不但提供了足够大的空间用于存放地址值，而且是内存对齐的（__ss_align成员用于内存对齐）。但是现实中我们常用协议族是TCP/IP，这个通用结构体有以下缺点：  获取IP地址和端口号时，需要位操作  TCP/IP的地址值不需要sockaddr_storage这么大的空间为了方便用户，Linux为各个协议族提供了专门的结构体。sockaddr_un#include &lt;sys/un.h&gt;struct sockaddr_un{  sa_family_t sin_family;  char sun_path[108];   //  文件路径名}sockaddr_un是UNIX本地域协议族专用的结构体。sockaddr_in#include &lt;netinet/in.h&gt;struct sockaddr_in{  sa_family_t sin_family;  u_int16_t sin_port;       //  端口号  strcut in_addr sin_addr;  //  IPv4地址};struct in_addr{  u_int32_t s_addr;         //  网络字节序表示};sockaddr_in是TCP/IP协议族专用的结构体，用于IPv4。sockaddr_in6#include &lt;netinet/in.h&gt;struct sockaddr_in6{  sa_family_t sin6_family;  u_int16_t sin6_port;       //  端口号  u_int32_t sin6_flowinfo;   //  流信息  strcut in6_addr sin6_addr; //  IPv6地址  u_int32_t sin6_scope_id;   // scope ID，处于实验阶段};struct in6_addr{  unsigned char sa_addr[16];  //  网络字节序表示};sockaddr_in6是TCP/IP协议族专用的结构体，用于IPv6。总结所有专用的socket结构体，在实际使用时，需要转化为sockaddr结构体（包括sockaddr_storage），因为所有的socket编程接口使用的地址参数都是sockaddr类型的。IP地址转换函数IPv4转换函数#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char * strptr);    // 点分十进制字符串转化为in_addr结构体int inet_aton(const char * cp, struct in_addr * inp);   //  点分十进制字符串转化为in_addr结构体，成功返回1，失败返回0char *inet_ntoa(struct in_addr in);   //  将网络字节序的ip地址数字转化为点分十进制字符串IPv6转换函数#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char * src, void dst);    //  将字符串表示的地址(IPv4或IPV6)转化为网络字节序整数const char * inet_ntop(int af, const void * src, char * dst, socklen_t cnt);  //  将网络字节序表示的IP地址整数转化为字符串这两个函数中，af指定协议族，值为AF_INET或AF_INET6。两个函数的返回值都是成功返回1，失败返回0，并设置errno。inet_pton将结果存储在dst指向的内存中，inet_ntop将结果存储在src指向的内存中。inet_ntop函数最后一个参数cnt用于指定目标存储单元的大小。可以用以下这两个宏来指定大小：#include &lt;netinet/in.h&gt;#define INET_ADDRSTRLEN 16    //  对应IPv4#define INET6_ADDRSTRLEN 46   //  对应IPv6字节序转换函数#include &lt;netinet/in.h&gt;unsigned long int htonl(unsigned long int hostlong);    // 32位主机序转网络序unsigned short int htons(unsigned short int hostshort); // 16位主机序转网络序unsigned long int ntohl(unsigned long int hostlong);    // 32位网络序转主机序unsigned short int ntohs(unsigned short int hostshort); // 16位网络序转主机序更多网络字节序相关内容可以参考文章[2]总结      sockaddr是最常用的结构体，所有的socket编程接口都使用该结构体类型的参数作为地址    sockaddr_in是TCP/IP协议族专用的结构体，用于IPv4  Reference[1] 《深入解析高性能服务器编程》  [2] 网络字节序"
  },
  
  {
    "title": "刷题笔记 —— 查询带键的排列",
    "url": "/posts/%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97/",
    "categories": "leetcode",
    "tags": "leetcode, Binary Index Tree",
    "date": "2023-04-20 11:16:00 +0800",
    





    
    "snippet": "树状数组  该问题题干比较绕，大概要求是在给定的排列P中找到queries[i]所处下标，然后修改P的排列顺序。因为顺序改变了，所以导致下标无法在O(1)时间内求得。本题一种巧妙的方法是用树状数组实现题目给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：...",
    "content": "树状数组  该问题题干比较绕，大概要求是在给定的排列P中找到queries[i]所处下标，然后修改P的排列顺序。因为顺序改变了，所以导致下标无法在O(1)时间内求得。本题一种巧妙的方法是用树状数组实现题目给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：一开始，排列 P=[1,2,3,…,m]。对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。请你以数组形式返回待查数组  queries 的查询结果。例子示例1输入：queries = [3,1,2,1], m = 5输出：[2,1,2,1] 解释：待查数组 queries 处理如下：对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 因此，返回的结果数组为 [2,1,2,1] 。   示例2输入：queries = [4,1,2,2], m = 4输出：[3,1,2,0]示例3输入：queries = [7,5,5,8,3], m = 8输出：[6,5,0,7,5]条件  1 &lt;= m &lt;= 10^3  1 &lt;= queries.length &lt;= m  1 &lt;= queries[i] &lt;= m难点分析该题最简单的方法是暴力法解决，用一个数组记录P元素对应的位置，然后将通过平移将当前数组移动到最前端。时间复杂度为O(MQ)，M为排列P的长度，Q为数组queries的长度。我们重点讲解第二种解法，它可以在O(log(M+Q))的时间内完成。这种解法需要用到树状数组的相关知识，树状数组是一种快速获得某范围内元素和的数据结构，相关知识我们放在下面的位置。我们发现求解每一个询问项queries[i]在排列P中的位置，等价于求解queries[i]前面有多少个元素。在方法一中，我们采用先从列表中「删除」这个数再将其「插入」数组首部的方法，导致时间复杂度为O(M)。但我们可以延长数组的长度，使每个询问项对应的元素插在前面的空位，这样就可以避免移动元素带来的开销。  我们以示例1为例，对于排列 [1, 2, 3, 4, 5] 以及查询 [3, 1, 2, 1]，一开始的数组为：_ _ _ _ 1 2 3 4 5第一次查询3，3前面有2个数。随后将3移动到前面：_ _ _ 3 1 2 _ 4 5第二次查询1，1前面有1个数。随后将1移动到前面：_ _ 1 3 _ 2 _ 4 5第三次查询2，2前面有2个数。随后将2移动到前面：_ 2 1 3 _ _ _ 4 5第四次查询1，1前面有1个数。随后将1移动到前面：1 2 _ 3 _ _ _ 4 5最后我们得到结果[2, 1, 2, 1]。现在我们的问题是怎么快速计算前面有多少个数。如果一个一个数，那时间会退化为O(MQ)。而树状数组的作用恰好是计算范围内的元素之和，所以我们可以利用树状数组快速计算前面有多少个数字。树状数组场景给定一个数组a，需要执行w次修改和q次查询，其中修改是修改某一个元素的值，查询是查询某一个范围内元素值的和。这个场景下，如果我们用普通方法，修改的时间是O(1)，但是查询需要循环求和，时间复杂度为O(n)。如果我们使用前缀和优化，查询时间是O(1)，但是由于所有前缀和都要更新，修改的时间是O(n)。为了平衡查询和修改的时间，树状数组被提出来，它的查询和修改时间复杂度都为O(logN)。所以树状数组适合计算范围和，且需要进行修改的场景。lowbit函数在讲解树状数组前，先了解一下lowbit函数。lowbit函数的功能就是求某一个数的二进制表示中最低的一位1。比如，x = 6，对应二进制为110，那么最后一位1应该是010，所以lowbit(x)返回2(二进制为010)。下面给出两种求解lowbit的代码：int lowbit(x) {\t    return x - (x &amp; (x - 1));}int lowbit(x) {\t    return x &amp; -x;  //  -x是x的补码}核心思想我们从二进制的角度出发，比如 n = 6，对应二进制为0110。既然树状数组的功能是求范围和，那我们将一个数看成几个区间累加的形式。我们可以表示为累加的形式0110 = 0100 + 0010。其中0100是lowbit(0100)的结果，0010是lowbit(0110)的结果。所以树状数组的核心思想是将范围和看成几个区间相加的结果。那区间该怎么划定呢？答案是根据二进制的前缀和。我们举例说明：比如 n = 7，我们求解前7个元素的和。7对应的二进制是0111，根据前缀，我们可以把0111分成三个区间，0100、0110、0111。接下来，前7个元素的和为：S7=a1+a2+a3+a4+a5+a6+a7。如上图所示：区间0111刚好表示7，对应a7的置。区间0110的的前缀是011，它在第二层，对应a5+a6。区间0100的的前缀是01，它在第三层，对应a1+a2+a3+a4。所以我们求解前7个元素的和时，根据二进制的前缀和划分区间，最后转换为S7=a[7]+a[6]+a[4]。而且由于前缀是相同的，我们可以用x-lowbit(x)来得到上一个前缀和对应的数。比如7-lowbit(7)=6，6-lowbit(6)=4，4-lowbit(4)=0。接下来的问题是，如何让a[6]的值等于a5+a6呢？如上图所示，5(0101)+lowbit(5)=6，也就是如果我们在给数组赋值时，赋值a[5]后，也同样赋值给a[6]。当a[6]也完成赋值后，a[6]的值会被赋值两次，分别是a5+a6。这个过程同样可以用lowbit实现。但当我们继续调用公式6+lowbit(6)=8。我们可以发现8对应的是第四层的格子，而且8(1000)和5(0101)、6(0110)的前缀都不同。由于我们查询的时候是根据二进制前缀和来划分区间的，我们查询6(0110)时，由于前缀不同，不会将区间划分到8(1000)。从而在我们查询划分的区间，该区间对应的数(比如6)包含了该区间的和(a5+a6)。最后，赋值6(00110)的时候，需要不断调用x+lowbit(x)往上赋值，比如赋值给8(01000)。因为前8项之和包括了6对应的值，而且6和8在更大范围内有相同的前缀和。解法解法1：模拟过程class Solution {public:    vector&lt;int&gt; processQueries(vector&lt;int&gt;&amp; queries, int m) {        vector&lt;int&gt; P(m + 1, 0);        vector&lt;int&gt; res;        for(int i = 1 ; i &lt;= m ; i++){            P[i] = i - 1;        }                for(int i = 0 ; i &lt; queries.size() ; i++){            for(int j = 0 ; j &lt; P.size() ; j++){                if(P[j] &lt; P[queries[i]]){                    P[j]++;                }            }            res.emplace_back(P[queries[i]]);            P[queries[i]] = 0;        }        return res;    }};解法2：树状数组class Solution {public:    class BIT{        vector&lt;int&gt; c;         int n;    public:        BIT(int _n):n(_n), c(_n + 1) { }        int lowbit(int x){  //  求x二进制中最右的1            return x &amp; (-x);        }        int query(int x){   //  查询x及前面所有元素的和            int ans = 0;            while(x){                ans += c[x];                x -= lowbit(x);            }            return ans;        }        void update(int x, int y){  //  更新            while(x &lt;= n){                c[x] += y;                x += lowbit(x);            }        }    };    vector&lt;int&gt; processQueries(vector&lt;int&gt;&amp; queries, int m) {        const int n = queries.size();        vector&lt;int&gt; pos(m + 1, 0);  //  记录P中每个元素的位置        vector&lt;int&gt; res;        BIT tree(m + n);            //  数组长度m+n+1        for(int i = 1 ; i &lt;= m ; i++){            pos[i] = n + i;            tree.update(n + i, 1);  //  置1，范围和表示范围内有几个元素        }        for(int i = 0 ; i &lt; n ; i++){            int&amp; cur = pos[queries[i]]; //  获取当前元素的位置            tree.update(cur, -1);       //  该位置上的元素置0，表示删除            res.emplace_back(tree.query(cur));  //  查询前面有多少个元素            cur = n - i;                //  当前元素移动到前面            tree.update(cur, 1);        //  移动后，该位置上的元素置1，表示插入        }        return res;    }};Reference[1] 查询带键的排列[2] 树状数组简单易懂的详解"
  },
  
  {
    "title": "刷题笔记 —— 按符号重排数组",
    "url": "/posts/%E6%8C%89%E7%AC%A6%E5%8F%B7%E9%87%8D%E6%8E%92%E6%95%B0%E7%BB%84/",
    "categories": "leetcode",
    "tags": "leetcode, Dynamic Programming, backtrack",
    "date": "2023-04-19 20:28:00 +0800",
    





    
    "snippet": "排序  该问题是一个简单的将数组转换为交叉数组，且要求保留原来相同正负号的元素间的前后顺序。题目给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。你需要 重排 nums 中的元素，使修改后的数组满足下述条件：  任意 连续 的两个整数 符号相反  对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。  重排后数组以正整数开头。重排元...",
    "content": "排序  该问题是一个简单的将数组转换为交叉数组，且要求保留原来相同正负号的元素间的前后顺序。题目给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。你需要 重排 nums 中的元素，使修改后的数组满足下述条件：  任意 连续 的两个整数 符号相反  对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。  重排后数组以正整数开头。重排元素满足上述条件后，返回修改后的数组。例子示例1输入：nums = [3,1,-2,-5,2,-4]输出：[3,-2,1,-5,2,-4]解释：nums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 示例2输入：nums = [-1,1]输出：[1,-1]解释：1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。所以 nums 重排为 [1,-1] 。条件  2 &lt;= nums.length &lt;= 2 * 105  nums.length 是 偶数                              1 &lt;=          nums[i]          &lt;= 10^5                      nums 由 相等 数量的正整数和负整数组成难点分析该题可以采用辅助数组，以空间换时间的方式实现，如下面解法一。该题的难点是在原地排序下实现，同时要求相同正负号的元素间前后顺序保持不变。这里借用归并排序的思想，先将原数组转换为前后排列，即正数在前，负数在后。再将前后排列的数组转换为交叉排列。原数组转换为前后排列可以通过归并的方式实现，通过翻转将正数置于数组前端。前后排列的数组转换为交叉排列的过程，难点在于元素移动位置的推导，具体推导如下：先观察交叉排列前和排列后的状态：1  2  3  4  5  6 -1 -2 -3 -4 -5 -6 // 这一行是正负数前后排列1 -1  2 -2  3 -3  4 -4  5 -5  6 -6 // 这一行是正负数交叉排列首先我们找到 1，他就在正确位置，不动接着我们找到数字 2，我们可以知道他的信息:  数字2，第 2 个正数，正确位置应该往后移动 1 位我们将数字 2 往后移动 1 位，那么原本在这个位置的数字 3 就被挤走：  数字3，第 3 个正数，正确位置应该往后 2 位我们将数字 3 往后移动 2 位，那么原本在这个位置的数字 5 就被挤走：  数字5，第 5 个正数，正确位置应该往后 4 位所以第X个正数应该向右侧移动X-1个位置，而第X个正数的下标为X-1，所以索引公式为：2*Index(Index为X的当前坐标)同理，我们前后反转一下，倒数第Y个负数应该向左侧移动Y-1个位置，倒数第Y个负数的下标为len-Y，所以索引公式为：Index-(Y-1)=2Index-len+1。解法解法1：辅助数组class Solution {public:    vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; tmp(nums.size(), 0);        int i = 0, j = 1;        for(auto &amp;e : nums){            if(e &gt; 0){                tmp[i] = e;                i+=2;            }else{                tmp[j] = e;                j+=2;            }        }        return tmp;    }};解法2：原地排序class Solution {public:    // 双指针翻转，时间复杂度 O(N)    void trans(vector&lt;int&gt;&amp; arr, int left, int right) {        while (left &lt; right) {            swap(arr[left], arr[right]);            left++;            right--;        }    }    // 将无序列表转变为前后排列，时间复杂度 O(NlogN)    void stable_partition_sort(vector&lt;int&gt;&amp; arr) {        int step = 1; // step表示子数组的长度        while (step &lt; (int)arr.size()) {            step *= 2;            for (int i = 0; i &lt; arr.size(); i += step) {                // 当右子数组没有内容时，直接返回                if (i + step / 2 &gt;= arr.size()) break;                // 分别寻找左子数组第一个负数，及右子树组最后一个正数索引                int left, right;                for (left = i; left &lt; i + step / 2; left++) {                    if (arr[left] &lt; 0) {                        break;                    }                }                for (right = min(i + step, (int)arr.size()) - 1; right &gt;= i + step / 2; right--) {                    if (arr[right] &gt; 0) {                        break;                    }                }                //  三次翻转                //  前两次翻转是为了第三次翻转后，让元素之间保持原来的前后顺序                trans(arr, left, i + step / 2 - 1);                trans(arr, i + step / 2, right);                //  第三次翻转，根据上述左子数组找到的第一个负数和右子数组找到的第一个正数，将正数排列在负数前面                trans(arr, left, right);            }        }    }    // 将前后排列转变为交叉排列，时间复杂度 O(N)    void cross(vector&lt;int&gt;&amp; arr) {        int n = arr.size() ;        for (int i = 0; i &lt; n; i++) {            // 查找不符合排列规律的索引            if ((i % 2 == 0) ^ (arr[i] &gt; 0)) {                int cur = arr[i];                int next = (cur &gt; 0) ? (2 * i) : (i * 2 - n + 1);                while (next != i) {                    swap(arr[next], cur);                    next = (cur &gt; 0) ? (2 * next) : (next * 2 - n + 1);                }                arr[i] = cur;            }        }    }    //  主调用函数    vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) {        stable_partition_sort(nums);        cross(nums);        return nums;    }};Reference[1] 按符号重排数组"
  },
  
  {
    "title": "刷题笔记 —— 允许重复选择元素的组合",
    "url": "/posts/%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88/",
    "categories": "leetcode",
    "tags": "leetcode, Dynamic Programming, backtrack",
    "date": "2023-04-18 20:28:00 +0800",
    





    
    "snippet": "回溯/动态规划  该问题是在数组中找出和等于target的子集，在组合问题的基础上增加了元素可重复选取的条件，可以用回溯法实现。这里我们给出用动态规划的另一种实现方式。题目给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的组合。candidates 中的数字可以无限制重复被选取。如果至少...",
    "content": "回溯/动态规划  该问题是在数组中找出和等于target的子集，在组合问题的基础上增加了元素可重复选取的条件，可以用回溯法实现。这里我们给出用动态规划的另一种实现方式。题目给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的组合。candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。例子示例1输入: candidates = [2,3,6,7], target = 7输出: [[7],[2,2,3]]示例2输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]示例3输入: candidates = [2], target = 1输出: []示例4输入: candidates = [1], target = 1输出: [[1]]示例5输入: candidates = [1], target = 2输出: [[1,1]]条件  1 &lt;= candidates.length &lt;= 30  1 &lt;= candidates[i] &lt;= 200  candidate 中的每个元素都是独一无二的。  1 &lt;= target &lt;= 500难点分析该题难点在于元素可重复，如果用回溯法，我们需要在回溯的过程中记录当前访问的元素下标，第一次递归时，只能选取当前元素及后面的元素。我们以示例2为例，给出回溯法的过程图：这里我们给出用动态规划的另一种实现方式，这种实现十分巧妙，值得我们学习。主要思想是，我们用一个列表记录每一次状态（这里的状态是子集），然后迭代计算下一次状态。我们以示例2为例，给出动态规划法的流程图：列表长度为target+1，因为第一个元素要存放空集。接着target值不断加1，判断能否由已有子集加上当前元素组合而成，若可以组合，则新增子集。最后不断迭代计算得到target等于目标值的子集。解法解法1：回溯法class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(candidates, target, path, res, 0, 0);        return res;    }    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt; &amp;res, int score, int index){        if(score &gt; target){            return;        }else if(score == target){            res.emplace_back(path);            return;        }else{            for(int i = index ; i &lt; candidates.size() ; i++){                path.emplace_back(candidates[i]);                dfs(candidates, target, path, res, score + candidates[i], i);                path.pop_back();            }        }    }};解法2：动态规划class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(target + 1);        dp[0] = vector&lt;vector&lt;int&gt;&gt;();        for(auto&amp;&amp; i: candidates) {            for(int j = i; j &lt;= target; j ++) {                for(auto&amp; k: dp[j - i]) {                    dp[j].emplace_back(k);                    dp[j][dp[j].size() - 1].emplace_back(i);                }            }        }        return dp[target];    }};Reference[1] 允许重复选择元素的组合"
  },
  
  {
    "title": "刷题笔记 —— 数组中数字出现的次数 II",
    "url": "/posts/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II/",
    "categories": "leetcode",
    "tags": "leetcode, finite state automata, Bitwise operation",
    "date": "2023-04-17 20:55:00 +0800",
    





    
    "snippet": "有限状态自动机/位运算  该题是在数组中找出只出现一次的元素，其他元素出现三次。核心思想就是对各个二进制位相加，再取余，最后得到的就是只出现一次的元素的二进制数。题目在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。例子示例1输入：nums = [3,4,3,3]输出：4示例2输入：nums = [9,1,7,9,7,9,7]输出：1条件  ...",
    "content": "有限状态自动机/位运算  该题是在数组中找出只出现一次的元素，其他元素出现三次。核心思想就是对各个二进制位相加，再取余，最后得到的就是只出现一次的元素的二进制数。题目在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。例子示例1输入：nums = [3,4,3,3]输出：4示例2输入：nums = [9,1,7,9,7,9,7]输出：1条件  1 &lt;= nums.length &lt;= 10000  1 &lt;= nums[i] &lt; 2^31难点分析该题目很简单，就是找到只出现一次的数，首先最简单的做法是用一个哈希表记录每个数字出现的次数，然后遍历哈希表找出只出现一次的那个数字，时间复杂度为O(n)。但是哈希表的做法需要大量存储空间，所以我们可以用位运算的做法。我们可以统计所有数字的二进制位出现1的次数，然后余3，这时出现3次的数字对应的二进制位取余后为0，而只输出一次的数字对应的二进制位取余后为1，所以最后我们只要把取余后的二进制数转换为十进制数就是最后结果。由于每轮中的位运算操作次数是常数，所以时间复杂度是O(n)，此外我们只需要32位数组，所以空间复杂度也是常数O(1)。和第二种做法思想类似，我们可以用有限状态机来表示位运算的过程。由于我们有3个状态，所以需要两位来表示状态0、1、2。状态变换过程如下图所示：我们设第一位为tow，第二位为one，我们给出one状态转换的计算公式：if(tow == 0)    if(n == 0)        one = one;  //  保持不变    if(n == 1)        one = ~one; //  取反if(two == 1)    one = 0;        //  置0我们将状态转换的计算公式简化，tow等于0时要不取反，要不不变，可以用异或逻辑表示。tow等于1时，置为0，可以用与逻辑表示。简化过程及简化后的结果如下图所示：计算完one之后，接着我们更新tow。因为状态的前后顺序没有影响，我们对调状态后发现，它们的转换公式是相同的，如下图所示：所以我们得到总的状态转换公式为：one = one ^ n &amp; ~two;two = two ^ n &amp; ~one;这是一个二进制位的转换公式，对于32位来说同样适用，我们只要将每一位拆开来看就可以了。记住，我们的核心思想是对每一个二进制位状态转换（加1），出现三次的数字对应的二进制位在3次加1后会变为0，而出现一次的数字对应的二进制位则为1。我们通过一个例子说明：假设数组为[3,3,4,3]初始时，tow 和 one 为： &gt; 000...000 | 000...000第一个数3的二进制是000...011，所以分别对末尾第一位和第二位加1，根据状态转换公式，tow 和 one会变为：  &gt; 000...000 | 000...011接着读入第二个数3，继续对末尾第一位和第二位进行状态转化：  &gt; 000...011 | 000...000接着读入第三个数4，二进制是000...100，对末尾第一、第二、第三位进行状态转换：  &gt; 000...011 | 000...100由于末尾第一位和第二位传入的是0，根据状态转换公式，会保持原值。只有末尾第三位发生改变。最后传入第4个数3，对末尾第一位和第二位进行状态转化：&gt; 000...000 | 000...100末尾第一位和第二位的原本状态是(tow,one)=(1,0)，传入1后，(tow,one)=(0,0)。所以末尾第一位和第二位经过三次加1后，最后归0。而one中没有归0的二进制位既是只出现一次的数字对应的二进制位。解法解法1：哈希表class Solution {public:    int singleNumber(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; freq;   //  用哈希表记录出现次数        for(auto &amp;e : nums){            if(freq.find(e) == freq.end()){                freq[e] = 1;            }else{                freq[e] = 2;            }        }        for(auto &amp;e : freq){    //  遍历哈希表，找只出现一次的那个数字            if(e.second == 1){                return e.first;            }        }        return -1;    }};解法2：位运算class Solution {public:    int singleNumber(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; state(32, 0);   //  这里如果用new int[32]，没有初始化会报错        for(int i = 0 ; i &lt; nums.size() ; i++){            for(int j = 0 ; j &lt; 32 ; j++){                state[j] += nums[i] &amp; 1;    //  获取末位                nums[i] &gt;&gt;= 1;              //  右移一位            }        }        for(int j = 0 ; j &lt; 32 ; j++){            state[j] %= 3;                  //  取余        }        //  将二进制数转换为十进制数        int res = 0;        for(int j = 0 ; j &lt; 32 ; j++){            res &lt;&lt;= 1;            res |= state[32 - 1 - j];        }        return res;    }};解法3：有限状态自动机class Solution {public:    int singleNumber(vector&lt;int&gt; nums) {        int one = 0, two = 0;        for (int n : nums) {            one = one ^ n &amp; ~two;            two = two ^ n &amp; ~one;        }        return one;    }};Reference[1] 数组中数字出现的次数 II"
  },
  
  {
    "title": "刷题笔记 —— 统计按位或能得到最大值的子集数目",
    "url": "/posts/%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/",
    "categories": "leetcode",
    "tags": "leetcode, backtrack, States Compre ssion",
    "date": "2023-04-17 15:15:00 +0800",
    





    
    "snippet": "回溯/状态压缩  先通过位或运算得到最大值，然后找出数组中通过位或运算等于最大值的子集数目题目给你一个整数数组 nums ，请你找出nums子集按位或可能得到的最大值，并返回按位或能得到最大值的不同非空子集的数目。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集不同 。对数组 a 执行按位或...",
    "content": "回溯/状态压缩  先通过位或运算得到最大值，然后找出数组中通过位或运算等于最大值的子集数目题目给你一个整数数组 nums ，请你找出nums子集按位或可能得到的最大值，并返回按位或能得到最大值的不同非空子集的数目。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集不同 。对数组 a 执行按位或，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。例子示例1输入：nums = [3,1]输出：2解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：- [3]- [3,1]示例2输入：nums = [2,2,2]输出：7解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。示例3输入：nums = [3,2,1,5]输出：6解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：- [3,5]- [3,1,5]- [3,2,5]- [3,2,1,5]- [2,5]- [2,1,5]条件  1 &lt;= nums.length &lt;= 16  1 &lt;= nums[i] &lt;= 10^5难点分析该题题目比较繁琐，简单来说，首先对数组位或运算求出最大值。然后数组的某些子集，进行位或运算也可能得到最大值，找出这些子集的数量。难点在于第二步，遍历所有子集的同时，计算子集中所有元素的位或值，判断是否相等。最简单的遍历方法是回溯法，回溯的过程中我们可以用一个变量保存位运算的结果。时间复杂度为O(n+2^n)。第二种方法是状态压缩，我们计算其中一个子集时，数组中的元素有两种状态，在子集中或不在子集中。所以我们可以用n位二进制数（n为数组大小），每一位上的0和1表示对应数组元素是否在该子集中。如果在子集中，则对该元素进行位运算。最后判断位运算的结果是否等于最大值。时间复杂度为O(n*2^n)。解法解法1：回溯法class Solution {public:    int n = 0;    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {        //  计算最大值        int max = 0;        for(auto &amp; e: nums){            max = max | e;        }        //  采用回溯法遍历所有子集        dfs(nums, 0, 0, max);        return n;    }    void dfs(vector&lt;int&gt;&amp; nums, int res, int index, int max){        if(nums.size() == index){            if(res == max){                n++;            }            return ;        }        dfs(nums, res, index + 1, max);        dfs(nums, res|nums[index], index + 1, max);    }};解法2：状态压缩class Solution {public:    int n = 1;    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {        //  计算最大值        int max = 0;        for(auto &amp; e: nums){            max = max | e;        }        //  得到所有状态，这里注意括号        int state = (1 &lt;&lt; nums.size()) - 1;        for(int i = 1 ; i &lt; state; i++){            if(findOr(nums, i) == max){                n++;            }        }        return n;    }    int findOr(vector&lt;int&gt;&amp; nums, int state){        int ans = 0;        for(int i = 0 ; i &lt; nums.size() ; i++){            //  如果当前状态第i位不为0，表示nums[i]参与位运算            //  这里!=0不能改为==1，因为位运算后左边不全为0            if(((1 &lt;&lt; i) &amp; state) != 0){                ans |= nums[i];            }        }        return ans;    }};Reference[1] 统计按位或能得到最大值的子集数目"
  },
  
  {
    "title": "刷题笔记 —— 两点之间不包含任何点的最宽垂直区域",
    "url": "/posts/%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%8C%85%E5%90%AB%E4%BB%BB%E4%BD%95%E7%82%B9%E7%9A%84%E6%9C%80%E5%AE%BD%E5%9E%82%E7%9B%B4%E5%8C%BA%E5%9F%9F/",
    "categories": "leetcode",
    "tags": "leetcode, sort",
    "date": "2023-04-14 16:30:00 +0800",
    





    
    "snippet": "排序  两点之间不包含任何点的最宽垂直区域问题是求出两点之间的最大差值，运用桶排序算法可以做到O(n)复杂度题目给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。请注意...",
    "content": "排序  两点之间不包含任何点的最宽垂直区域问题是求出两点之间的最大差值，运用桶排序算法可以做到O(n)复杂度题目给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。请注意，垂直区域 边上 的点 不在 区域内。例子示例1输入：points = [[8,7],[9,9],[7,4],[9,7]]输出：1解释：红色区域和蓝色区域都是最优区域。示例2输入：points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]输出：3条件  n == points.length  2 &lt;= n &lt;= 105  points[i].length == 2  0 &lt;= xi, yi &lt;= 109难点分析本题的题意是在一堆无序的点（只考虑x坐标）中，找出最大的差值。首先最简单的做法是二重循环，但是时间复杂度比较高。可以先进行排序，然后前后元素比较得到最大的差值。本题最大的难点在于如何在O(n)时间内得到结果，这就联想到O(n)复杂度的桶排序。我们的主要思想是，把点划分到一个一个线段（桶）内，这个线段长度必须满足：比最大差值小。这样，我们求的最大差值一定会被划分到两个线段（桶）中。所以我们只要把该线段内的点的最小值，比上前一个线段内点的最大值，就能求出最大差值了。那难点来了，这个线段长度取多少？根据公式：最大差值满足：maxGap &gt;= (maxPoint - minPoint) / (n - 1)。所以我们取(maxPoint - minPoint) / (n - 1)为线段长度即可。间距小于线段长度的，一定会放入同一个线段（桶）中。而间距大于线段长度的，会被放到不同的线段（桶）中。再结合上面的公式，我们可以得出，最大差值一定是在不同的线段中的点的间距。解法解法1：常规排序class Solution {public:    int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        sort(points.begin(), points.end());        int mx = 0;        for (int i = 1; i &lt; points.size(); i++) {            mx = max(points[i][0] - points[i - 1][0], mx);        }        return mx;    }};解法2：桶排序class Solution {public:    int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        const int n = points.size();        const int inf = 1 &lt;&lt; 30;    //  生成最大值和最小值的一种简便写法        int mi = inf, ma = -inf;        for(auto &amp;e : points){      //  计算points的最大值和最小值            mi = min(mi, e[0]);            ma = max(ma, e[0]);        }        int bucketSize = max(1, (ma - mi) / (n - 1));   //  桶大小        vector&lt;pair&lt;int, int&gt;&gt; backet((ma - mi) / bucketSize + 1, {inf, -inf});        for(auto &amp;e : points){  //  更新桶中的最大值和最小值            int index = (e[0] - mi) / bucketSize;            backet[index].first = min(backet[index].first, e[0]);            backet[index].second = max(backet[index].second, e[0]);        }        int res = 0;        int prev = inf;        for(auto &amp;e : backet){              if(e.first &gt; e.second) continue;    //  因为有些桶可能没用到，其中e=[inf,-inf]，所以加个判断            if(e.first - prev &gt; res){   //  前一个桶的最大值和当前桶的最小值做比较                res = e.first - prev;            }            prev = e.second;        }        return res;    }};Reference[1] 两点之间不包含任何点的最宽垂直区域"
  },
  
  {
    "title": "C++ —— 网络字节序",
    "url": "/posts/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/",
    "categories": "other, C++",
    "tags": "C++, socket, htons, inet_ntoa",
    "date": "2023-04-12 11:03:00 +0800",
    





    
    "snippet": "网络字节序  主机中根据字节高低位的存储顺序分为大端模式和小端模式，我们把主机存储字节的顺序叫做主机字节序。由于不同的主机存储的字节顺序是不同的，通常由CPU决定。所以在网络通信中，我们需要统一存储顺序，即都采用大端模式存储，我们称之为网络字节序。在下面内容中我们围绕网络字节序展开研究，介绍了网络字节序和主机字节序的转换方法。网络字节序一般用于端口号或ip地址，所以我们还介绍了ip地址的点分...",
    "content": "网络字节序  主机中根据字节高低位的存储顺序分为大端模式和小端模式，我们把主机存储字节的顺序叫做主机字节序。由于不同的主机存储的字节顺序是不同的，通常由CPU决定。所以在网络通信中，我们需要统一存储顺序，即都采用大端模式存储，我们称之为网络字节序。在下面内容中我们围绕网络字节序展开研究，介绍了网络字节序和主机字节序的转换方法。网络字节序一般用于端口号或ip地址，所以我们还介绍了ip地址的点分十进制字符串和二进制网络字节序的互相转换。网络字节序网络字节顺序NBO(Network Byte Order)是将字节按从高到底的顺序存储，在网络上使用统一的顺序。主机字节顺序主机字节顺序HBO(Host Byte Order)是主机存储字节的顺序，分为大端模式和小端模式。不同主机的HBO不同，与主机的CPU有关，即数据的存储顺序由CPU决定，与操作系统无关。由于这个原因，不同体系结构的机器之间不能直接通信，所以要转换成一种约定的顺序，也就是网络字节顺序。在下一步阐述之前，我们先介绍一下大端模式和小端模式。大端\\小端模式定义  大端模式：高地址存低字节，低地址存高字节| 12 | 34 | 56 | 78 |低位   ———&gt;   高位  小端模式：低地址存低字节，高地址存高字节| 78 | 56 | 34 | 12 |低位   ———&gt;   高位人类读写数据习惯是大端字节序，比如1234，我们先读的是高位的12，再读低位的34。所以小端是反人类的方式  端模式(Endian)起源于《格列佛游记》, 书中根据鸡蛋敲开的方式不同将所有人分为2类，从圆头开始敲的人被归为Big Endian，从尖头开始敲的被归为Little Endian。小人国的内战就是源于吃鸡蛋是是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。大小端的存在性为什么机器有大小端之分？编译语言中许多数据类型的宽度大于一个字节的，比如int占4个字节。将多字节类型的数据存储到寄存器，必然会有顺序问题。早年不同厂商的机器标准不同，加上大\\小端模式各有优缺点，所以产生了大小端问题。常见的处理器大小端结构：            处理器      端模式                  IntelX86      Little-Endian              Power-PC      Big-Endian              IBM      Big-Endian              ARM      默认Little-Endian              STM32      Little-Endian      注意，网络通讯协议采用的是Big-Endian。所以为了解决不同主机的通信问题，在网络通信中我们需要将字节顺序转换为大端模式的网络字节序。[ 例子 ]：假设在x86平台(Little-Endian)上,有一个int型变量,在内存中由低到高分别是:0x78,0x56,0x34,0x12。当通过网络发送该数据时,正确的发送顺序是0x12,0x34,0x56,0x78。  注意，即使同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也需要考虑字节序问题（因为JAVA虚拟机采用大端模式的字节序）。大小端的优点  小端模式：强制类型转换数据不需要调整字节内容。  大端模式：符号位判断固定为第一个字节，容易判断正负，且便于人类阅读。总结：大小端明显优劣之分，己方优点就是对方劣势。判断主机大小端unsigned short a = 0x1218;if( (*(char*)&amp;a)  == 0x18){    //  小端模式}else{    //  大端模式}大小端顺序转换typedef unsigned short int uint16;typedef unsigned long int uint32;#define BigLittleSwap16(A) ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | \\                           (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))  #define BigLittleSwap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \\                           (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \\                           (((uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \\                           (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))转换函数下面介绍一组主机字节序和网络字节序互相转换的函数，一般用于网络编程中port，ip地址等数据的转换。这些互相转换的函数存储在头文件#include &lt;arpa/inet.h&gt;中。分别为：#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);其中函数名的缩写含义是：ntohs -&gt; net to host short int (16位)htons -&gt; host to net short int (16位)ntohl -&gt; net to host long int (32位)htonl -&gt; host to net long int (32位)这些函数功能和用法类似，我们选择其中一个详细讲解。htons函数原型：uint16_t htons(uint16_t hostshort);函数功能：将一个无符号短整型数值转换为网络字节序，即大端模式。参数及返回值：  u_short hostshort: 16位无符号整数  返回值: TCP / IP网络字节顺序示例：short int port = 8012;    //  假设端口号为8012cout&lt;&lt; port &lt;&lt; \" -&gt; \" &lt;&lt; bitset&lt;16&gt;(port) &lt;&lt; endl;uint16_t ptn = htons(port);   //  转换为网络字节序cout&lt;&lt; ptn &lt;&lt; \" -&gt; \" &lt;&lt; bitset&lt;16&gt;(ptn) &lt;&lt; endl;uint16_t pth = ntohs(ptn);    //  将网络字节序转换为主机字节序cout&lt;&lt; pth &lt;&lt; \" -&gt; \" &lt;&lt; bitset&lt;16&gt;(pth) &lt;&lt; endl;//  输出：8012 -&gt; 00011111 0100110019487 -&gt; 01001100 000111118012 -&gt; 00011111 01001100我们从结果可以看到，在一个字节内，计算机是按顺序存储的，当跨多个字节时，主机字节序是小端模式。我们通过htons函数转换为网络字节序，即大端模式。由于port占两个字节，所以ptn的两个字节顺序和port的两个字节顺序反过来了。最后我们通过ntohs函数转换回主机字节序。  注意，因为计算机的端口数量有65536个，也就是2^16，所以需要short int类型来表示。同理，ip地址需要用long int类型(32位)来表示。IP地址字符串和32位数字的转换函数原型：int inet_aton(const char *cp,struct in_addr *inp); char *inet_ntoa(struct in_addr in);in_addr inet_addr(const char *cp);其中结构体in_addr以网络字节序的形式存储ip地址，结构体如下：struct in_addr {\tu_int32_t s_addr; //  原来的in_addr结构体有许多成员，后来经过删减只剩下ip地址了};函数功能：将点分十进制表示的IP地址字符串与网络字节序形式的ip地址数字互相转换。参数及返回值：  in_addr: 数字形式的ip地址的结构体  cp: 点分十进制表示的ip地址字符串  返回值: inet_aton成功返回非0，失败返回0inet_ntoa返回一个由inet_ntoa()控制的静态字符指针，所以每次调用inet_ntoa()，它就将覆盖上次调用时所得的IP地址inet_addr返回数字形式的ip地址的结构体头文件：#include &lt;netinet/in.h&gt;\t// 提供struct in_addr#include &lt;arpa/inet.h&gt;\t// 提供inet_ntoa()示例：struct in_addr *src_addr;\t\t// 用来保存本机IP（网络字节序）src_addr = (in_addr *)malloc(sizeof(in_addr));// 通过inet_aton将字符串表示的ip地址转换为网络字节序表示的数字inet_aton(\"172.31.238.173\", src_addr);     cout &lt;&lt;  bitset&lt;32&gt;(src_addr-&gt;s_addr) &lt;&lt; endl;  //  输出二进制cout &lt;&lt; inet_ntoa(*src_addr) &lt;&lt; endl;      // 输出点分十进制字符串//  通过inet_aton将src_addr结构体中的ip地址进行修改inet_aton(\"172.31.238.100\", src_addr);cout &lt;&lt;  bitset&lt;32&gt;(src_addr-&gt;s_addr) &lt;&lt; endl;cout &lt;&lt; inet_ntoa(*src_addr) &lt;&lt; endl;//  输出：10101101111011100001111110101100172.31.238.17301100100111011100001111110101100172.31.238.100我们通过inet_aton()成功将字符串表示的ip地址转换为网络字节序表示的数字形式(u_int32_t)，后面又通过inet_ntoa()输出为点分十进制字符串。这里我们可以看到，由于ip地址在in_addr中是以网络字符序存储的，即大端模式。所以先存储IP地址中的高位，即173/100。所以两次输出的二进制值，前8位不同，后24位相同。总结      网络字节序NBO是将字节按从高到底的顺序存储，是为了解决不同主机之间的兼容性问题    主机字节序和网络字节序互相转换的函数存储在头文件#include &lt;arpa/inet.h&gt;中  Reference[1] 一文彻底弄懂大端与小端[2] socket网络编程之htons()相关详解[3] 学习inet_ntoa()函数"
  },
  
  {
    "title": "C++ —— VA_LIST",
    "url": "/posts/VA_LIST/",
    "categories": "other, C++",
    "tags": "C++, VA_LIST, stdarg.h",
    "date": "2023-04-05 20:20:00 +0800",
    





    
    "snippet": "VA_LIST  VA函数(variable argument function)，指参数个数可变的函数，又称可变参数函数。比如c++中的printf、scanf、exce*函数都是参数个数可变的VA函数。为了方便我们处理VA函数，C语言中提出一组宏——VA_LIST，用于解决变参问题。本节我们将深入源码探讨va_list的原理，并用一个示例来说明如何使用它。定义VA_LIST是在C语言中解...",
    "content": "VA_LIST  VA函数(variable argument function)，指参数个数可变的函数，又称可变参数函数。比如c++中的printf、scanf、exce*函数都是参数个数可变的VA函数。为了方便我们处理VA函数，C语言中提出一组宏——VA_LIST，用于解决变参问题。本节我们将深入源码探讨va_list的原理，并用一个示例来说明如何使用它。定义VA_LIST是在C语言中解决变参问题的一组宏，其中va_list表示可变参数列表类型（它是一个类型，所以使用时我们需要声明为变量）。  va_list等相关函数存储在&lt;stdarg.h&gt;头文件中。源码va_list的本质是一个指向可变参数format的char*指针,offset用来指向当前访问的参数。#ifndef _VA_LIST_DEFINED#ifdef _M_ALPHAtypedef struct {  char *a0;    /* pointer to first homed integer argument */  int offset;  /* byte offset of next parameter */} va_list;#elsetypedef char *va_list;#endifva_start, va_end, va_arg的源码如下：#ifdef _M_IX86#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) -1) &amp;~ (sizeof(int) -1 ))  //  为了满足需要内存对齐的系统#define va_start(ap, v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )  //  ap指向第一个可变参数的地址#define va_arg(ap, t) ( *(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))   //  获取变参的具体内容，具体解析见下#define va_end(ap) ( ap = (va_list)0 )  //  清空va_list#elif define(_M_MRX000)/* Use these types and definition if generating code for MIPS *///  作者说明：C编译器为了统一在不同的硬件架构、硬件平台上的实现，和增加代码的可移植性，提供了一系列宏来屏蔽硬件环境不同带来的差异#define va_start(ap, v) ap = (va_list)&amp;v + sizeof(v)#define va_end(list)#define va_arg(list, mode) ((mode *)(list = (char *)((((int)list *(__builtin_alignof(mode) &lt;= 4 ? 3 : 7)) &amp; (__builtin_alignof(mode) &lt;= 4 ? -4 : -8)) + sizeof(mode))))[-1]示例我们定义一个求平均值的函数，该函数可以接受任意数量的参数。int average(int var, ...){  int count = 0, sum = 0, i = var;  //  i访问第一个参数变量  va_list valst;            //  声明va_list变量  va_start(valst, var);  //  使参数列表指针指向可变参数表的第一个参数  while(i != -1)  {      sum+=i;      count++;      i = va_arg(valst, int);  //  va_arg取出当前可变参数，第二个参数是你要返回的参数的类型  }  va_end(valst); //  置空指针  return sum/count; //  返回平均值}//  主函数int main(int crgc, char** argv){  printf(\"%d\", average(1, 2, 3));  printf(\"%d\", average(1, 2, -3, -2));  printf(\"%d\", average(1, 7, 9, 2, -1));}内存分配说明C语言的函数形参是从右往左压入堆栈的，这样可以保证栈顶是第一个参数。而且x86平台内存分配顺序是从高地址到低地址。因此上述函数average的内存分配情况是这样的：栈区|栈顶                低地址|第一个参数var1      &lt;-- &amp;v|第二个参数var2      &lt;-- va_start(ap,v)后，ap所指地址|...|最后一个参数varN|...|函数返回地址|...|栈底               高地址所以va_arg(ap,t)的行为是先令ap += _INTSIZEOF(t)，ap指向下一个参数的地址，然后再执行ap - _INTSIZEOF(t)返回上一个参数的地址，最后完成类型转换*(t *)(…)。缺点va_list方便了我们处理可变参数列表，但它也有一些缺点：  因为va_list是通过宏实现的，所以不能识别可变参数的个数和类型  编译器不能检查使用可变参数的函数原型，难以纠错  由于参数的地址用于VA_START宏，所以参数不能声明为寄存器变量，函数或数组类型  VA_LIST允许对内存的随意访问，但我们写程序时必须严格控制内存访问边界总结      VA_LIST是在C语言中解决变参问题的一组宏    va_list等相关函数存储在&lt;stdarg.h&gt;头文件中  Reference[1] windows学习笔记2——va_list,va_start,va_end,va_arg的使用[2] va_list原理及用法[3] va_list深究"
  },
  
  {
    "title": "C++ —— string format",
    "url": "/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0/",
    "categories": "other, C++",
    "tags": "C++, format, cstdio",
    "date": "2023-03-31 11:03:00 +0800",
    





    
    "snippet": "string format  本节我们将介绍几个将格式化的字符串写入缓冲区的函数，它们都定义在&lt;cstdio&gt;头文件中。接着我们将探讨一下格式化字符串中用到的各种格式化说明符。最后我们将介绍这几个函数的区别。sprintfsprintf的函数原型为：sprintf(char* buffer, const char* format, ...);sprintf的函数参数为：  buf...",
    "content": "string format  本节我们将介绍几个将格式化的字符串写入缓冲区的函数，它们都定义在&lt;cstdio&gt;头文件中。接着我们将探讨一下格式化字符串中用到的各种格式化说明符。最后我们将介绍这几个函数的区别。sprintfsprintf的函数原型为：sprintf(char* buffer, const char* format, ...);sprintf的函数参数为：  buffer: 将要写入的字符串缓冲区  format: 写入缓冲区的字符串格式  …:    用于格式化字符串的参数（任意数量）  返回值： 写入成功则返回写入的字符数量（不包括\\0），写入失败则返回一个负数sprintf的函数例子为：int age = 23;int i = sprintf(buffer, \"My age is %d\", age);   //  i为12int j = sprintf(buffer, \"My 年龄 is 18\");       //  j为13snprintfsnprintf的函数原型为：int snprintf( char* buffer, size_t buf_size, const char* format, ... );snprintf的函数参数为：  buffer: 将要写入的字符串缓冲区  buf_size: 能写入缓冲区的字符数量，由于最后一个字符是’/0’，所以实际输出的字符数量为buf_size-1  format: 写入缓冲区的字符串格式  …:    用于格式化字符串的参数（任意数量）  返回值： 写入成功则返回可以写入的字符数量（不包括\\0），写入失败则返回一个负数。注意这里返回的字符数量包括被截断的部分snprintf的函数例子为：int i = snprintf(buffer,10, \"My age is %d\",18);     //  i为12，但实际只输出9个字符int j = snprintf(buffer, 12, \"My age is %d\", 18);   //  j为12，但实际只输出11个字符/*输出：  My age isMy age is 1     //  截断位置为buf_size-1，即共输出11个字符*/vsprintfvsprintf的函数原型为：int vsprintf( char* buffer, const char* format, va_list vlist );vsprintf的函数参数为：  buffer: 将要写入的字符串缓冲区  buf_size: 能写入缓冲区的字符数量，由于最后一个字符是’/0’，所以实际输出的字符数量为buf_size-1  format: 写入缓冲区的字符串格式  vlist:  用于格式化字符串的可变参数列表[4]  返回值： 写入成功则返回写入的字符数量（不包括\\0），写入失败则返回一个负数。vsprintf的函数例子为：void output(char * buffer,const char *format, ...) {  va_list valst;  va_start(valst, format);  int i = vsprintf(buffer, format, valst);  va_end(valst);  cout &lt;&lt; i &lt;&lt; endl;  cout &lt;&lt; buffer &lt;&lt; endl;}int main() {  ...  output(buffer,\"My age is %d\",18);  ...}/*输出：12My age is 18*/vsnprintfvsnprintf的函数原型为：int vsnprintf( char* buffer, size_t buf_size, const char* format, va_list vlist );vsnprintf的函数参数为：  buffer: 将要写入的字符串缓冲区  buf_size: 能写入缓冲区的字符数量，由于最后一个字符是’/0’，所以实际输出的字符数量为buf_size-1  format: 写入缓冲区的字符串格式  vlist:  用于格式化字符串的可变参数列表  返回值： 写入成功则返回可以写入的字符数量（不包括\\0），写入失败则返回一个负数。注意这里返回的字符数量包括被截断的部分vsnprintf的函数例子为：void output(char * buffer,const char *format, ...) {  va_list valst;  va_start(valst, format);  int i = vsnprintf(buffer, 10, format, valst);  va_end(valst);  cout &lt;&lt; i &lt;&lt; endl;  cout &lt;&lt; buffer &lt;&lt; endl;}int main() {  ...  output(buffer,\"My age is %d\",18);  ...}/*输出：12My age is     //  截断位置为buf_size-1，即共输出9个字符*/区别它们的相同之处都是把格式字符串写入字符串缓冲区中。  sprintf和snprintf的差别在于：snprintf在写入字符串缓冲区后，按照buf_size把缓冲区进行截断，而sprintf不会截断。  vsprintf和vsnprintf的差别同理：vsnprintf是根据buf_size的大小对缓冲区进行截断。  sprintf、snprintf和vsprintf、vsnprintf的差别是：sprintf、snprintf的函数原型是传入一个format参数后，可以接受多个不同类型的实参。而vsprintf、vsnprintf则是先将多个可变数量的实参封装在va_list中，再将实参列表传入函数中。这样做的好处是在参数类型和个数不确定的情况下，可以用一个堆栈保存我们的可变参数，实现一些需要对输出函数封装的场景。比如下面这个例子：    void myPrintf(const char* fmt, ...){char str[20];//  假设这里我们需要对输出函数做一些处理，比如输出前面加上时间和事件等级sprintf(str, fmt);printf(fmt);}int main(){...int a = 30, b = 20;myPrintf(\"a=%d,b=%d\\r\\n\", a, b);...}//  输出结果为： a=12319876,b=6492195      我们可以看到输出的结果不正确，因为myPrintf函数中的可变参数(…)并没有被正确读取到sprintf中，或者说sprintf没办法处理这种情况。为了实现对输出函数的封装场景，我们要用到vsprintf：void myPrintf(const char* fmt, ...){  char str[20];  //  假设这里我们需要对输出函数做一些处理，比如输出前面加上时间和事件等级  va_list valst;  va_start(valst, fmt);  vsprintf(str, fmt, valst);  va_end(valst);  printf(str);}int main(){  ...  int a = 30, b = 20;  myPrintf(\"a=%d,b=%d\\r\\n\", a, b);  ...}//  输出： a=30, b=20这样我们就能正确处理函数中传入的可变参数(…)了。格式说明符格式化字符串中往往有一些格式说明符，比如%d,%s。接下来我们深入研究一下这些格式说明符。格式说明符的语法为：%[flags][width][.precision][length]specifier  flags [可选]flags用于规定输出样式，取值有以下几种：            flag      作用                  +      右对齐，和字段宽度width配合使用，左边补空格，负数会显示-号              -      左对齐，和字段宽度width配合使用，右边补空格              空格      输出值为正时加上空格，为负时加上负号              #      specifier 是 o、x、X 时，增加前缀 0、0x、0X                     specifier 是 e、E、f、g、G 时，一定使用小数点                     specifier 是 g、G 时，尾部的 0 保留              0      左边使用0填充字段宽度，和字段宽度width配合使用      示例如下：printf(\"%d |\\n\",1234);          // 不加width，正常输出printf(\"%-10d |\\n\",1234);       // 左对齐，右边补空格printf(\"%10d |\\n\",1234);        // 右对齐，左边补空格printf(\"% d % d\\n\", 16,-16);    // 值为正数输出空格，负数输出符号printf(\"%x %#x\\n\", 31, 31);     // 增加前缀0xprintf(\"%G %#G\\n\", 1.0, 1.0);   //  一定使用小数点printf(\"%g %#g\\n\", 31.1, 31.1); // 保留尾部的0printf(\"%010d |\\n\", 1);         // 前面用0填充 /* 输出:1234 |1234       |      //  -号      1234 |      //  +号16 -16            //  空格1f 0x1f           //  #号1 1.00000         //  #号31.1 31.1000      // #号0000000001 |      // 0号*/             width [可选]width用于指定输出字段的最小宽度，如果输出的字段小于width，则根据flags进行左对齐或右对齐；如果输出字段大于width，则输出所有字段，不会截断。示例如下：    printf(\"%d |\\n\",1234);     // 不加widthprintf(\"%-10d |\\n\",1234);  // 左对齐，右边补空格printf(\"%10d |\\n\",1234);   // 右对齐，左边补空格printf(\"%*d |\\n\", 10, 1234); // *号表示width由后面的参数10指定/* 输出:1234 |1234       |   1234 |    1234 |  */        precision [可选]precision用于指定输出的精度，一般用于指定浮点数和字符串的精度。示例如下：    printf(\"%.2d\\n\", 1234);          // 整型printf(\"%.2f\\n\", 1234.1234);     // 浮点型，截取小数点后的前两位printf(\"%.2s\\n\", \"1234.1234\");   // 字符串，截取字符串的前两位printf(\"%.*f\\n\", 1, 1234.1234);     // *号表示precision由后面的参数指定/* 输出:12341234.12121234.1 */        length [可选]length用于指定参数的大小，取值为h或l。取值h时，参数被解释为短整型；取值l时，参数被解释为长整型。示例如下：```c++long n1 = 1234567890;    // 长整型printf(“%ld\\n”, n1);     // 由于长整型(32位)最大值为2147483647，所以能成功输出printf(“%hd\\n”, n1);     // 由于短整型(16位)最大值为32767，所以会被截断/* 输出:1234567890722输出722的原因：1234567890对应二进制为：  1001001100101100000001011010010由于短整型只有16位，所以截断了末尾的16位：  0000001011010010有符号数的第一位表示正负号，剩下的二进制数转化为十进制数为：  2 + 16 + 64 + 128 + 512 = 722*/long n2 = 1234;         // 短整型printf(“%ld\\n”, n2);printf(“%hd\\n”, n2);/* 输出:1234567890722由于长整型%ld和短整型%hd的位数都足够，所以不会发生溢出*/5. specifierspecifier用于规定输出数据的类型，它的取值取下：  | specifier | 对应数据类型  | 描述 || --        |  --          |  --  || d/i       |    int       | 输出有符号的十进制整数，i是老式写法 || o         | unsigned int | 输出无符号的八进制整数（没有前缀0） || u         | unsigned int | 输出无符号的十进制整数 || x/X       | unsigned int | 输出无符号的十六进制整数，x对应 abcdef，X对应ABCDEF（没有前缀0x/0X） || f/lf      |    double    | 输出十进制表示的浮点数，默认精度为6 || e/E       |    double    | 输出科学计数法表示的数，e/E表示输出时的大小写，默认浮点数精度为6 || g         |    double    | 根据数值不同自动选择%f或%e，%e格式在指数小于-4或指数大于等于精度时用使用 || G         |    double    | 根据数值不同自动选择%f或%E，%E格式在指数小于-4或指数大于等于精度时用使用 || c         |     char     | 输出字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 || s         |     char *   | 输出字符串。输出字符串直至'\\0'，或者打印了指定的字符数精度 || p         |     void *   | 输出16进制形式的指针 || %         |    转义符号   | 输出字符%（百分号）本身 || n         |     int *    | 到此字符之前为止，一共输出的字符个数，不输出文本 |示例如下：  ```c++int a=30,b=20;int p;printf(\"a=%d, b=%d %n\\r\\n\", a, b, &amp;p);printf(\"%d %p\",p, &amp;p);/*输出： a=30, b=2011 0x7fff7c7c4ffc*/总结      sprintf、vsprintf和snprintf、vsnprintf的区别是后者可以指定写入缓冲区的字符串大小，大于指定字符数的写入将会被截断    sprintf、snprintf和vsprintf、vsnprintf的区别是前者接受多个参数，后者接受一个可变参数列表，后者适用于封装输出函数的场景    sprintf、snprintf、vsprintf、vsnprintf等相关函数定义在&lt;cstdio&gt;头文件中  Reference[1] C++ sprintf()[2] C语言printf(““)左对齐和右对齐[3] printf 格式化输出函数[4] C++ —— VA_LIST"
  },
  
  {
    "title": "C++ —— 条件变量cond",
    "url": "/posts/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcond/",
    "categories": "other, C++",
    "tags": "C++, cond, pthread.h",
    "date": "2023-03-27 17:13:00 +0800",
    





    
    "snippet": "条件变量cond  条件变量和信号量不同，它不是用于上锁，而是用来等待线程的，通常与互斥锁一起使用。条件变量可以阻塞当前线程，等待另一个线程完成某些任务，然后唤醒该线程，从而达到线程之间的同步要求。作用我们通常用互斥锁确保线程的异步安全，但是它不能完成线程之间的同步操作。比如对于A、B线程，互斥锁只能保证A线程执行过程中，B不会执行。但如果我们要确保A在B之前执行，那互斥锁就做不到了。而条件...",
    "content": "条件变量cond  条件变量和信号量不同，它不是用于上锁，而是用来等待线程的，通常与互斥锁一起使用。条件变量可以阻塞当前线程，等待另一个线程完成某些任务，然后唤醒该线程，从而达到线程之间的同步要求。作用我们通常用互斥锁确保线程的异步安全，但是它不能完成线程之间的同步操作。比如对于A、B线程，互斥锁只能保证A线程执行过程中，B不会执行。但如果我们要确保A在B之前执行，那互斥锁就做不到了。而条件变量就是用来满足这类场景的。我们可以主动等待一个条件变量，此时线程会挂起，等待另一个线程完成某些任务。当另一个线程唤醒一个或多个线程，这些唤醒的线程会重新上锁，然后测试条件是否满足。区别条件变量和信号量的区别：  条件变量可以一次唤醒所有等待线程，而信号量没有这个功能  信号量有一个值（大于零），而条件变量没有值，也就是说条件变量无法知道需要唤醒多少线程，唤醒过多少线程。反之，信号量可以指明可用资源的数量  这里要注意，因为条件变量没有值，所以唤醒条件变量的信号可能会丢失。比如我们先执行了唤醒操作，再执行等待操作：      signal –&gt; wait    此时，线程会进入无限地等待，因为signal发出的信号已经丢失了。为了解决这种情况，条件变量cond必须和互斥锁mutex配合使用。      lock –&gt; wait –&gt; unlock –&gt; lock –&gt; signal –&gt; unlock  定义条件变量相关的类定义在头文件中，定义如下：#include &lt;pthread.h&gt;pthread_cond_t  cond;    //  本质是一个结构体，可以简单看作一个整数1或0初始化sem_init()函数专门用来初始化信号量，语法如下：int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 其中，各个参数的含义为：  cond：表示要初始化的目标条件变量  attr：条件变量属性，通常为默认值NULL另外我们也可以通过静态初始化的方法来初始化条件变量：pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //  得到一个静态条件变量阻塞等待一个条件变量int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 这个函数的作用是：阻塞当前线程，并等待条件变量cond满足要求。阻塞的同时会释放已掌握的互斥锁，相对于pthread_mutex_unlock(&amp;mutex);由于阻塞的同时会释放已掌握的互斥锁，所以这里需要传入参数mutex。  需要注意，pthread_cond_wait函数的阻塞和释放锁过程是原子操作的。当条件变量被满足时，会唤醒线程，此时线程解除阻塞，但需要重新竞争互斥锁，相对于执行pthread_mutex_lock(&amp;mutex);它还有另一个等待条件变量的函数：int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 该函数和上面的pthread_cond_wait函数的区别是，它传入一个时间结构体，在限定时间内等待条件变量，如果超时则立即返回。这里传入的时间结构定义如下：struct timespec {    time_t tv_sec; /* seconds */ 秒    long   tv_nsec; /* nanosecondes*/ 纳秒}需要注意，这里传入的是一个绝对时间，也就是说如果我们将tv_sec赋值1秒，它的含义并不是比当前时间前进1秒，而是比绝对时间前进1秒，就像下面这样：struct timespec t = {1, 0}; //  赋值1秒pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); //  此时超时时间为1970年1月1日 00:00:01秒，会立刻返回正确的做法是这样的：struct timespec t = {0, 0};struct timeval now = {0, 0};  //  这个数据结构是用来获取当前时间的gettimeofday(&amp;now, NULL);     //  获取当前时间t.tv_sec = now.tv_sec + 1;    //  赋值1秒，1秒后超时返回m_cond.timewait(m_mutex.get(), t);唤醒阻塞线程int pthread_cond_signal(pthread_cond_t *cond);      //   唤醒至少一个线程int pthread_cond_broadcast(pthread_cond_t *cond);   //  唤醒全部阻塞的线程唤醒该条件变量上的所有线程，实现线程间的同步操作销毁条件变量int pthread_cond_destroy(pthread_cond_t *cond); 上面这些函数操作成功时，返回值都为0。但函数执行过程中发生错误，则返回非0值，比如：  cond指针为非法地址  执行wait函数，在等待过程被信号或fork() 中断  执行timedwait函数时，参数abstime时间无效  执行init函数时，参数type是不可识别的类型  执行destroy函数时，检测到多次执行了destroy函数销毁条件变量例子我们举一个阻塞队列的例子。这是一个生产者、消费者模型，队列写入是生产者，队列读取是生产者，如果队列为空时，当我们调用读取函数，应该使用条件变量阻塞线程，直到有数据写入队列中。读取函数如下：bool pop(T &amp;item){    m_mutex.lock();     //  上锁，保证线程安全    while(m_size &lt;= 0)  //  如果队列为空，则使用条件变量阻塞线程    {        //  唤醒后需要重新竞争互斥锁，这个过程可能条件变量又发生了变化，所以可能返回失败        if(pthread_cond_wait(m_cond, m_mutex.get()) != 0)        {            m_mutex.unlock();            return false;        }    }    //  读取队列中的数据    m_front = (m_front + 1) % m_max_size;    item = m_array[m_front];    m_size--;    m_mutex.unlock();    return true;}写入函数如下：bool push(const T &amp;item){    m_mutex.lock(); //  上锁，保证线程安全    if(m_size &gt;= m_max_size)    //  如果数据满了，唤醒条件变量上的线程读取数据    {        pthread_cond_broadcast(m_cond); //  唤醒全部阻塞在条件变量上的线程        m_mutex.unlock();        return false;    }    //  写入数据    m_back = (m_back + 1) % m_max_size;    m_array[m_back] = item;    m_size++;    m_cond.broadcast(); //  通知读取线程，有数据写入    m_mutex.unlock();    return true;}优点条件变量最重要的应用在生产者和消费者模型，当然如果没有条件变量，光靠互斥锁也能实现生产者和消费者模型，但是这会产生很多不必要的竞争。如果生产者没有生成出数据，消费者之间竞争互斥锁是没用意义的。所以条件变量最大的优点就是减少线程间的竞争，只用生产者完成了，才会引发消费者之间的竞争，提高程序效率。总结      条件变量可以阻塞当前线程，等待另一个线程完成某些任务，然后唤醒该线程，从而达到线程之间的同步要求    条件变量相关的类定义在头文件中  Reference[1] linux中条件变量和信号量的区别！[2] 条件变量详细解说[3] 相似的同步函数：条件变量"
  },
  
  {
    "title": "C++ —— 信号量semaphore",
    "url": "/posts/%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/",
    "categories": "other, C++",
    "tags": "C++, semaphore, semaphore.h",
    "date": "2023-03-27 17:13:00 +0800",
    





    
    "snippet": "信号量semaphore  信号量（Semaphore）的概念最早由荷兰计算机科学家 Dijkstra（迪杰斯特拉）提出，有时又称“信号灯”。信号量是多线程环境下的一个全局变量，它表示最多可以有几个任务同时访问某个共享资源。作用信号量的本质是一个全局变量，可以根据实际场景设置信号量的大小（取值范围&gt;=0）。信号量为N表示最多有N个进程或线程访问某个共享资源。此外，信号量支持“加1”和“...",
    "content": "信号量semaphore  信号量（Semaphore）的概念最早由荷兰计算机科学家 Dijkstra（迪杰斯特拉）提出，有时又称“信号灯”。信号量是多线程环境下的一个全局变量，它表示最多可以有几个任务同时访问某个共享资源。作用信号量的本质是一个全局变量，可以根据实际场景设置信号量的大小（取值范围&gt;=0）。信号量为N表示最多有N个进程或线程访问某个共享资源。此外，信号量支持“加1”和“减1”操作，而且修改值时是以“原子操作”的方式实现的。通过“加1”和“减1”来控制共享资源的访问线程数（信号量可用于线程或进程，为了方便，下面只用线程进行说明）。规则多线程程序中，使用信号量需遵守以下几条规则：  信号量的值不能小于 0  有线程访问资源时，信号量执行“减1”操作，访问完成后再执行“加1”操作  当信号量的值为0时，想访问资源的线程必须等待，直至信号量的值大于0，等待的线程才能开始访问分类  二进制信号量：指初始值为 1 的信号量，此类信号量只有 1 和 0 两个值，通常用来替代互斥锁实现线程同步  计数信号量：指初始值大于 1 的信号量，当进程中存在多个线程，可以用计数信号量来限制同时访问资源的线程数量定义信号量相关的类定义在头文件中，定义如下：#include &lt;semaphore.h&gt;sem_t mySem;    //  POSIX标准中，信号量用sem_t类型表示初始化sem_init()函数专门用来初始化信号量，语法如下：int sem_init(sem_t *sem, int pshared, unsigned int value);其中，各个参数的含义为：  sem：表示要初始化的目标信号量  pshared：表示该信号量是否可以和其他进程共享，值为0时表示不共享，值为1时表示共享  value：设置信号量的初始值  返回值：初始化成功返回0，否则返回-1操作信号量//  sem_post函数：将信号量的值“加1”，同时唤醒其它等待访问资源的线程int sem_post(sem_t* sem);//  sem_wait函数：//  当信号量的值大于0时，sem_wait函数会对信号量做“减1”操作；//  当信号量的值为0时，sem_wait函数会阻塞当前线程，直至有线程执行sem_post函数，暂停的线程才会继续执行int sem_wait(sem_t* sem);//  sem_trywait函数：和sem_wait函数类似，但信号量的值为0时，不会阻塞当前线程，而是立即返回-1int sem_trywait(sem_t* sem);//  sem_destory函数：销毁信号量int sem_destroy(sem_t* sem); 上面这些函数操作成功时，返回值都为0。例子我们通过一个例子说明信号量的用法： 假设我们有一个数据库连接池，连接池的最大连接为2。现在我们有5个请求需要操作数据库，他们需要竞争获取连接池，为了实现互斥访问连接池，我们使用信号量来实现。首先，我们定义5个线程表示5个数据库连接请求，因为连接池最大数量为2，所以信号量设为2。//\t信号量声明为全局变量sem_t sem;int main(){\t//\t用5个线程表示现在有5个数据库连接正在执行\tpthread_t conn[5];\t//初始化信号量，表示连接池最大数量为2    sem_init(&amp;sem, 0, 2);\t//\t创建5个线程，执行sql查询任务\tfor (int i = 0; i &lt; 5; i++)    {        int flag = pthread_create(&amp;conn[i], NULL, doSql, &amp;i);        if (flag != 0)        {            std::throw Exception(); //  线程创建失败        }        cout&lt;&lt;\"conn \" &lt;&lt; i &lt;&lt; \" 线程创建成功 \"&lt;&lt;endl;        usleep(1);    }\t\t//\t结束进程\tfor (int j = 0; j &lt; 5; j++)    {        int flag = pthread_join(conn[j], NULL);        if (flag != 0) {            std::throw Exception(); //  线程等待失败        }    }\t//\t销毁信号量    sem_destroy(&amp;sem);\t\treturn 0;}接着我们在doSql函数内，实现信号量的操作：void *doSql(void *arg){\tint id = *((int*)arg);\t//\t用信号量限制连接池，如果连接池为空，则阻塞程序\tif (sem_wait(&amp;sem) == 0)    {        //  从连接池中获取数据库连接        cout &lt;&lt; \"---conn \" &lt;&lt; id &lt;&lt; \" 正在执行sql \" &lt;&lt;endl;\t\t//\t数据库执行sql并返回结果        usleep(2);        cout &lt;&lt; \"---conn \" &lt;&lt; id &lt;&lt; \" 正在执行sql \" &lt;&lt;endl;        //  将数据库连接归还连接池        //\t信号量加1，表示归还连接到连接池，同时唤醒阻塞的线程        sem_post(&amp;sem);    }    return 0;}输出结果为：# 编译: g++ semaphoreTest.cpp -o semaphoreTest  -pthread# 执行：./semaphoreTest# 输出：conn 0 线程创建成功---conn 0 正在执行sql---conn 0 执行sql结束conn 1 线程创建成功---conn 1 正在执行sql---conn 1 执行sql结束conn 2 线程创建成功---conn 2 正在执行sql---conn 2 执行sql结束conn 3 线程创建成功---conn 3 正在执行sql---conn 3 执行sql结束conn 4 线程创建成功---conn 4 正在执行sql---conn 4 执行sql结束C++20信号量C++20中引入了信号量，存储在头文件&lt;semaphore&gt;中。头文件中的类分为counting semaphore和binary semaphore，对应上面的计数信号量和二进制信号量。总结      信号量是多线程环境下的一个全局变量，它表示最多可以有几个任务同时访问某个共享资源    信号量相关的类定义在头文件中  Reference[1] Linux信号量详解[2] C++ 多线程（七）：信号量 Semaphore 及 C++ 11 实现"
  },
  
  {
    "title": "C++ —— __VA_ARGS__用法",
    "url": "/posts/__VA_ARGS__%E7%94%A8%E6%B3%95/",
    "categories": "other, C++",
    "tags": "C++, precompile",
    "date": "2023-03-20 20:30:00 +0800",
    





    
    "snippet": "##VA_ARGS  在C++实现日志打印时，常常会用到__VA_ARGS__或##__VA_ARGS__符号，它的作用是在宏中将可变参数的内容替换掉__VA_ARGS__的内容作用__VA_ARGS__在宏中将函数的可变参数进行替换，##__VA_ARGS_则在__VA_ARGS__基础上，使可变参数为零时，去掉参数前面的逗号。VA_ARGS__VA_ARGS__的用法例子如下：#incl...",
    "content": "##VA_ARGS  在C++实现日志打印时，常常会用到__VA_ARGS__或##__VA_ARGS__符号，它的作用是在宏中将可变参数的内容替换掉__VA_ARGS__的内容作用__VA_ARGS__在宏中将函数的可变参数进行替换，##__VA_ARGS_则在__VA_ARGS__基础上，使可变参数为零时，去掉参数前面的逗号。VA_ARGS__VA_ARGS__的用法例子如下：#include &lt;stdio.h&gt;#define Log(fm, ...) printf(fm, __VA_ARGS__) // ...表示可变参数，__VA_ARGS__就是将...的值复制到这里int main(){    // 输出可变参数    Log(\"tow argument: %s %d\\n\", \"hello world!\", 2023); //OK    // Log(\"no argument\");    // error    return 0;}输出如下：tow argument: hello world! 2023当我们调用Log(“no argument”);时，却报错了：VA_ARGS.cpp: In function ‘int main()’:VA_ARGS.cpp:3:43: error: expected primary-expression before ‘)’ token #define Log(fm, ...) printf(fm,__VA_ARGS__)                                            ^VA_ARGS.cpp:9:5: note: in expansion of macro ‘Log’     Log(\"987654321\");    //输出字符串常量报错这里报错的原因是因为字符串no argument赋给了fm，__VA_ARGS__的值为空，宏替换后函数变为printf(“no argument”,)，末尾的这个逗号很明显是语法错误的。为了解决这个问题，我们可以使用##__VA_ARGS__宏。##VA_ARGS#include &lt;stdio.h&gt;#define Log(fm, ...) printf(fm,##__VA_ARGS__) // ##__VA_ARGS__可以去掉前面的逗号int main(){    //输出可变参数    Log(\"tow argument: %s %d\\n\", \"hello world!\", 2023); // OK    Log(\"no argument\\n\");  // OK    return 0;}输出结果为：tow argument: hello world! 2023no argument总结      __VA_ARGS__的作用是在宏中将可变参数的内容替换掉__VA_ARGS__的内容    ##__VA_ARGS__可以使__VA_ARGS__为空时，去掉前面的逗号  Reference[1] ##__VA_ARGS__与##args的用法"
  },
  
  {
    "title": "C++ —— getopt函数用法",
    "url": "/posts/getopt%E5%87%BD%E6%95%B0/",
    "categories": "other, C++",
    "tags": "C++, unistd.h",
    "date": "2023-03-17 15:39:00 +0800",
    





    
    "snippet": "getopt函数用法  getopt()被用来解析命令行选项参数作用getopt()是用来解析命令行选项参数的，使我们自己不需要编写代码处理命令行参数argv。函数定义#include &lt;unistd.h&gt;     //  头文件extern char *optarg;    //  返回选项的参数extern int optind,      //  记录下一次调用getopt...",
    "content": "getopt函数用法  getopt()被用来解析命令行选项参数作用getopt()是用来解析命令行选项参数的，使我们自己不需要编写代码处理命令行参数argv。函数定义#include &lt;unistd.h&gt;     //  头文件extern char *optarg;    //  返回选项的参数extern int optind,      //  记录下一次调用getopt的选项位置 extern int opterr,      //  是否输出错误信息，当opterr=0时，不向stderr输出错误信息extern int optopt;      //  返回选项对应的ascii码，或返回'?'符号int getopt(int argc, char * const argv[], const char *optstring);   //  函数定义参数解析  int argc： main函数参数，表示命令行提供的参数个数  char * const argv[]： main函数参数，表示命令行提供的参数的字符指针  const char *optstring： 判断命令行参数的表达式，具体规则如下：  单个字符，表示选项const char* optstring = \"a\";//  调用时命令为：./run -a  单个字符后接一个冒号(:)，表示该选项后必须跟一个参数，选项和参数通过空格隔开，未跟参数则报错const char* optstring = \"a:\";//  调用时命令为：./run -a 100//  如果调用: ./run -a，则会报错//  报错信息为：./run: option requires an argument -- 'a'  单个字符后接两个冒号(:)，表示该选项后必须跟一个参数，参数紧跟在选项后面，即不能使用空格隔开，未跟参数或参数和选项之间有空格则参数为NULLconst char* optstring = \"a:\";//  调用时命令为：./run -a100//  如果调用: ./run -a 100，则参数100会读取失败如果读取了一个命令行存在，但是optstring中没有指定的选项，则会报错，报错信息为：./run: invalid option -- 'a'optstring示例const char* optstring=\"ab:c::d::\";//  命令行输入：./run -a -b para1 -cpara2 -d para3/*  分析：1. a后面没有冒号，读取选项-a，对应参数为NULL2. b后面有一个冒号，读取选项-b，对应参数为para13. c后面有两个冒号，读取选项-c，对应参数为para24. d后面有两个冒号，读取选项-d，但由于-d和para3之间有空格，所以para3参数读取失败，-d的对应参数为NULL*/这里有一点要注意，默认情况下getopt会重新排列命令行参数的顺序，不包含在optstring的命令行参数会被排到最后。就像下面这样：const char* optstring=\"ab:c::d::\";...     //  调用getopt读取命令行参数for(int i=0;i&lt;argc;i++){    cout&lt;&lt; i &lt;&lt; \" \" &lt;&lt; argv[i] &lt;&lt; endl; //  输出命令行参数内容}//  命令行输入：./run -a para0 -b para1 -c para2 -dpara3 /*  程序输出：0  ./getopt1  -a2  -b3  para14  -c5  -dpara36  para07  para2/*可以看到para0虽然输入时排在-b之前，但是经过getopt()修改顺序之后，排到了末尾的尾置。para2同理。所以不包含在optstring的命令行参数会被排到最后。optopt、optind和optarg  optopt是getopt()方法的返回值，如果匹配成功，则返回选项对应的ascii码，否则找不到符合的参数，则报错并且返回’?’(ascii码为63)。当getopt()方法分析结束，则返回-1。const char* str=\"ab:c::d::\";while((opt = getopt(argc, argv, str)) != -1){    cout&lt;&lt; \"opt \" &lt;&lt; opt &lt;&lt;endl;}//  输入：./run -a , 输出：opt 97//  输入：./run -b , 输出：opt 63 (选项后面未跟参数)//  输入：./run -e , 输出：opt 63 (optstring中没有e)  optind记录的是下一个需要分析的字符串的索引，我们可以通过argv[optind]获得下一个字符串。const char* str=\"ab:c::d::\";while((opt = getopt(argc, argv, str)) != -1){    cout&lt;&lt; \"opt \" &lt;&lt; opt &lt;&lt;endl;    cout&lt;&lt; \"argv[optind] \" &lt;&lt; argv[optind] &lt;&lt;endl;    }/*输入：./run -a para0 -b para1 -c para2 -dpara3输出：opt 97              //  第一个处理的选项-aargv[optind] para0  //  下一个处理的字符串是para0opt 98              //  由于para0不匹配，所以处理-b para1argv[optind] -c     //  下一个处理的字符串是-copt 99              //  处理选项-cargv[optind] para2  //  下一个处理的字符串是para2opt 100             //  由于para2不匹配，所以处理-dpara3*/  optarg是一个字符指针，记录了选项后跟着的参数。如果没有跟着参数或者报错，则optarg为NULL。通常与switch语句一起使用。const char *str = \"p:l:m:o:s:t:c:a:\";while((opt = getopt(argc, argv, str)) != -1){    switch (opt)    {    case 'p':    {        PORT = atoi(optarg);        break;    }    ...    default:        break;    }}//  输入：./run -p 8888， 则optarg内容为8888//  输入：./run -b 8888， 则optarg内容为NULL (-b不匹配)getopt_longgetopt函数的定义：#includeint getopt(int argc, char * const argv[],        const char *optstring); extern char *optarg;extern int optind, opterr, optopt;  #define _GNU_SOURCE#include int getopt_long(int argc, char * const argv[],        const char *optstring,        const struct option *longopts,        int *longindex); int getopt_long_only(int argc, char * const argv[],        const char *optstring,        const struct option *longopts,        int *longindex);这里我们主要解释一下getopt_long()函数。getopt_long中，参数argc,argv,optstring与上面getop()函数相同。我们重点关注参数longopts。longopts是一个结构体，其定义为：struct option {  const char *name;    //  name为选项的标识  int has_arg;    /*  has_arg有3个值:        no_argument(或0): 表示该参数后面不跟参数值        required_argument(或1): 表示该参数后面一定要跟个参数值        optional_argument(或2): 表示该参数后面可以跟，也可以不跟参数值    */  int *flag;    //  决定getopt_long()的返回值。如果flag是null，则函数返回val值  int val;    //  返回值(和flag联合决定)}longopts结构体例子：struct option long_options[] = {    {\"m_a\",required_argument,0,'a'},    {\"m_c\",no_argument,0,'c'},}opt = getopt_long(argc, argv, \"a:c\", long_options, NULL)//  输入：./run -a 100，输出：opt为a，optarg为100//  输入：./run -c，输出：opt为c，optarg为NULL总结      getopt()被用来解析命令行选项参数，返回值为成功匹配的字符ascii码或’?’的ascii码，选项携带的参数则有optarg保存  Reference[1] getopt()用法详解"
  },
  
  {
    "title": "刷题笔记 —— 复杂链表的复制",
    "url": "/posts/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/",
    "categories": "leetcode",
    "tags": "leetcode, Linked list",
    "date": "2023-03-16 16:39:00 +0800",
    





    
    "snippet": "链表  复杂链表的复制问题是链表指针比较复杂的情况下，如何原地进行深复制题目请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。例子示例1输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null]...",
    "content": "链表  复杂链表的复制问题是链表指针比较复杂的情况下，如何原地进行深复制题目请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。例子示例1输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]示例2输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]示例3输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]示例4输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。条件  -10000 &lt;= Node.val &lt;= 10000  Node.random 为空（null）或指向链表中的节点。  节点数目不超过 1000 。难点分析链表指针比较复杂，复制过程中，random指向的结点可能存在也可能不存在，同时链表的数据结构难以随机定位某个结点，使得random所指向的指针难以直接获得。很容易想到使用哈希表的方法来定位某个结点，但是面试中哈希表的方法并不能让人满意。所以不用哈希表，原地实现复杂链表的深复制是本题的难点。解法解法1：哈希表+常规解法class Solution {public:    Node* copyRandomList(Node* head) {        //  考虑链表为空的情况        if(head==NULL) return NULL;        unordered_map&lt;Node*,Node*&gt; dist;        Node *newList=new Node(-1), *r=newList;        Node* p=head;        while(p!=NULL){            Node *q=NULL;            //  如果p的复制结点已经存在，则直接从哈希表中读取            //  否则，复制p对应的结点，存入哈希表中            if(dist.find(p)!=dist.end()){                q=dist[p];            }else{                q=new Node(p-&gt;val);                dist[p]=q;            }            //  如果p-&gt;next不为空，且对应复制结点已经存在，则直接从哈希表中读取            //  如果p-&gt;next不为空，且对应复制结点不存在，则创建该结点并存入哈希表中            //  如果p-&gt;next为空，说明走到链表末尾，复制结点q-&gt;next也为空            if(p-&gt;next!=NULL){                if(dist.find(p-&gt;next)!=dist.end()){                    q-&gt;next=dist[p-&gt;next];                }else{                    Node *t=new Node(p-&gt;next-&gt;val);                    dist[p-&gt;next]=t;                    q-&gt;next=t;                }            }else{                q-&gt;next=NULL;            }            //  根据上面类似的过程处理random指针            if(p-&gt;random==NULL){                q-&gt;random=NULL;            }else{                if(dist.find(p-&gt;random)!=dist.end()){                    q-&gt;random=dist[p-&gt;random];                }else{                    Node *t=new Node(p-&gt;random-&gt;val);                    dist[p-&gt;random]=t;                    q-&gt;random=t;                }            }            //  移动链表，复制下一个结点            r-&gt;next=q;            r=q;            p=p-&gt;next;        }        return newList-&gt;next;    }};解法2：哈希表+回溯法class Solution {public:    //  创建一个哈希表    unordered_map&lt;Node* ,Node*&gt; dist;    Node* copyRandomList(Node* head) {        if(head==NULL) return NULL;        Node* p=NULL;        //  如果复制结点不存在，则创建一个结点，并存入哈希表中，并递归创建next和random指向的结点        if(dist.find(head)==dist.end()){            p=new Node(head-&gt;val);            dist[head]=p;            p-&gt;next=copyRandomList(head-&gt;next);            p-&gt;random=copyRandomList(head-&gt;random);        }else{            //  复制结点已存在，返回该复制结点            p=dist[head];        }        return p;    }};解法3：扩展链表 + 节点拆分class Solution {public:    Node* copyRandomList(Node* head) {        if(head==NULL) return head;        //  在原有链表的结点后面复制一个结点，即        //  A-&gt;B-&gt;C ==&gt; A-&gt;A`-&gt;B-&gt;B`-&gt;C-&gt;C`        Node *p=head;        while(p!=NULL){            Node *q=new Node(p-&gt;val);            q-&gt;next=p-&gt;next;            p-&gt;next=q;            p=q-&gt;next;        }        //  修改复制结点的random指针        p=head;        while(p!=NULL){            if(p-&gt;random!=NULL){                p-&gt;next-&gt;random=p-&gt;random-&gt;next;            }            p=p-&gt;next-&gt;next;        }        //  将链表拆分为两个链表        p=head;        Node *res=head-&gt;next,*q=res;        while(p!=NULL){            p-&gt;next=p-&gt;next-&gt;next;            p=p-&gt;next;            if(q-&gt;next!=NULL){                q-&gt;next=q-&gt;next-&gt;next;                q=q-&gt;next;            }        }        return res;    }};Reference[1] 复杂链表的复制"
  },
  
  {
    "title": "读书笔记 —— Effective C++ (异常安全)",
    "url": "/posts/Effective-C++_%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2023-03-15 15:16:00 +0800",
    





    
    "snippet": "  本节中我们探讨异常安全代码，首先我们通过一个例子指出这个例子中存在的异常不安全行为。在解决这些行为之前，我们先认识一下异常安全保证的等级。这很重要，因为我们需要根据选择的异常安全保证来解决例子中的问题。通常的解决方法有调换代码逻辑顺序，用智能指针管理对象。接着我们提出了一般化的异常安全代码设计策略，copy-and-swap。最后我们强调了并不是任何代码都可以改写成异常安全的，首先是异常...",
    "content": "  本节中我们探讨异常安全代码，首先我们通过一个例子指出这个例子中存在的异常不安全行为。在解决这些行为之前，我们先认识一下异常安全保证的等级。这很重要，因为我们需要根据选择的异常安全保证来解决例子中的问题。通常的解决方法有调换代码逻辑顺序，用智能指针管理对象。接着我们提出了一般化的异常安全代码设计策略，copy-and-swap。最后我们强调了并不是任何代码都可以改写成异常安全的，首先是异常安全代码需要时间和空间成本，这些成本可能在现实场景中无法满足。其次，一个函数的异常安全等级由它内部调用子函数的最低异常安全等级决定。所以当我们设计一个异常安全系统的时候，应该仔细斟酌它需要提供什么样的异常安全保证，然后在现实可行的情况下，尽量去实现最强烈的异常安全保证。异常安全异常安全在编程中十分重要，它指的是我们的程序哪怕出现了异常，也能处于某种安全状态，而不是某种不确定的状态。先让我们来看一个例子：//  修改背景的函数void PrettyMenu::changeBackground(istream&amp; imgSrc){    lock(&amp;mutex);               //  上锁    delete bgImage;             //  删除旧的背景图    ++imageChanges;             //  背景图计数器加一    bgImage=new Image(imgSrc);  //  安装新的背景图    unlock(&amp;mutex);             //  解锁}这个函数功能很简单，但是它是异常不安全的。异常安全性有两个条件，我们从这两个条件来阐述这个函数为什么是不符合异常安全的。      不泄露任何资源。如果lock之后的某一步发生了异常，因为发生异常后，后面的代码都不会执行，所以unlock自然也不会执行。这就导致了程序互斥器并没有解锁，也就是发生了资源泄漏。        不允许数据败坏。如果我们新的背景图安装失败，旧的背景图删除了，所以程序会处于没有背景图的状态。另外，背景图计数器加一，但是背景图并没有成功安装，这就导致了数据败坏。  异常安全级别在探讨解决方法之前，我们先来了解一下异常安全函数的三个等级（或者说提供的三个保证）。然后我们根据实际情况，为函数提供相应的异常安全级别。      基本承诺如果异常被抛出，程序内的任何事物仍然保持在有效状态下。就像上面的changeBackground函数，如果该函数抛出异常，我们承诺它的背景图仍然是有效的。但是它提供了一个最基本的承诺，也就是说，虽然背景图仍然可以显示，但我们无法确定当前显示的背景图是新的背景图还是旧的背景图，抑或是某个缺省背景图。        强烈保证如果异常被抛出，程序状态保持不变。就像数据库的一致性，如果函数成功，则完全成功；如果函数失败，则退回到调用函数前的状态。        不抛掷保证（nothrow）承诺绝不抛出异常，因为它们总能够完成原先承诺的功能。这是最高级别的保证，比如内置类型（int，指针）身上的所有操作都是提供nothrow保证的。    这里需要注意，承诺nothrow并不是指函数中声明了nothrow。C++中函数可以声明nothrow，承诺函数不会抛出异常，但这只是一个虚幻的承诺，是否抛出异常由函数的实现决定，而不是nothrow声明决定。如果声明了nothrow的函数抛出异常，异常行为由set_unexpected设置的行为（exit或abort）决定$^{[3]}$。  int doSomething() nothrow;    //  声明不抛出异常，不代表真的不会抛出异常int doSomething() throw();    //  声明不抛出异常的另一种写法  任何异常安全的代码都需要提供上述三种保证之，否则它就不具备异常安全性。所以如果我们需要把代码写成异常安全的，首先需要思考为我们的函数提供哪一种安全保证。当然，最强烈的异常保证（不会抛出任何异常）肯定是最好的，但是现实中很难做到。比如所有STL容器，申请动态内存空间时，都可能抛出bad_alloc异常。所以，可能的话请提供nothrow保证。但是对于大多数函数而言，抉择往往落在基本保证和强烈保证之间。现在让我们回到changeBackground函数，并将它改造为异常安全的。首先我们尝试为该函数提供强烈保证。  针对第一个问题，lock之后发生异常会泄漏内存，unlock函数并没有执行，我们用智能指针来指向互斥器。在delete bgImage时，也可能因为发生异常，而导致内存泄漏，我们同样使用智能指针来管理。智能指针管理的内存，无论是否发生异常，当运行到代码块的末端时，都会执行释放内存操作。```c++//  这里我们定义一个类来封装互斥器操作class Lock{   public: explicit Lock(Mutex* pm): MutexPtr(pm,unlock)   //  传递unlock函数给删除器 {     lock(MutexPtr.get());   //  构造函数中上锁 }private: std::tr1::shared_ptr MutexPtr;};//  改造后的changBackground函数void PrettyMenu::changeBackground(istream&amp; imgSrc){    Lock m1(&amp;mutex);            //  上锁，运行结束能自动解锁    delete bgImage;             //  删除旧的背景图    ++imageChanges;             //  背景图计数器加一    bgImage=new Image(imgSrc);  //  安装新的背景图}2. 针对第二个问题，数据败坏——例如安装新的背景图失败，计数器却完成了加一操作，我们调换一下语句顺序。只有新的背景图安装完成，计数器才能加一。这样提供了强烈保证——新背景图安装成功，计数器加一；安装失败，则计数器和调用前状态一致。  对于另一个问题：新的背景图安装失败，但是旧的背景图早已经被删除，我们同样调换一下顺序，先创建Image对象，再完成删除操作。如果Image对象创建失败，则原来的背景图没有被delete，程序保持原来的背景图；如果创建成功，那就用新的背景图替换旧的背景图。这样就能为changeBackground函数提供强烈保证。这里我们采用智能指针管理bgImage成员。```c++//  修改原来的类中，背景图bgImage的存储方式class PrettyMenu{    ...    std::tr1::shared_ptr&lt;Image&gt; bgImage;    //  用智能指针管理对象    ...};//  改造后的changBackground函数void PrettyMenu::changeBackground(istream&amp; imgSrc){    Lock m1(&amp;mutex);                    //  上锁，运行结束能自动解锁    bgImage.reset(new Image(imgSrc));   //  替换背景图    ++imageChanges;                     //  先替换背景图，再修改计数器}注意，这里不需要手动delete原来的背景图，因为这个动作已经由智能指针内部完成了。删除动作只会发生在new Image(imgSrc)动作完成之后，也就是说new Image(imgSrc)执行成功了，才会替换和删除背景图。如果系统未进入reset函数，也绝不会使用delete。所以，改造后的changBackground函数调用前后状态能保持一致。但是改造后的函数还有一点美中不足：我们传入参数的是一个输入流istream，如果Image构造函数抛出异常，该输入流的读取记号(read marker)已被移走。也就是说对于程序的其他部分，输入流istream发生了变化，调用前和调用后的参数状态不一致。我们只要改变参数类型（由引用改为传值），或者传入图像数据的名称就可以解决这个问题。copy and sawp策略接下来我们提供一种一般化的设计策略来提供强烈保证，这个策略叫做copy and swap。它的原则是：我们生成一个副本，然后对这个副本进行修改。如果修改时抛出异常，由于原对象没有任何修改，所以原对象还是修改前的状态；如果修改成功，我们将原对象和副本进行交换。这里的swap置换函数必须不抛出异常，当然着很容易实现（我们上面说了，交换内置类型和指针，往往可以保证不抛出异常）。就像下面这样：//  这里将原来的类改造为pimpl idiom结构，便于我们高效地实现swapstruct PMImpl{  //  struct和class区别不大，struct更适合看成一个数据结构，class更适合看成一个对象    std::tr1::shared_ptr&lt;Image&gt; bgImage;    int imageChanges;};class prettyMenu{    ...private:    Mutex mutex;    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;};//  改造后的changBackground函数void PrettyMenu::changeBackground(istream&amp; imgSrc){    using std::swap;    Lock m1(&amp;mutex);                    //  上锁，运行结束能自动解锁    //  创建副本    std::tr1::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl));    //  修改副本    pNew-&gt;bgImage.reset(new Image(imgSrc));    ++pNew-&gt;imageChanges;    //  置换副本    swap(pImpl, pNew);}copy and swap策略是使对象状态全部实现或者全部不实现的一种很好的办法。但是它也存在一些问题。  首先它并不总能保证整个函数是强烈异常安全的。我们来看下面这个例子：    void someFunc(){ ... f1(); f2(); ...}      f1和f2函数都是强烈异常安全的，如果f1成功执行，f2随后抛出了异常，那么此时程序状态和someFunc被调用前的程序状态不同。这是由于连带影响(side effects)。如果函数只操作局部性状态(local state)，则很容易提供强烈保证。但是如果函数对非局部性数据(non-local state)进行操作时，提供强烈保证就困难多了。举个例子，比如f1修改了数据库某个字段，f2抛出了异常，那么没有什么做法可以使数据库操作取消和恢复。  为每一个数据复制一个副本，然后进行置换，这种做法比原来的做法需要更多的时间和空间成本。现实中，效率和复杂性带来的成本可能使我们不能提供强烈保证。例如在一个对时间要求很高，且数据结构较大的系统中，复制和置换的成本是我们不能接受的，这时候我们只能退而求其次，提供基本保证。不存在局部异常安全继续看刚刚的someFunc函数代码，如果f2无法提供异常安全性，那么someFunc函数甚至无法提供最基本的保证。因为一旦f2抛出异常，程序有可能在f2内泄漏资源，或者败坏数据。someFunc函数无法在外层调用解决这些问题。也就是说如果someFunc调用的函数无法提供任何异常安全保证，那么someFunc自身也无法提供任何保证。所以一个软件系统要不具有异常安全性，要不就不具有异常安全性，没有所谓的局部异常安全性。最后我们应该挑选“现实可实施”条件下最强的异常安全等级。借用书中的一段话来结尾：四十年前，满载goto的代码被视为一种美好实践，而今我们却致力写出结构化控制流(structred control flows)。二十年前，全局数据(globally accessible data)被视为一种美好实践，而今我们却致力于数据的封装。十年前，撰写“未将异常考虑在内”的函数被视为一种美好实践，而今我们致力于写出“异常安全码”。总结      较少的代码更好，这意味着出错的机会更少，而且一旦修改，被误解的机会也更少    异常安全函数即使发生异常也不会造成资源泄漏和数据败坏，这样的函数分为三种可能的保证：基本型、强烈型、不抛出异常型    强烈保证往往可以用copy-and-swap实现，但是强烈保证的函数并非对所有很多都可实现或具备现实意义    函数提供的异常安全保证由其所调用的各个函数决定，最高的异常保证性取决于调用函数中的异常安全保证的最弱者  Reference[1] «Effective C++»[2] «C++ Primer»[3] std::set_terminate 和 std::set_unexpected  [4] c++ 中 class 和 struct 的区别是什么"
  },
  
  {
    "title": "读书笔记 —— C++ 异常处理",
    "url": "/posts/C++_%E5%BC%82%E5%B8%B8/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, Expection",
    "date": "2023-03-14 14:25:00 +0800",
    





    
    "snippet": "异常处理  异常处理(expection handing)机制是程序中独立开发的一个部分，它能够对运行时出现的问题进行通信并做出相应的处理。异常使我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，当问题出现后将该错误信息传递给程序的另一部分，由程序的另一部分解决该问题。这样，检测环节无需知道问题处理模块的所有细节，反之亦然。本章中我们介绍了异常的抛出和捕获过程。捕获过程...",
    "content": "异常处理  异常处理(expection handing)机制是程序中独立开发的一个部分，它能够对运行时出现的问题进行通信并做出相应的处理。异常使我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，当问题出现后将该错误信息传递给程序的另一部分，由程序的另一部分解决该问题。这样，检测环节无需知道问题处理模块的所有细节，反之亦然。本章中我们介绍了异常的抛出和捕获过程。捕获过程以栈展开的形式进行，匹配过程中类型转换还会受到限制，且栈展开过程中局部对象会被销毁。我们要注意析构函数不要抛出自身不能处理的异常，在文中我们将对其做出解释。接着我们介绍了异常对象即异常类的体系结构。C++中我们能通过(…)语法捕获所有异常，捕获所有异常通常与重新抛出一起使用。对于构造函数初始化列表中的异常，我们可以通过函数try语句块来捕获。最后我们介绍了异常说明符、异常运算符，以及函数指针和虚函数中异常说明需要保持一致的问题。异常抛出在C++中，我们可以通过抛出(throwing)一条表达式来引发(raised)一个异常。就像下面这样：//  抛出一个字符串throw \"error\";//  抛出一个对象std::bad_alloc t;throw t;根据抛出的对象和内容，程序的抛出部分会告知程序的异常处理部分发生了什么错误。这里需要我们注意，当我们执行一个throw后，throw后面的语句不会再执行。程序的控制权会由throw转移到与之匹配的catch模块上。就像下面这样：try{    ...     //  异常发生后，前面创建的对象会被销毁    std::bad_alloc t;    throw t;    ...     //  后面的代码不会执行}catch(std::bad_alloc &amp;e){    //  throw语句执行后，控制权来到catch模块    cerr &lt;&lt;e.what()&lt;&lt;endl;}...    //   执行完catch模块后，程序从这里继续执行这里有两个重要信息：  调用链的函数可能会提早退出  一旦程序开始处理异常代码，则沿着调用链创建的局部对象会被销毁栈展开刚刚我们提到，程序throw之后，会进入catch模块，那如果有多个catch模块呢？它会进入哪一个？首先进入哪一个catch模块是由抛出表达式（或对象）的类型和当前调用链共同决定的，感觉抛出表达式（或对象）的类型，会选中调用链中与该类型匹配的最近的catch模块。接下来我们看一下详细的流程：  当抛出一个异常后，程序暂停当前函数的执行过程，并寻找与该异常匹配的catch子句  当throw出现在一个try语句块内，检测与该try块关联的catch子句  如果找到匹配的catch，就用该catch模块处理异常  如果没找到匹配的catch，且该try语句嵌套在其他try块中，则检测外层try块匹配的catch子句  如果还是找不到匹配的catch，则退出当前函数，在外层函数中检测try块匹配的catch子句  如果依然找不到匹配的catch，继续退出当前函数，在更外层函数中检测try块匹配的catch子句  依此类推，直到找到匹配的catch或者退出主函数这个寻找匹配的catch的过程叫做栈展开(stack unwinding)。如果我们找到匹配的catch，执行完对应的catch模块后，会从try关联的最后一个catch子句之后的代码继续执行。而如果我们一直没找到匹配的catch，程序就会调用标准库函数terminate，终止当前程序。栈展开过程中对象会自动销毁在栈展开的过程中如果退出了某个块，编译器将这个块创建的对象正确地销毁。  如果异常发生在构造函数中，则当前的对象可能只构造了一部分，即有的成员已经初始化了，而有的成员没有初始化。这种情况下，我们要确保已经构造的成员被正确地销毁。  如果异常发生在数组或者标准库容器的元素初始化过程中，可能异常发生之前已经构造了一部分元素，这时候我们要确保已经构造的元素被正确地销毁。析构函数和异常析构函数负责释放资源，但存在这么一种情况，释放资源之前发生了异常，然后剩余的释放资源的部分将不会被执行。就像下面这样：~ClassName::ClassName(){ //  析构函数    doSomething();  //  发生了异常    delete data;    //  释放资源                    //  由于上面发生了异常，delete语句不会执行}为了解决这个问题，我们可以用智能指针（比如shared_ptr）来控制资源的释放，无论析构函数中是否发生了异常，当程序运行到作用域的末尾时，shared_ptr指针会检查计数器，从而正确地释放该资源（unique_ptr也可以做到）。最后，析构函数不应该抛出不能被它自身处理的异常。也就是说，如果析构函数可能发生某个异常，应该将该操作放置在try块中，并在析构函数内部处理。就像下面这样：~ClassName::ClassName(){    try    {        do_something();    }    catch()    {          //这里可以什么都不做，只是保证catch块的程序抛出的异常不会被扔出析构函数之外    }}析构函数不能抛出异常的原因有以下两点：  如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。  通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。异常对象异常对象(expection object)是一种特殊的对象，编译器使用异常抛出的表达式来对异常对象进行拷贝初始化。  这里注意，throw语句中的表达式必须拥有完全类型，即必须实现定义。如果表达式是类类型的话，必须实现一个可访问的析构函数和拷贝或移动构造函数。如果表达式是数组或者函数类型，则表达式将被转换成与之对应的指针类型。异常对象位于编译器管理的空间中，编译器确保无论调用哪个catch子块都能访问该空间。当异常处理完毕后，异常对象会被销毁。就像下面这样：try{    throw Exception3(); //  这不是一个局部对象，并不会随着当前作用域结束而销毁}catch(Exception1 ex){      ex.what();  //  输出错误信息}catch(Exception2 ex){    ex.what();}catch(Exception3 ex){  //  异常对象可以在3个catch子块中被访问    ex.what();    //  异常处理完毕后，异常对象才被销毁}  这里需要我们注意，因为退出某个块时，这个块内的局部对象也会被销毁，所以我们不能抛出一个指向局部对象的指针。捕获异常catch子句(catch clause)中的异常声明(exception declaration)看起来像是只包含一个形参的函数形参列表。和函数形参一样，形参名可以省略，就像下面这样：catch (Exception) {  //  省略形参名    doSomething();}声明的类型决定了代码能捕获什么样的异常。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。 当我们进入一个catch语句后，通过异常对象初始化异常声明中的参数。如果catch是一个非引用类型，则该参数是异常对象的一个副本；如果参数是引用类型，则该参数是异常对象的一个别名，此时修改参数也会改变异常对象。catch的参数还有一个特性和函数类似：如果catch的参数是基类类型，可以用派生类类型初始化。此时，如果catch参数是非引用类型，则异常对象的副本会被切掉一部分。如果catch参数是引用类型，则该参数会以常规方式绑定到异常对象上。也就是说，如果参数是基类，则catch中无法使用派生类特有的成员。就像下面这样：//  定义一个基类的异常类class BaseException: public exception {public:\tvoid what() {\t\tcout &lt;&lt; \"BaseException what()\" &lt;&lt; endl;\t}};//  定义一个派生类的异常类class DerivedException: public BaseException {public:\tvoid what() {\t\tcout &lt;&lt; \"DerivedException what()\" &lt;&lt; endl;\t}};//  主函数int main() {\ttry {        throw DerivedException();   //  抛出派生类\t}\tcatch (BaseException ex) {  //  非引用类型，会被切掉一部分\t\tex.what();  //  输出BaseException what()\t}    catch (BaseException&amp; ex) {  //  引用类型，但不能使用派生类特有的方法\t\tex.what();  //  输出BaseException what()\t}\treturn 0;}查找匹配的处理代码在寻找catch的匹配时，我们最终找到的不一定是最佳匹配，而是第一个与异常匹配的catch语句。所以，越是专门的catch越应该置于整个catch列表的前端。同理，派生类的异常处理代码应该放在基类的处理代码之前。除此之外，catch语句中形参与实参的匹配规则会有许多限制，绝大多数转换是不被允许的，我们总结为以下四点：  允许从非常量类型转换为常量类型  允许从派生类转换为基类  允许数组转换为数组指针，函数转换为函数指针  其他所有的转换规则都不被允许重新抛出有时候，一个单独的catch语句不能完整地处理整个异常，在执行某些校正操作之后，需要由更上一层函数接着处理异常。这时候我们可以通过重新抛出(rethrowing)的操作将异常传递给另一个catch语句。重新抛出的语法如下：catch (Exception ex) {    doSomething();    throw;}//  注意不能写出这样catch (Exception ex) {    doSomething();    throw ex;   //  错误，这样会抛出一个副本，而不是原来的异常}空的throw语句只能出现在catch语句或者catch语句直接或间接调用的函数之内。如果在catch模块之外使用了空throw语句，则编译器会调用terminate。 很多时候，catch语句会改变参数的内容，如果我们希望改变之后的内容重新抛出，则catch的异常声明应该是引用类型。就像下面这样：catch (BaseException ex) {  //  非引用类型    set_status(ex);         //  改变状态    throw;                  //  只修改了异常对象的局部副本}catch (BaseException&amp; ex) { //  引用类型    set_status(ex);         //  改变状态    throw;                  //  修改了异常对象}捕获所有异常的处理代码我们可以用省略号作为异常声明，这样程序会捕获所有异常(catch-all)。就像下面这样：catch (...) {   //  捕获任意类型的异常    doSomething();    throw;      //  修改了异常对象}catch(…)通常和重新抛出语句一起使用，catch子句中执行当前局部能完成的工作后，重新抛出异常。catch(…)既能单独出现，也可以与其他catch语句一同出现。如果catch(…)与其他几个catch语句一同出现时，catch(…)必须在最后的位置，因为出现在catch(…)后面的语句永远不会被匹配。函数try语句块和构造函数构造函数是这样实现的：Blob::Blob(std::initializer_list&lt;string&gt;):data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)){    try{        doSomething();  //  其他初始化操作    }catch(Exception e){        e.what();    }}如果我们需要在构造函数内加try-catch块，会有一个问题。那就是成员变量data在进入函数体之前先执行初始化列表，如果初始化列表的过程发生异常，try中的语句块还未生效，所有函数体内的catch语句也无法处理初始化列表中抛出的异常。想要处理构造函数初始值抛出的异常，我们需要将构造函数写出函数try语句块(function try block)。语法如下：Blob::Blob(int a, double b, string c) try: data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)){    doSomething();  //  其他初始化操作} catch(const std::bad_alloc &amp;e){    handle_out_of_memory(e);}这个catch既能处理构造函数体内抛出的异常，也能处理成员初始化列表抛出的异常。  这里有一点要注意，参数中也可能发生异常，但是参数的异常不属于函数try语句块的一部分。参数初始化过程发生的异常，属于调用表达式的一部分，在调用者所在的上下文进行处理。noexcept异常声明在c++新标准中，我们可以通过提供noexcept说明(noexcept )指定某个函数不会抛出异常，这样做的好处是会给编译器更大的优化空间。语法如下：void recoup(int) noexcept;  //  不会抛出异常void alloc(int);            //  可能抛出异常对于一个函数来说，noexcept说明要么出现在该函数的所有声明和定义中，要么都不出现。  该说明应该在函数的尾置返回类型之前  我们可以在函数指针的声明和定义中指定noexcept  在typedef和类型别名中不能出现noexcept  在成员函数中，noexcept说明符需要跟在const及引用符之后，在final、override或虚函数的=0之前违反异常说明哪怕我们对一个函数声明了noexcept，指出该函数不会抛出异常，但编译器并不会在编译时做检查（毕竟有一些运行时错误是检查不出来的）。所以一个函数如果声明了noexcept，并且在函数体内存在throw语句，或者在函数运行时调用了可能抛出异常的其他函数，这个函数也是可以通过编译的。就像下面这样：void f() noexcept{    throw exception();  //  违反了异常说明，但可以通过编译}但是这样编写代码的结果是：一旦一个noexcept函数抛出了异常，程序就会调用teminate确保遵守不在运行时抛出异常的承诺。在早期的C++设计中，异常说明是可以指定可能抛出的异常类型的。就像下面这样：void f() throw(length_error)    //  指出可能抛出的异常，这个写法已淘汰{    throw length_error();  }这个写法已淘汰，但是它还有一个重要的保留，如果函数后跟着throw()，就意味着该函数不会抛出异常。就像下面这样：void recoup(int) throw();void recoup(int) noexcept;  //  这两条是等价的异常说明的实参异常说明符是可以带参数的，该参数必须能转换为bool类型，如果实参为true，则该函数不会抛出异常；如果实参为false，则该函数可能抛出异常。就像下面这样：void recoup(int) noexcept(true);    //  声明不会抛出异常void recoup(int) noexcept(false);   //  声明可能抛出异常noexcept运算符这里的noexcept运算符和上面介绍的noexcept说明符不同。noexcept运算符是一个一元运算符，它的功能是表示给定的表达式是否会抛出异常，返回bool类型的右值常量。就像下面这样：noexcept(recoup(i));    //  如果recoup(i)不会抛出异常则返回true，否则返回falsenoexcept(e)当e调用的所有函数都做了不抛出异常说明，且e本身不含有throw语句时，结果才返回true；否则noexcept(e)返回false。noexcept运算符常常与noexcept说明符混合使用，就像下面这样：void f() noexcept(noexcept(g()));   //  f和g的异常说明一致如果g承诺了不会抛出异常，则f也不会抛出异常；如果g没有承诺不会抛出异常，则f也可能抛出异常。异常说明与指针、虚函数和拷贝控制如果我们声明了一个函数指针是noexcept的，那它只能指向同样声明了noexcep的函数。相反，如果我们显式或隐式说明了一个函数指针可能抛出异常，它可以指向任何函数，即使是承诺了不抛出异常的函数。就像下面这样：void (*pf1)(int) noexcept = recoup; //  ok，pf1和recoup都声明了noexceptvoid (*pf2)(int) = recoup;          //  ok，pf2未作noexcept声明，但recoup声明了noexceptpf1 = alloc;    //  no，pf1声明了noexcept，不能指向可能抛出异常的函数pf2 = alloc;    //  ok，pf2和alloc都可能抛出异常如果一个虚函数承诺了不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺。相反，如果基类的虚函数允许抛出异常，则派生出来的虚函数既可以允许抛出异常，也可以不允许抛出异常。就像下面这样：//  基类class Base{public:    virtual double f1(double) noexcept; //  不会抛出异常    virtual int f2() noexcept(false);   //  可能抛出异常    virtual void f3();                  //  可能抛出异常};//  派生类class Derived: public Base{public:    double f1(double);          //  错误，Base::f1承诺不会抛出异常    int f2() noexcept(false);   //  正确，与Base::f2的异常说明一致    void f3() noexcept;         //  正确，Derived::f3做了更严格的规定};最后，新版本的编译器默认会给拷贝控制成员(拷贝/移动/析构函数)加上noexcept声明。而某些旧版的编译器会采用以下策略：  如果所有成员和基类都做了noexcept声明，则默认生成的拷贝控制成员也是noexcept的。相反，如果任何一个成员或基类可能抛出异常，则默认生成的拷贝控制成员是noexcept(false)的。  如果定义了析构函数但没有提供异常说明，编译器会按照上述规则自动加上异常说明异常类层次标准库异常类的继承体系如图所示（图摘自《C++ Primer》）:其中exception类是所有异常类的基础，它只定义了默认构造函数、拷贝构造函数、拷贝赋值运算符、虚析构函数、what()虚成员函数。其中what()成员返回一个const char*指针，指向一个null结尾的字符数组，用来输出错误信息，且确保不会抛出任何异常。同时，因为what()是虚函数，所以我们用基类捕获异常时，调用的what函数是与异常对象动态类型对应的版本。当我们自定义异常类的时候，需要基础exception类，并重写它的成员方法：class MyException :public exception{    //  继承exception类public:    //  构造函数\tMyException(){\t\t...\t}    //  析构函数（虚函数）\t~MyException(){\t\t...\t}    //  拷贝构造函数\tMyException(const MyException&amp; rhs){\t\t...\t}    //  what成员（虚函数）\tvoid what(){\t\t...\t}};  bad_cast和bad_alloc定义了默认构造函数。  runtime_error和logic_error没有默认构造函数，但有一个参数为字符数组或string对象的构造函数。这些实参提供关于错误的更多信息。  继承体系的第二层将exception划分为两个大类：运行时错误和逻辑错误。运行时错误指只有在程序运行时才能检测的错误（比如申请内存失败）。逻辑错误指我们可以在代码中发现的错误（比如数组越界）。总结      异常使我们能够将问题的检测和解决过程分离开来    在C++中，我们可以通过抛出一条表达式来引发一个异常    一个异常如果没有被捕获，则它将终止当前程序    在栈展开的过程中如果退出了某个块，编译器将这个块创建的对象正确地销毁    析构函数不应该抛出不能被它自身处理的异常    抛出指针要求不能抛出一个指向局部对象的指针    如果catch接受的异常和某个继承体系有关，最好将catch的参数定义成引用类型    如果多个catch语句的类型之间存在着继承关系，我们应该把继承链最底端的类放在前面，最顶端的类放在后面    我们可以使用空的throw语句将异常重新抛出，由更上一层的函数对应的处理模块进行捕获    如果catch(…)与其他几个catch语句一同出现时，catch(…)必须在最后的位置    处理构造函数初始值异常的唯一方法是将构造函数写出函数try语句块    通常情况下，编译器不能也不必在编译时验证异常说明    noexcept有两层含义：跟在函数参数列表后面时表示异常说明符；当作为noexcept异常说明的bool实参出现时，它是一个运算符    函数指针与该指针所指的函数必须有一致的异常说明，基类与派生类对应的虚函数必须有一致的异常说明    继承体系的第二层将exception划分为两个大类：运行时错误和逻辑错误  Reference[1] «C++ Primer»[2] 为什么析构函数中不能抛出异常？"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(8)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_8/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-03-07 15:33:00 +0800",
    





    
    "snippet": "模板特例化  本节中介绍了模板特例化，如果我们不想用通用模板实例化，而是针对某一个类型使用特定优化代码时，我们可以将类模板或函数模板特例化。我们通过例子介绍了如何特例化函数模板和类模板。函数模板的特例化是模板的一个实例，而并非重载，不会影响函数匹配。除此之外，类模板可以部分特例化，而函数模板不行。部分特例化是提供一部分实参或者提供模板参数的一个特例化版本。部分特例化的版本还是一个模板，使用时...",
    "content": "模板特例化  本节中介绍了模板特例化，如果我们不想用通用模板实例化，而是针对某一个类型使用特定优化代码时，我们可以将类模板或函数模板特例化。我们通过例子介绍了如何特例化函数模板和类模板。函数模板的特例化是模板的一个实例，而并非重载，不会影响函数匹配。除此之外，类模板可以部分特例化，而函数模板不行。部分特例化是提供一部分实参或者提供模板参数的一个特例化版本。部分特例化的版本还是一个模板，使用时需要指定剩下的模板实参。最后我们介绍了类模板可以特例化特定成员函数，而不是特例化整个模板。模板特例化应用场景在实际编码过程中可能存在这样一种场景：我们定义的通用模板并不适用于所有的类型，比如以下函数：//  第一个版本template &lt;typename T&gt; int compare(const T&amp; v1, const T&amp; v2){    if(v1&lt;v2) return 1;    if(v2&lt;v1) return -1;    else return 0;}如果我们传入一个对象，很明显这个对象不一定支持&lt;比较符操作。同理，如果我们传入一个字符串指针，程序比较的指针的地址而不是我们希望比较的字符串大小。所以通用定义的模板可能会导致编译失败或者不正确行为。甚至有些情况，我们可以针对某种类型优化算法，而不是采用通用模板。为了解决这个问题，我们可以定义一个类或函数的模板特例化(template specialization)版本。之前的章节我们为了解决字符串的比较问题，重载了一个compare函数模板：template &lt;size_t N, size_t M&gt;int compare(const char (&amp;)[N], const char (&amp;)[M]);  //  第二个版本如果我们传入一个字符串字面常量或者一个字符数组，编译器会调用第二个版本。但如果我们传递的是一个字符指针，则会调用第一个版本。compare(\"hi\",\"mom\");    //  调用第二个版本const char* p1 = \"hi\", *p2 = \"mon\";compare(p1, p2);        //  调用第一个版本这是因为我们无法将一个指针转化为一个数组的引用，也就是当我们传入指针p1,p2时，第二个版本的compare函数不可行。为了处理字符指针，可以为第一个版本定义一个模板特例化版本。一个特例化版本就是模板的一个实例，其中模板参数会被指定为特定的类型。定义函数模板特例化我们以字符指针的compare函数为例，实现函数模板的特例化：template&lt;&gt;int compare(const char* const &amp;p1, const char* const &amp;p2){    return strcmp(p1, p2);}函数模板的特例化写法是以template&lt;&gt;开头，然后将参数中的T替换成具体类型。空尖括号(&lt;&gt;)表示我们将为原模板的所有模板参数提供实参。同时，我们定义的特例化版本，函数参数类型必须和原模板对应的类型匹配。当我们传入字符指针时，编译器就会优先调用特例化版本。const char* p1 = \"hi\", *p2 = \"mon\";compare(p1, p2);  //  调用特例化版本模板特例化与函数重载定义函数模板特例化时，我们本质上是接管了编译器的工作，也就是我们为模板的一个实例提供了定义。所以特例化版本本质上是一个实例，而不是函数的一个重载版本。因此，特例化不影响函数匹配。就像下面这个例子：//  我们再定义一个独立的非模板函数int compare(const char* const &amp;p1, const char* const &amp;p2){    return strcmp(p1, p2);}//  调用compare函数compare(p1, p2);    //  选择非模板函数的版本如果我们定义的是特例化版本，并不会影响函数匹配。但如果定义的是非模板函数的版本，根据函数重载的版本规则，会选择非模板函数的版本。最后我们强调，特例化一个模板时，必须先声明原来的通用模板。而且，在任何使用模板实例化的代码之前，也必须先声明特例化版本。这是因为如果丢失了特例化版本的声明，编译器就会用通用模板生成代码。这种情况下编译器并不会报错，但是使用了错误的模板版本可能会导致程序不正确运行，从而大大增加我们查找错误的难度。所以我们建议模板及其特例化版本一个声明在同一个头文件中，所有通用模板的声明应该放在前面，然后才是这些模板的特例化版本声明。类模板特例化类模板的特例化和函数模板特例化类似，但是有一点要注意，如果我们需要特例化标准库中的某个模板，需要在原模板定义所在的命名空间中特例化它。我们以自定义类Sales_data来创建hash&lt;key_type&gt;模板的一个特例化版本为例：//  打开std命名空间namespace std{    template&lt;&gt;  //  尖括号说明我们将为原模板的所有模板参数提供实参    struct hash&lt;Sales_data&gt;    {        typedef size_t result_type;        typedef Sales_data argument_type;        size_t operator()(const Sales_data&amp; s) const;        ...    }    //  类外定义operator()函数    size_t hash&lt;Sales_data&gt;::operator()(const Sales_data&amp; s) const    {        return hash&lt;string&gt;()(s.bookNo) ^               hash&lt;unsigned&gt;()(s.units_sold) ^               hash&lt;double&gt;()(s.revenue)    }}   //  关闭命名空间，注意没有分号这里我们解释一下hash&lt;Sales_data&gt;模板中定义了一个函数调用运算符()的重载方法。该方法是输入一个Sales_data对象，返回一个哈希值。在上述实现中，我们将哈希函数的交给了标准库中hash模板的特例化版本。hash&lt;string&gt;、hash&lt;unsigned&gt;、hash&lt;double&gt;是hash模板的特例化版本，通过三者生成的哈希值进行异或运算，形成最后的哈希值。假定我们的特例化版本在作用域中，当我们用Sales_data作为容器的类型时，编译器就会自动使用此特例化版本。hash&lt;Sales_data&gt; hsd;   //  使用的是特例化版本类模板的部分特例化类模板可以部分特例化，但是函数模板不能部分特例化。一个类模板的部分特例化(partial specialization)指不需要为所有模板参数提供实参。 我们通过一个例子说明类模板的部分特例化：// 通用模板template&lt;class T1, class T2&gt; class Pair { ... }; // 部分特例化，模板参数T2指定为inttemplate&lt;class T1&gt;class Pair&lt;T1, int&gt;  { ... }; 类模板的部分特例化本身还是一个模板，我们在使用它的时候需要为部分特例化版本中未指定的模板参数提供实参。Pair&lt;double, double&gt; p1;  //   使用通用模板Pair&lt;double, int&gt; p2;     //   使用部分特例化模板注意，如果有多个模板可供选择，编译器将使用特例化程度最高的模板。部分特例化还有一种用法。部分特例化版本的模板参数列表是原始模板参数列表的一个子集或者是一个特例化版本。也就是说我们可以指定原模板参数是一个特例化版本。我们用标准库的remove_reference类型说明：//  原始、通用的版本template &lt;class T&gt; struct remove_reference {...} ;//  左值引用版本template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; {...} ;//  右值引用版本template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; {...} ;这个例子中，特例化版本的模板参数的数目和原模板相同，但是类型不同，使用引用提供特殊版本实现部分特例化现有模板。当我们传入不同类型的实参时，会选择不同的特例化版本：int i;//  decltype(42)返回int，使用原始模板remove_reference&lt;decltype(42)&gt;::type a;//  decltype(i)返回int&amp;，使用T&amp;的特例化版本remove_reference&lt;decltype(i)&gt;::type a;//  decltype(std::move(i))返回int&amp;&amp;，使用T&amp;&amp;的特例化版本remove_reference&lt;decltype(std::move(i))&gt;::type a;特例化类成员我们可以只特例化特定成员函数，而不是特例化整个模板。例如，我们有一个Foo类，包含一个成员函数Bar，我们只特例化该成员：template &lt;typename T&gt; struct Foo{    Foo(const T&amp; t): mem(t) { }    void Bar() { ... }    T mem;};//  特例化成员函数Bar()template&lt;&gt;void Foo&lt;int&gt;::Bar(){    //  进行应用于int的特例化处理}上述代码中我们只特例化了Foo&lt;int&gt;的一个成员，当我们调用Foo类时：Foo&lt;string&gt; fs; //  实例化Foo&lt;string&gt;::Foo()fs.Bar();       //  实例化Foo&lt;string&gt;::Bar()Foo&lt;int&gt; fi;    //  实例化Foo&lt;int&gt;::Foo()fi.Bar();       //  使用特例化版本的Foo&lt;int&gt;::Bar()当我们使用int以外的类型时，Foo根据实参类型正常实例化。当我们使用int类型时，Foo的其他成员正常实例化，只有Bar函数使用我们定义的特例化版本。总结      当我们无法（或不希望）使用通用的模板版本时，我们可以定义类或函数模板的一个特例化版本    特例化的本质是实例化一个模板，而非重载它，不影响函数匹配    模板及其特例化版本一个声明在同一个头文件中，所有通用模板的声明应该放在前面，然后才是这些模板的特例化版本声明    我们可以部分特例化类模板，但不能部分特例化函数模板    我们可以只特例化特定成员函数，而不是特例化整个模板  Reference[1] «C++ Primer»[2] 类模板的部分特例化"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(7)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_7/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-03-06 20:52:00 +0800",
    





    
    "snippet": "可变函数模板  我们可能会遇到这样的需求，函数模板的类型数量是不确定的，同时函数参数的数量也可能是不确定的。为了解决这个问题，c++引入了可变函数模板。可变函数模板可以接受可变数目的模板参数或函数参数。本节中我们通过编写一个实例来深入理解可变函数模板。介绍了它的两种用法：获取包大小，扩展包。我们可以通过各种模式灵活地扩展出我们想要的调用形式。在扩展的基础上，我们还可以结合std::forwa...",
    "content": "可变函数模板  我们可能会遇到这样的需求，函数模板的类型数量是不确定的，同时函数参数的数量也可能是不确定的。为了解决这个问题，c++引入了可变函数模板。可变函数模板可以接受可变数目的模板参数或函数参数。本节中我们通过编写一个实例来深入理解可变函数模板。介绍了它的两种用法：获取包大小，扩展包。我们可以通过各种模式灵活地扩展出我们想要的调用形式。在扩展的基础上，我们还可以结合std::forward函数转发函数参数包。可变函数模板定义可变参数模板(variadic template)是指一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包(parameter packet)。参数包一般分为两种：  模板参数包(template parameter packet)：表示零个或多个模板参数  函数参数包(function parameter packet)：表示零个或多个函数参数我们用一个省略号来表示模板参数或函数参数的一个参数包。就像下面这样：template &lt;typename T, typename... Args&gt;void foo(const T&amp; t, const Args&amp;... rest);class…或typename…指出接下来的参数表示零个或多个类型的列表，就像上面例子中typename… Args，Args可以表示零个或多个模板参数。一个类型（const Args&amp;)后接省略号表示零个或多个给定类型的函数参数的列表，就像上面例子中const Args&amp;… rest，rest可以表示零个或多个函数参数。这里要注意，在函数参数中，如果一个参数类型是模板参数包，则此参数必须是一个函数参数包。对于一个可变参数模板，编译器不仅可以根据实参推断模板参数类型，还能推断包中参数的数目，就像下面这样：int i = 0;double d = 3.14;string s = \"hi\"; foo(i, s, 42, d);       //  包中有三个参数foo(s, 42, \"hello\");    //  包中有两个参数foo(d, s);              //  包中有一个参数foo(\"hello\")            //  空包编译器会为foo实例化出四个不同的版本：void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);void foo(const string&amp;, const int&amp;, const char[6]&amp;);void foo(const double&amp;, const string&amp;);void foo(const char[6]&amp;);sizeof运算符当我们需要找到包中有多少个元素时，可以使用sizeof…运算符。sizeof…不会对实参求值，而是返回一个常量表达式。sizeof…的用法如下所示：template &lt;typename... Args&gt; void g(Args... args){    cout&lt;&lt; sizeof...(Args) &lt;&lt; endl;     //  求类型参数的数目    cout&lt;&lt; sizeof...(args) &lt;&lt; endl;     //  求函数参数的数目}编写可变参数函数模板在现实应用场景中，我们可能会遇到函数参数数量不固定的情况，比如用户随机给定n（n&gt;=0）个关键词。我们往常的做法是用initializer_list来定义可接受可变数目实参的函数，就像下面这样：vector&lt;string&gt; keywords1={\"world\",\"bird\",\"plane\"};  //  三个关键词vector&lt;string&gt; keywords1={\"kownledge\",\"apple\"};     //  两个两个词这里调用vector的构造函数参数就是initializer_list。但这种方法有一个缺陷：所有实参必须是相同的类型（或可以转换为相同的类型）。基于这个问题场景，可变函数模板可以解决类型参数不确定，类型参数数目不确定，函数参数数目不确定的问题。下面我们列举一个打印函数，说明怎么处理可变参数模板的内容。我们先给出代码：//  递归终止函数//  此函数必须在可变参数版本的print定义之前声明template &lt;typename T&gt; ostream&amp; print(ostream&amp; os, const T&amp; t){    return os &lt;&lt; t; //  打印最后一个元素，且末尾不打印分隔符}//  递归函数//  除了最后一个元素之外，其他元素都会调用这个版本的printtemplate &lt;typename T, typename... Args&gt; ostream&amp; print(ostream&amp; os, const T&amp; t, const Args&amp;... rest){    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...);  //  递归调用，打印其他实参}可变参数函数通常是用递归实现的。第一步调用包中的第一个实参，然后用剩余实参调用自身。为了终止递归，我们还需要定义一个非可变参数函数。上面的实现中，递归的print函数将包中第一个实参绑定到t中，剩下的实参形成下一个print调用的参数包。在每次调用中，包里的第一个实参都会被移出，成为t的实参。递归的执行过程如下：            调用      t      rest                  ptint(cout, i, s, 42)      i      s, 42              ptint(cout, s, 42)      s      42              ptint(cout, 42)      调用非可变参数版本的print             最后这里有两个点需要我们注意：      当最后一次调用print时，两个print版本都是可行的。因为可变参数版本的print可以只接受两个参数，第三个参数rest表示零个函数参数。但是非可变参数模板比可变参数模板更特例化，所以编译器选择非可变参数模板。        当我们定义可变参数版本的print时，要先声明或定义非可变参数版本的print。否则，可变参数版本会无限递归。  包扩展对于一个参数包，我们对它的操作有两种：  获取包大小  扩展(expand)扩展包时，我们需要一个模式(pattern)。拓展一个包就是将它分解成每个构成元素，然后对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号(…)来出发扩展操作。下面我们通过一个例子来说明什么是扩展和模式：template &lt;typename T, typename... Args&gt;ostream&amp; print(ostream&amp; os, const T&amp; t,const Args&amp;... rest) //  扩展1{    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...);  //  扩展2}上述代码第一个扩展操作出现在print的函数参数列表中，编译器将const Args&amp;模式应用到模板参数包Args的每一个元素上。例如我们调用函数：print(cout, i, s, 42);const Args&amp;…模式会将参数包扩展成如下形式：//  模式const Args&amp;//  扩展后ostream&amp; print(ostream&amp; os, const int&amp; t, const string&amp; t, const int&amp; t);第二个扩展操作出现在print的递归调用中，此情况下，模式是函数参数包的名字。rest…模式会将参数包扩展成如下形式：//  模式rest...//  扩展后print(os, s, 42);理解包扩展可能看完上面两个扩展模式的例子，觉得对模式和扩展不是很理解，那接下来我们继续深入探讨一些复杂的模式，加深对扩展的理解。我们将上面的print函数修改一下，对每个实参调用debug_rep：template &lt;typename T, typename... Args&gt;ostream&amp; print(ostream&amp; os, const T&amp; t,const Args&amp;... rest){    //  模式为debug_rep(rest)...    //  扩展后为print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an));    return print(os, debug_rep(rest)...);  //  扩展2}这个模式表示我们希望对rest中的每一个参数都调用debug_rep函数，扩展结果是一个用逗号分隔的debug_rep调用列表。这里要注意，如果我们将模式改写成debug_rep(rest…)，则程序会报错，就像下面这样：print(os, debug_rep(rest...));报错原因在于包扩展后会形成这样的形式：print(os, debug_rep(a1, a2, ..., an));而我们定义的debug_rep(const T&amp;)方法不存在与此调用匹配的debug_rep版本。所以在我们使用包扩展时，要注意省略号的位置。转发参数包之前的章节我们介绍了利用forward机制实现模板参数转发，可变函数模板也可以结合forward机制来实现转发参数包。接下来我们举一个实例来说明：//  这是一个非模板的容器类class StrVec {public:    //  容器类中有一个模板成员，该成员的功能是插入一个元素    //  为了保证实参类型信息，模板参数类型定义为右值引用    template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;...);};//  类外定义emplace_back函数template &lt;class... Args&gt;inline void StrVec::emplace_back(Args&amp;&amp;... args){    chk_n_alloc();  //  检查并分配空间    //  在first_free指向位置创建元素    alloc.construct(first_free++, std::forward&lt;Args&gt;(args)...); }上面的例子实现了容器StrVec的一个插入元素的函数。我们发现construct调用中存在一个扩展：std::forward&lt;Args&gt;(args)...这个扩展既扩展了模板参数包Args，也扩展了函数参数包args，扩展后的形式为：std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2), ..., std::forward&lt;Tn&gt;(tn)$T_i$表示模板参数包中的第i个元素类型，$t_i$表示函数参数包中第i个元素。例如我们调用：StrVec sevc;sevc.emplace_back(10, 'c');construct调用中的模式会扩展出：std::forward&lt;int&gt;(10), std::forward&lt;char&gt;('c')另外，如果我们传递一个右值给实参，则construct也会得到一个右值。例如：string s1=\"the\", s2=\"end\";sevc.emplace_back(s1 + s2);它会将右值以如下形式传递给construct：std::forward&lt;string&gt;(string(\"the end\"))forward&lt;string&gt;的结果是string&amp;&amp;，从而将该实参转发给string的移动构造函数来创建新元素。总结      可变参数模板是指一个接受可变数目参数的模板函数或模板类    class…或typename…指出接下来的参数表示零个或多个类型的列表    一个类型后接省略号表示零个或多个给定类型的函数参数的列表    当我们需要找到包中有多少个元素时，可以使用sizeof…运算符    可变参数函数通常是用递归实现的    扩展中的模式会独立地应用于包中的每个元素    可变函数模板也可以结合forward机制来实现转发参数包  Reference[1] «C++ Primer»"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(6)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_6/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-03-04 16:57:00 +0800",
    





    
    "snippet": "模板与重载  函数模板可以被另一个函数模板或非函数模板重载。当然，它们的函数名相同，但参数类型或参数数量得不同。本节我们先介绍函数模板的匹配规则，如果有多个匹配的候选函数，则编译器会选择更特例化的那个版本。接下来，我们编写了一个重载模板的例子，并且说明什么情况下会调用哪个版本。最后，我们探讨了模板转换过程中关于类型转换的问题。函数模板匹配规则函数模板的匹配规则会受到以下方面的制约，接下来我们...",
    "content": "模板与重载  函数模板可以被另一个函数模板或非函数模板重载。当然，它们的函数名相同，但参数类型或参数数量得不同。本节我们先介绍函数模板的匹配规则，如果有多个匹配的候选函数，则编译器会选择更特例化的那个版本。接下来，我们编写了一个重载模板的例子，并且说明什么情况下会调用哪个版本。最后，我们探讨了模板转换过程中关于类型转换的问题。函数模板匹配规则函数模板的匹配规则会受到以下方面的制约，接下来我们一条条深入探讨：      对于一个调用，其候选函数包括所有模板实参推断成功的实例这个很好理解，重载的函数模板可能不止一个（见下面例子），所以候选函数是这些模板函数的实例，而且并不是所有的实例都成立，只有实参匹配的实例才是我们要的。        候选的模板函数总是可行的，因为模板实参推断会排除任何不行的模板这句话就是上面所说的，只有实参匹配的实例才是我们要的。        如果有多个匹配的候选函数，不需要进行类型转换的候选函数优先可用于函数模板的类型转换非常有限。比如其中一个匹配函数为function(const T&amp;)，而另一个是function(T&amp;)，如果我们传入int变量，第一个匹配函数需要由int转换为const int，而第二个不用。也就是说第二个候选函数匹配更加精确，编译器会选择第二个候选函数。        如果恰有一个函数提供比其他函数更好的匹配，则选择此函数。如果多个函数提供同样好的匹配，则：          如果同样好的候选函数只有一个是非模板函数，则选择此函数      如果同样好的候选函数中，由一个函数模板比其他模板更加特例化，则选择此函数模板      否则，此调用有歧义      编写重载模板接下来我们列举重载模板的例子，然后说明在哪些情况下，会调用哪个模板。现在我们有一个打印debug内容的函数。先定义它的const对象的引用的版本：template &lt;typename T&gt; string debug_rep(const T&amp; t){    ostringstream ret;    ret &lt;&lt; t;   //  打印t的内容    return ret.str();   //  返回ret绑定的string的一个副本}接下来我们定义debug_rep的指针版本：template &lt;typename T&gt; string debug_rep(T* p){    ostringstream ret;    ret &lt;&lt; \"pointer: \" &lt;&lt; p;   //  打印p的指针地址    if(p)        ret &lt;&lt; \" \" &lt;&lt; debug_rep(*p);    //  打印p指针所指的内容    else        ret &lt;&lt; \"null pointer\";          //  指出空指针    return ret.str();   //  返回ret绑定的string的一个副本}  注意此函数不能用于char，因为char在IO库定义了一个«版本，这个版本会打印出数组的内容而不是地址值。接下来我们调用这些函数：string s(\"hi\");cout &lt;&lt; debug_rep(s) &lt;&lt; endl;在这个函数调用中，由于我们传的不是指针，而不是一个对象，所以只有debug_rep(const T&amp; t)的版本可用。那如果我们传入一个指针：cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl;在这次调用中，第一个版本是可行的，T会绑定string，生成实例debug_rep(const string&amp;)。第二个版本也是可行的，T会绑定为string，生成实例debug_rep(string)。虽然两个版本都适配，但是按照我们的匹配规则，第一个版本的参数T需要将string类型转换为const string类型。所以编译器会选择第二个版本，即debug_rep(T p)这个版本。那如果我们传入一个const指针呢？const string *sp = &amp;s;cout &lt;&lt; debug_rep(sp) &lt;&lt; endl;在这次调用中，第一个版本是可行的，T会绑定string，生成实例debug_rep(const string&amp;)。第二个版本也是可行的，T会绑定为const string，生成实例debug_rep(const string)。这种情况两个版本都适配，而且第一个版本没有const的转换，那编译器会怎么选择呢？答案是编译器会选择第二个版本，因为debug_rep(T)只能用于指针类型，而debug_rep(const T&amp; t)可以用于任何类型，包括指针类型。也就是说，编译器会根据匹配规则，选择后者这个更加特例化的版本。没有这条规则，传递const指针的调用永远会有歧义。非模板和模板重载如果候选函数中存在非模板版本的函数，就会选择非模板版本的那个。我们定义一个非模板版本的debug_rep()：string debug_rep(const string&amp; s){    return '\"' + s + '\"';}现在当我们对一个string调用一个debug_rep时：cout &lt;&lt; debug_rep(s) &lt;&lt; endl;有两个匹配的候选函数：  debug_rep&lt;string&gt;(const string &amp;)，第一个模板，T绑定到string*  debug_rep(const string&amp;)，非模板函数根据匹配规则，编译器会选择非模板版本。出于同样的原因，编译器应该选择最特例化的版本，一个非模板函数比一个模板函数更好。重载模板和类型转换存在一种情况，我们有一个char*型指针或字符串字面常量，我们想要传递字符串调用给string的debug_rep版本。cout &lt;&lt; debug_rep(\"hi\") &lt;&lt; endl;有三个匹配的候选函数：  第一个版本实例化为debug_rep(const char[3]&amp;)，T被绑定到char[3]  第二个版本实例化为debug_rep(const char*)，T被绑定到const char  第三个版本实例化为debug_rep(const string&amp;)，T被绑定为string，但是需要发生const char*到string的类型转换由于第二个版本和第三个版本相比第一个版本更加特例化，所以编译器不会选择第一个版本。第二个版本需要进行一次数组到指针的转换。而第三个版本需要进行char*到string的转换。在这两个转换中，第二个版本是基本类型之间的转换，而第三个版本是基本类型到类类型的转换。所以第二个版本的转换更加精确，第二个版本更加特例化，编译器会选择第二个版本。如果我们希望将字符串传给string的debug_rep版本处理（因为T的版本不能打印char的地址，效果并不好），可以这么做：//  定义重载函数，调用string debug_rep(char *p){    return debug_rep(string(p));}string debug_rep(const char *p){    return debug_rep(string(p));}  声明所有重载版本  最后我们强调一下，在定义任何函数之前，记得声明所有重载的函数版本，这样可以避免编译器由于未遇到你希望调用的版本，从而实例化出一个你不需要的版本。总结      函数模板可以被另一个函数模板或非函数模板重载    当有多个重载模板对同一个调用提供同样好的匹配时，应该选择最特例化的版本    对于一个调用，如果一个非模板函数与一个模板函数提供同样好的匹配，则选择非模板版本    在定义任何函数之前，记得声明所有重载的函数版本  Reference[1] «C++ Primer»"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(5)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_5/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-03-01 11:13:00 +0800",
    





    
    "snippet": "模板实参推断  本节我们继续探讨模板实参推断的内容。在这之前，我们简单介绍了左值和右值，以及左值引用和右值引用的知识。当模板参数为左值引用的时候，我们传入一个左值，会推断成对应的左值引用类型。当模板参数为const左值引用的时候，我们可以传递任何类型的参数。当模板参数为右值引用的时候，我们发现它也可以传递任何类型的参数。接下来我们深究原因，发现这是c++用了引用折叠，所以使得右值引用参数可以...",
    "content": "模板实参推断  本节我们继续探讨模板实参推断的内容。在这之前，我们简单介绍了左值和右值，以及左值引用和右值引用的知识。当模板参数为左值引用的时候，我们传入一个左值，会推断成对应的左值引用类型。当模板参数为const左值引用的时候，我们可以传递任何类型的参数。当模板参数为右值引用的时候，我们发现它也可以传递任何类型的参数。接下来我们深究原因，发现这是c++用了引用折叠，所以使得右值引用参数可以接收任何类型。如果模板参数类型为右值引用，可能会导致程序中一些逻辑实现出现意料之外的情况，我们举了一个例子说明这一点。模板参数类型为右值引用会导致编写正确的代码比较困难，但他有两个很好的应用：模板参数转发和模板重载。我们介绍了模板参数类型为右值引用，是怎么帮助模板转发参数的。最后，我们接着之前探讨的引用折叠，介绍了std::move()函数的原理。左值和右值在讲解后面的内容之前，我们先来回顾一下左值和右值的概念。C++11中，所有的值分为两种：左值(lvalue)、右值(rvalue)，其中右值又可以细分为纯右值(prvalue)、将亡值(xvalue)。我们先有一个感性的认识：在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。比如int a = b + c;中，变量a是有名字的，且可以取址的，所以它是左值。b + c是没有名字的，而且&amp;(b+c)这种操作是非法的，所以它是右值。接着我们沿着C++的版本来了解右值：  在c语言中，右值是指不能在赋值语句左边的值。  在c++98中，右值是指纯右值，即需要转换的临时变量，返回右值的表达式（比如b+c）、不跟对象关联的字面常量（比如true,2,’c’）。  在c++11中，右值的定义进行了扩充，分为纯右值和将亡值。其中纯右值的定义和c++98中右值的定义相同，将亡值的则是c++11新增的跟右值引用相关的表达式。将亡值指移动其他变量的内存空间得到的值（比如右值引用操作&amp;&amp;的返回值，std::move的返回值），原来的值不能再被使用，而且即将销毁。《c++ Primer》中给我们做了一个简单的归纳：当对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。  函数本身是有地址的，它是一个左值；但是函数的返回值，可能是左值，也可能是右值。（c++98中，函数被确立为左值）最后我们说明：左值和右值的概念主要体现在许多运算符上。有些运算符需要左值运算对象，有些运算符需要右值运算对象；有些运算符返回左值结果，有些则返回右值结果。所以《c++ Primer》提出了一条重要的原则：需要右值的地方可以用左值来代替，但不能反过来把右值当左值使用；当一个左值被当成右值使用时，实际使用的是它的内容（值）左值引用和右值引用介绍完左值和右值，我们接下来来探讨左值引用(lvalue reference)和右值引用(rvalue reference)。我们平时提到的引用(reference)都是指左值引用，其底层原理是通过指针实现的。当我们知道右值是没有指针的，因为右值不能取地址，而且右值在内存中在临时的，即将销毁的。正因为右值没有名字，所以我们提出右值引用来绑定右值的存在。右值引用采用&amp;&amp;符号来表示，我们来看下面例子：int i = 42;int &amp;r = i;         //  正确，左值引用绑定左值int &amp;r2 = i * 42;   //  错误，左值引用不能绑定右值int &amp;&amp;rr = i;       //  错误，右值引用不能绑定左值int &amp;&amp;rr2 = i * 42; //  正确，右值引用绑定右值const int &amp;r3 = i * 42; //  正确，const的左值引用绑定右值我们可以看出，右值引用可以绑定到要求转换的表达式、字面常量和返回右值的表达式中，但不能绑定到一个左值上面。反过来，左值引用也不能绑定右值。但在最后一行我们发现，用const修饰的左值引用也可以绑定一个右值。于是，我们做以下实验：int &amp;a = 2;       // 错误，左值引用不能绑定右值int b = 2;        // 定义非const左值const int &amp;c = b; // 正确，const左值引用可以绑定非cosnt左值const int d = 2;  // 定义const左值const int &amp;e = c; // 正确，const左值引用绑定到const左值const int &amp;f =2;  // 正确，const左值引用绑定到右值我们得出结论：左值引用只能绑定非const左值；const左值引用可以绑定左值和右值(无论是否有const修饰)；右值引用只能绑定非const右值。（const右值引用没啥实际意义，这里不做探讨）而且const左值引用和右值引用能延长右值的生存时间。  关于为什么常量左值引用可以绑定右值，作者推测禁止左值引用绑定右值的原因可能是右值往往是临时变量（修改会导致未定义行为）或者字面常量（不可修改）。而const修饰的左值引用是禁止对引用的对象进行修改的，避免了这类问题。另外这里要主要，右值的引用是一个左值！int &amp;&amp;rr1 = 42;     //  正确，字面常量是右值int &amp;&amp;rr2 = rr1;    //  错误，变量是左值从左值引用函数参数推断类型介绍完左值引用和右值引用，接下来我们要回到模板实参推断中，探讨模板实参中存在左值引用和右值引用的情况。如果一个函数参数是一个左值引用（T&amp;）时，只能给它传递一个左值。实参可以是const，也可以不是；如果实参是const，则T会被推断为const类型：template &lt;typename T&gt; void f1(T&amp;);  //  实参必须是一个左值f1(i);    //  i是int类型，模板参数类型T推断为intf1(ci);   //  i是const int类型，模板参数类型T推断为const intf1(5);    //  错误，5是右值，不能传递给模板实参如果一个函数参数是常量左值引用（const T&amp;）时，我们可以给它传递任何实参（不论左值还是右值，const还是非const），就像上面const左值引用中我们实验结果的绑定情况一样。template &lt;typename T&gt; void f2(const T&amp;); f2(i);  //  i是int类型，模板参数类型T推断为intf2(ci); //  i是const int类型，模板参数类型T推断为intf2(5);  //  const左值引用可以绑定右值，模板参数类型T推断为int这里需要注意一点，函数本身是const的，所以T的类型推断结果不会是const类型，因为const语句是函数参数类型的一部分了，即不会推断成const const int。从右值引用函数参数推断类型如果一个函数参数是一个右值引用（T&amp;&amp;）时，我们可以传递一个右值。template &lt;typename T&gt; void f3(T&amp;&amp;);f3(42); //  右值引用可以绑定右值，模板参数类型T推断为int引用折叠和右值引用参数到目前为止我们发现编译器会应用正常的引用绑定规则于模板参数类型上，和左、右值引用的绑定规则一样。但是当我们把左值传入右值引用的模板实参中，发现编译竟然通过了。template &lt;typename T&gt; void f3(T&amp;&amp;);f3(i);  // i是int类型的左值，理论上右值T&amp;&amp;不能绑定左值，但是程序却正确运行我们发现上面的程序能正常运行，这不符合右值引用不能绑定左值的设定。原来，c++在正常的绑定规则之上定义了两个例外规则。      当我们将一个左值传递给一个函数的右值引用参数时，编译器会推断该模板类型参数是实参的左值引用类型。即我们传递f3()一个int类型变量时，编译器会推断T类型为int&amp;。        如果我们间接创建一个引用的引用，则这些引用形成了“折叠”左值引用的引用在所有情况下，引用会折叠成一个普通的左值引用类型。比如X&amp; &amp;会折叠成X&amp;。在新标准中，折叠规则扩展到右值引用，只有在一种特殊情况下引用会折叠成右值引用。也就是说，给定一个类型X：          X&amp; &amp;会折叠成X&amp;      X&amp;&amp; &amp;和X&amp; &amp;&amp;会折叠成X&amp;      X&amp;&amp; &amp;&amp;会折叠成X&amp;&amp;（特殊情况）      通常我们不能做直接定义一个引用的引用，所以引用折叠只能应用于间接裁剪的引用的引用，比如类型别名或模板参数。所以让我们看回上面的例子，f3()传递了一个左值，函数的实例化看起来会像是这样：void f3&lt;int&amp;&gt;(int&amp; &amp;&amp;);//  折叠后void f3&lt;int&amp;&gt;(int&amp;);所以总结一下：  如果一个函数参数是一个右值引用（T&amp;&amp;）时，它可以绑定一个左值  这种情况下，如果实参是一个左值，则推断出来的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（T&amp;）  如果实参是一个左值，则推断出来的模板实参类型将是一个右值类型，函数参数将被实例化为一个右值引用参数（T&amp;&amp;）所以，如果一个函数参数是一个右值引用（T&amp;&amp;）时，则可以传递任意类型的实参（不论左值还是右值，const还是非const）。而且传入左值，函数参数会实例化为左值引用类型；传入右值，函数参数会被实例化为右值引用类型。编写接受右值引用参数的模板函数我们在上面介绍了右值引用的模板参数可以绑定容易类型的实参，现在我们定义一个这样的模板：template &lt;typename T&gt; void f3(T&amp;&amp; val){    T t=val;    t=fcn(t);    if(val==t){...}}我们来观察一下这个函数模板，传入左值和传入右值有什么区别？当我们传入左值，比如传入int类型变量i：  类型T会实例化为int&amp;  第一行代码变成int&amp; t=val,t是一个引用  第二行代码t=fcn(t)，val的值也会发生变化（因为t是引用）  第三行代码中，因为t是val的引用，所以val==t的结果一定是true当我们传入右值，比如传入字面常量42：  类型T会实例化为int  第一行代码会变成int t=val，t是一个值  第二行代码t=fcn(t)，val的值不受影响  第三行代码中，因为t在第二行代码中值可能被改变了，而val的值不变，所以val==t的结果不确定我们可以看到传入左值和右值导致的结果可能大不相同，这是我们编写正确的代码变得困难。那怎么解决这个问题呢？首先我们通常将类型参数为右值引用的情况用于这两种场合：模板参数转发、模板重载。（我们将在后面做介绍）如果是在模板重载的情况，我们会多声明一个函数模板，避免左值进入类型参数为右值引用的模板，从而避免程序错误：template &lt;typename T&gt; void f(T&amp;&amp;);      //  绑定非const右值template &lt;typename T&gt; void f(const T&amp;); //  绑定左值和const右值模板参数转发刚刚提到模板参数类型是右值引用的情况，主要用于模板参数转发和模板重载。现在让我们来探讨模板参数转发。转发就是某些函数需要将一个或多个实参连同类型不变地转发给其他函数，比如在函数中调用其他函数。我们来举一个例子：template &lt;typename F,typename T1,typename T2&gt;void flip1(F f,T1 t1,T2 t2){    f(t2,t1);} 这个函数模板的功能很简单，传入一个可调用对象f，然后逆序调用参数t1和t2。这个函数一般情况下能很好地运行，但如果f的函数参数是引用时，它就会出现问题了：void f(int v1,int v2){    cout &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; ++v2 &lt;&lt; endl;}这个函数f在调用的同时，参数v2会完成自增。就像这样：f(42,i);    //  i会加1但是如果我们将函数f传递给函数模板flip1时，却不会自增了。flip1(f,j,42);  //  这里j不会变化我们先来看实例化后的函数：void flip1(void(*fcn)(int,int &amp;),int t1,int t2);我们传进去的可调用对象f参数依然是引用，但是t1不是引用。j传递给t1的时候进行了拷贝，形成一份副本t1’，再将t1’传递给函数f。结果临时副本t1’完成了自增，但原来的变量t1并没有自增。所以这里我们应该传递引用。但问题来了，我们希望t1，t2被传递时保持被转发实参的所有性质，包括实参的类型、是否为const、实参是左值还是右值。如果我们改为（左值）引用，当我们给实参传递右值的时候就会报错。这时候我们想到之前讨论模板参数类型是右值引用时的表现：如果传入左值，函数参数会实例化为左值引用类型；传入右值，函数参数会被实例化为右值引用类型。而且无论传递是左值还是右值，都可以保持const属性，因为引用类型的const是底层的。所以我们将函数模板修改成下面这个样子：template &lt;typename F,typename T1,typename T2&gt;void flip2(F f,T1&amp;&amp; t1,T2&amp;&amp; t2){    f(t2,t1);} 这样当我们执行代码flip2(f,j,42)时，j会被转换成左值引用，再将引用传递给函数f，然后f递增了v2的同时，也改变了j的值。但是这段代码依然不是完美的，原因就在于可调用对象f不能接受右值引用参数的函数，例如：void g(int&amp;&amp; i,int&amp; j){    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;}可能你会疑惑，我们传递给t2时，不是得到了右值引用类型了吗？为什么不能调用参数是右值引用类型的函数？别忘了我们上面讲到的，右值的引用是一个左值！为了解决这个问题，我们引入标准库中的参数转发函数forward。forward定义在头文件utility中，使用时必须显式定义参数类型。它的功能是返回该显式实参类型的右值引用，即forward&lt;T&gt;的返回类型是T&amp;&amp;。我们使用forward重写代码：template &lt;typename F,typename T1,typename T2&gt;void flip2(F f,T1&amp;&amp; t1,T2&amp;&amp; t2){    f(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1));} forward&lt;Type&gt;如果实参是右值，则Type是一个普通（非引用）类型，返回Type&amp;&amp;。如果实参是左值，则Type是一个左值引用类型，通过引用折叠返回一个左值引用类型Type&amp;。std::move()原理最后借着之前提到的引用折叠，这里就探讨一下std::move()函数的原理。std::move()函数可以将一个左值转换成右值引用。我们先给出move()函数的标准库代码：template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t){    return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);}模板参数类型T是一个右值引用类型，就像之前讲的那样，它可以接受任何类型的参数。我们可以给它传递一个左值，也可以传递一个右值。接下来，我们来细究传递左值和传递右值时，move()函数是如何工作的。当我们传入右值，例如：std::move(string(\"bye\"));  编译器推断出T的类型是string  remove_reference&lt;string&gt;的type是string  参数t是string&amp;&amp;类型，所以static_cast&lt;string&amp;&amp;&gt;(t)什么也不做  返回值是string&amp;&amp;类型所以，传入右值时，函数实例化为：string&amp;&amp; move(string &amp;&amp;t);当我们传入左值，例如：string s1(\"hi\");std::move(s1);  编译器推断出T的类型是string&amp;  remove_reference&lt;string&amp;&gt;的type是string  参数t是string&amp; &amp;&amp;类，折叠为string&amp;  static_cast&lt;string&amp;&amp;&gt;(t)强制转化t为string&amp;&amp;类型  返回值是string&amp;&amp;类型所以，传入左值时，函数实例化为：string&amp;&amp; move(string &amp;t);这里注意，c++中不能隐式地将一个左值转换为右值引用，但是允许显式地用static_cast将一个左值转换为右值引用。参数t的类型是一个左值引用类型，左值引用也是一个左值，所以允许显式地转换为右值引用类型。  对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断左值。截断一个左值是安全的，一方面c++认可了这种转换，另一方面通过显式调用static_cast,c++试图阻止我们意外地进行这种转换。最后，move()函数和forward()函数的区别是：move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左、右值类型。总结      在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值    左值引用只能绑定非const左值；const左值引用可以绑定左值和右值；右值引用只能绑定右值    如果一个函数参数是一个左值引用时，只能给它传递一个左值    如果一个函数参数是常量左值引用时，我们可以给它传递任何实参（不论左值还是右值，const还是非const）    如果一个函数参数是一个右值引用时，我们可以传递一个右值    引用折叠只能应用于间接裁剪的引用的引用，比如类型别名或模板参数    如果一个函数参数是一个右值引用（T&amp;&amp;）时，则可以传递任意类型的实参（不论左值还是右值，const还是非const）    如果一个函数参数是一个右值引用（T&amp;&amp;）时，传入左值和右值可能会导致函数内的逻辑表现不同    如果一个函数参数是一个右值引用（T&amp;&amp;）时，它对应的const属性和左值/右值属性将得到保持    如果一个函数参数是一个右值引用（T&amp;&amp;）时，forward会保持实参类型的所有细节    std::move()会无条件的将一个参数转换成右值，而std::forward()则会保留参数的左、右值类型  Reference[1] «C++ Primer»[2] Value categories[3] 常量左值引用可以绑定右值的原因[4] C++ 左值和右值[5] std::move的理解和使用[6] std:move基本用法和理解"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(4)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_4/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-02-28 15:46:00 +0800",
    





    
    "snippet": "模板实参推断  对于模板函数，通过函数实参来确定模板实参的过程称为模板实参推断(template argument deduction)。本节中我们先介绍了函数模板在类型转换上有特殊的初始化规则，其中主要包括const转换和数组或函数指针转换这两条规则，其他大多数的类型转换在函数模板中是不生效的。但是如果函数模板中有非模板类型参数，正常的类型转换就可以应用。所以，如果我们显式指定了模板实参，...",
    "content": "模板实参推断  对于模板函数，通过函数实参来确定模板实参的过程称为模板实参推断(template argument deduction)。本节中我们先介绍了函数模板在类型转换上有特殊的初始化规则，其中主要包括const转换和数组或函数指针转换这两条规则，其他大多数的类型转换在函数模板中是不生效的。但是如果函数模板中有非模板类型参数，正常的类型转换就可以应用。所以，如果我们显式指定了模板实参，那显式的模板参数也可以进行类型转换。除此之外，显式模板实参一般用来指定返回值类型，这样用户可以把握返回值的精度。如果我们事先不知道返回值类型，即返回值类型根据模板参数的类型而改变，我们可以使用尾置返回类型来解决这个问题。我们还可以通过标准库的类型转换模板，对模板类型进一步转换，比如去掉模板类型中的const，将模板类型的引用转换为值或指针。最后我们介绍了函数指针可以用于推断函数模板的实参。类型转换与模板类型参数模板实参在初始化的过程中，会采用特殊的初始化规则，这些规则约束只有几种有限的类型转换能够生效。而且在初始化的过程中，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。接下来我们总结一下这些模板参数的类型转换规则：  顶层const无论在形参还是在实参中，都可以被忽略。    //  声明部分template &lt;typename T&gt; T fobj(T,T);  //  实参会被拷贝template &lt;typename T&gt; T fref(const T&amp;, const T&amp;);  //  引用string s1(\"a value\");const stirng s2(\"anthor value\");//  例子部分fobj(s1,s2);  //  调用fobj(string,string);const被忽略      这里一个直观的解释是：fobj(T,T)在传参过程中会实参会进行拷贝，无论原对象是否为const，都没有关系。  const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参。    fref(s1,s2);  //  调用fref(const string&amp;, const string&amp;)           //  s1转换为const是允许的        数组和函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。    int a[10],b[42];fobj(a,b);  //  调用fobj(int *, int *)fref(a,b);  //  错误，形参是引用，数组不会转换为指针，所以类型不匹配      如上面例子所示，一个数组的实参可以转换为一个指向首元素的指针。类似的，一个函数的实参也可以转换为该函数类型的指针。  其他的类型转换都不能应用于模板函数（包括算术转换，派生类向基类的转换，用户自定义的隐式转换）。使用相同模板参数类型的函数形参一个模板类型参数可以用于多个函数形参类型，就像下面这样：template &lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2);但是由于上面所说的模板参数转换限制，如果推断出来的两个类型不匹配，就会调用错误，就像这样：long lng;compare(lng,1024);  //  错误，推断出类型为compare(long,int)当然，解决方法也很简单，我们只要为模板函数定义两个类型参数就可以了。当然要特别注意这些类型之间能使用比较运算符&lt;。template &lt;typename T, typename X&gt;int compare(const T&amp; v1, const X&amp; v2);...compare(lng,1024);  //  正确，调用compare(long,int);正常类型转换应用于普通函数实参模板函数中也有普通类型定义的参数，对于这一类参数，它们可以正常地进行类型转换，就像下面这样：template &lt;typename T&gt;ostream &amp;print(ostream&amp; os, const T&amp; obj){    return os &lt;&lt; obj;}print(cout,42); //  实例化print(ostream&amp;,int);ofstream f(\"output\");print(f,10);    //  实例化print(ostream&amp;,int);                //  f由ofstream转换为ostream类型指定显式模板实参有一种场景，我们希望能指定返回值的类型，便于用户选择合适的精度。于是我们定义这样的模板：template &lt;typename T1, typename T2, typename T3&gt;T1 sum(T2,T3);但这个时候出现问题了，我们知道模板函数的参数类型是根据实参推断出来的，上面的模板参数T1无法推断。那该怎么办呢？这时候我们可以提供显式模板实参(explicit template argument)来指定T1的类型。具体语法如下：auto val3 = sum&lt;long&gt;(i,lng);  //  实例化 long sum(int,long);显式模板实参是按从左到右的顺序进行匹配的，只有尾部（最右）的参数可以忽略。如果忽略了右边的参数，它们会根据函数实参来推断出模板参数类型。当然，如果推断不出来，将会报错。//  糟糕的设计：由于返回值必须显式指定实参，所以用户必须指定三个模板实参template &lt;typename T1, typename T2, typename T3&gt;T3 alter_sum(T2,T1);  val3=alter_sum&lt;long&gt;(i,lng);  //  错误，不能推断T3的参数类型val3=alter_sum&lt;int,long,long&gt;(i,lng);  //  正确，显式指定了所有参数正常类型转换应用于显式指定的实参如果模板类型参数已经显式指定了函数实参，那这些实参可以进行正常的类型转换，就像下面这样：//  模板函数定义template &lt;typename T&gt; int compare(const T&amp; v1, const T&amp; v2);long lng;compare(lng,1024);  //  错误，类型不匹配compare&lt;long&gt;(lng,1024);  //  正确，实例化compare(long,long);1024发生类型转换compare&lt;ing&gt;(lng,1024);   //  正确，实例化compare(int,int);lng发生类型转换尾置返回类型和类型转换我们上面提到用户可以通过显式指定实参来决定模板函数的返回值类型，但是有一种场景，返回值类型不能提前知道，而是根据函数的模板参数决定的。这种情况我们应该怎么办呢？template &lt;typename It&gt;??? &amp;fcn(It begin,It end){    //  处理序列    return *begin;  //  返回序列中一个元素的引用}我们可以看上面的代码，它的功能是传入一个序列的首尾迭代器，然后对序列进行一些操作，最后返回其中一个元素的引用。在这个例子中，返回值是根据传入的序列类型决定的，而编译器无法提前获知该类型。为了解决这个问题，我们可以采用尾置返回类型。我们先给出改造后的函数代码：template &lt;typename It&gt;auto &amp;fcn(It begin,It end) -&gt; decltype(*begin){    //  处理序列    return *begin;  //  返回序列中一个元素的引用}尾置返回类型的语法格式是：auto function(parameters) -&gt; result { ... }我们先将返回值类型声明为auto，然后在末尾result给出返回值类型。而decltype(*begin)函数的作用是传入一个序列，返回该序列的元素的类型的引用。比如我们传入string序列，返回类型为string&amp;；如果我们传入int序列，返回类型为int&amp;。进行类型转换的标准库模板类上面的fcn函数，我们再进一步探讨，如果我们需要返回的是一个元素的值，而不是这个元素的引用。这时候可能会犯难了，我们传入的是迭代器，而所有的迭代器操作返回的是一个引用。那怎么才能得到元素的值，而不是引用呢？答案是，使用标准库的类型转换(type transformation)模板。这些模板定义在头文件type_traits中。本例中，我们用其中一个模板remove_reference来获取元素类型。remove_reference的使用方式如下：remove_reference&lt;decltype(*begin)&gt;::typeremove_reference有一个模板类型参数和一个type的类型成员。如果我们用引用类型实例化remove_reference，则type会生成被引用的类型（值），比如remove_reference&lt;string&amp;&gt;，则type成员为string。通过remove_reference模板，我们就可以获取元素的值了！template &lt;typename It&gt;auto &amp;fcn2(It begin,It end) -&gt; typename remove_reference&lt;decltype(*begin)&gt;::type{    //  处理序列    return *begin;  //  返回序列中一个元素的拷贝}这里要注意，我们之前说过，模板通过作用域运算符(::)访问的名字默认表示变量，如果想让它表示类型，必须加上关键字typename。函数指针和实参推断如果我们将模板函数初始化为一个函数指针，或者将模板函数赋值给一个函数指针，编译器可以通过函数指针的类型来推断模板实参。我们先声明一个模板函数，然后再初始化一个函数指针：//  声明模板函数template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);//  用compare模板函数初始化函数指针int (*pf1)(const int&amp;,const int&amp;) = compare;函数指针pf1指定了参数类型是int，所以compare会实例化成compare(const int&amp;,const int&amp;)。当然，如果函数指针类型不能确定模板实参，就会产生错误。我们来看下面这个例子，函数func接受一个函数指针作为参数：//  普通函数声明void func(int(*)(const string&amp;, const string&amp;));void func(int(*)(const int&amp;, const int&amp;));//  调用函数funcfunc(compare);  //  错误，编译器不知道使用compare的哪个实例这个例子中，通过func的参数无法确定模板实参的唯一类型。也就是说，func既可以接受compare的int版本，也可以接受compare的string版本。由于存在分歧，所以导致编译失败。解决办法也很简单，只要我们使用显式模板实参，就可以消除func调用的歧义了。func(compare&lt;int&gt;); //  正确，传递参数为compare(const int&amp;, const int&amp;)所以，当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型和值。总结      将实传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换和数组（函数）到指针的转换    一个模板类型参数可以用于多个函数形参类型    如果函数参数类型不是模板参数，则对实参进行正常的类型转换    显式模板实参可以显式地指定模板参数类型    如果模板类型参数已经显式指定了函数实参，那这些实参可以进行正常的类型转换    如果返回值的类型根据类型参数的类型转换决定的话，我们可以通过尾置返回类型的写法来表示返回值类型    我们可以使用标准库的类型转换模板（如remove_reference），实现模板的类型转换    编译器可以使用函数指针的类型来推断模板实参    当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型和值  Reference[1] «C++ Primer»"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(3)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_3/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-02-27 16:01:00 +0800",
    





    
    "snippet": "定义模板  上两节我们介绍了函数模板和类模板的定义，在本节中我们将继续介绍模板中的一些其他细节。首先我们围绕模板参数，介绍了模板参数的作用域，在作用域中模板参数的名字会覆盖，但变量名字不能和模板参数相同，这会导致重定义。接着我们介绍了通过类的作用域运算符(::)来访问模板参数中的成员时，默认访问的是变量而不是类型，如果我们需要获取的是类型，需要加上关键字typename。然后我们介绍了默认模...",
    "content": "定义模板  上两节我们介绍了函数模板和类模板的定义，在本节中我们将继续介绍模板中的一些其他细节。首先我们围绕模板参数，介绍了模板参数的作用域，在作用域中模板参数的名字会覆盖，但变量名字不能和模板参数相同，这会导致重定义。接着我们介绍了通过类的作用域运算符(::)来访问模板参数中的成员时，默认访问的是变量而不是类型，如果我们需要获取的是类型，需要加上关键字typename。然后我们介绍了默认模板实参在函数模板和类模板上的应用。此外，我们还介绍了成员模板。成员模板就是普通类或模板类中本身是模板的成员函数。我们通过两个例子说明了成员模板在普通类和模板类中的应用。我们还简单介绍了显式实例化，它可以避免多个文件中实例化相同模板带来的额外开销。最后我们探讨了模板参数在智能指针上的应用。模板参数和作用域模板参数遵循普通的作用域规则。在模板作用域中，模板参数会覆盖外层作用域相同的名字。但是，与其他大多数上下文不同，模板中不能宠用模板参数名。typedef double A;template &lt;typename A, typename B&gt; void f(A a, B b){    A tmp = a;  //  外层中A是double的别名，但模板作用域中，A被覆盖为模板参数    double B;   //  错误，B已经声明为模板参数，不能再重用这个名字}由于模板参数名不能重用，在模板参数列表中，这个参数名也只能出现一次。template &lt;typename V, typename V&gt; ... // 错误，这里V不能出现两次类::类型成员我们给出一段代码，看看编译器是否能正确编译出来：template &lt;typename T&gt; void f(const T&amp;){    ...    T::size_type * p;}这句代码有个问题：T::size_type可以看作是一个类型，声明了一个*p的指针。但是它也可以看成是一个static变量，完成相乘操作。为了解决这个问题，c++默认通过作用域运算符(::)访问的不是类型，而是变量。当我们希望使用一个模板参数的类型成员时，要显式告诉编译器，这个名字(size_type)是一个类型。我们用关键字typename实现。template &lt;typename T&gt;typename T::value_type top(const T&amp; c) //  返回值类型T::value_type{    if (!c.empty()) return c.back();    else        return typename T::value_type();  //  括号()表示初始化一个容器}从上面例子看出，如果我们想要使用模板参数里面的类型，就要在前面加上关键字typename。默认模板实参（函数模板）我们可以给函数参数提供默认参数，同样的，我们也可以给函数模板提供默认参数，就像下面这样：template &lt;typename T, typename F = less&lt;T&gt;&gt;   //  声明模板参数F的默认值为less&lt;T&gt;int compare(const T&amp; va, const T&amp; v2, F f=F())  //  声明函数参数f的默认值为F(){    if(f(v1, v2)) return -1;    if(f(v2, v1)) return 1;    return 0;}如果我们没有给定模板参数F的话，就会使用默认的模板参数less&lt;T&gt;，而compare()函数会使用默认的参数F()。bool i = compare(0,42); //  F使用了默认参数如果传递完整实参的话，就不会调用默认参数，就像下面这样：Sales_data item1,item2;bool j = compare(item1,item2,compareIsbn);  //  compareIsbn是Sales_data类的比较辅助函数这里有一点要注意，与函数使用默认参数一样，只有当它右侧的所有参数都有默认实参的时候，才可以有默认参数。默认模板实参（类模板）同样的，默认模板实参也可以用于类模板上，类模板的定义就像下面这样：template &lt;typename T = int &gt;  //  模板参数T的默认值是intclass Numbers{public:    Numbers(T v=0):val(v) { }    ...private:    T val;};//  使用方法Numbers&lt;long double&gt; lots_of_percision; //  使用long double类型Numbers&lt;&gt; average_percision;  //  空&lt;&gt;表示使用默认类型非模板类的成员模板一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，我们称之为成员模板(member template)。成员模板不能是虚函数。我们通过一个例子给出成员模板的用法：class DebugDelete{public:    DebugDelete(std::ostream &amp;s = std::cerr):os(s) { }    //  普通类中的成员函数，功能是释放指针内存并打印日志    template &lt;typename T&gt; void operator()(T *p) const{ // 这里T的类型由编译器推断        os &lt;&lt; \"deleting pointer\" &lt;&lt; std::endl;        delete p;    }private:    std::ostream &amp;os;};//  使用方法double *p=new double;DebugDelete d;d(p);   //  推断模板参数类型T为doubleint *ip=new int;d(ip);  //  推断模板参数类型T为int类模板的成员模板我们知道类模板由模板成员，而成员模板也有自己的模板参数，所以我们要声明两次模板参数：template &lt;typename T&gt; class Blob  //  定义类模板的模板参数{public:    template &lt;typename It&gt; Blob(It b,It e);  //  定义函数模板的模板参数    ...};我们在类外定义成员模板的时候，也需要提供两次模板参数列表，类的模板参数列表在前，成员模板的模板参数列表在后：template &lt;typename T&gt;   //  定义类模板的模板参数template &lt;typename It&gt;  //  定义函数模板的模板参数Blob&lt;T&gt;::blob(It b, It e):data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)){ }当我们实例化类模板的成员模板时，我们需要同时提供两者的实参。同样的，类模板的模板实参需要我们显式提供，而成员模板的模板实参则由编译器进行推断。//  实例化Blob&lt;int&gt;，成员模板的模板类型是int*int ia[] = {0,1,2,3,4,5,6,7,8,9};Blob&lt;int&gt; a1(begin(ia),end(ia));//  实例化Blob&lt;int&gt;，成员模板的模板类型是vector&lt;long&gt;::iteratorvector&lt;long&gt; vi = {0,1,2,3,4,5,6,7,8,9};Blob&lt;int&gt; a2(vi.begin(),vi.end());//  实例化Blob&lt;string&gt;，成员模板的模板类型是list&lt;const char*&gt;::iteratorlist&lt;const char*&gt; w={\"now\",\"is\",\"the\",\"time\"};Blob&lt;string&gt; a3(w.begin(),w.end());显式实例化声明我们在多个独立编译的源文件可能使用了相同的模板，并且它们的模板参数是相同的，每个文件都会编译一个模板实例。在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重，为了解决这个问题，我们通过显式实例化(explicit instantiation)来避免额外开销。显式实例化的声明语法如下：extern template declaration;    //  declaration为函数模板或类模板的模板声明//  例子extern template class Blob&lt;int&gt;;declaration是一个类或函数的声明，其中declaration中的所有模板参数都要被替换成模板实参。当编译器遇到extern模板声明时，它不会在本文件生成实例化代码，并且告诉编译器在程序其他地方会有一个显式实例化定义。既然不会在本文件生成实例化代码，毋庸置疑，extern声明必须出现在任何使用此实例化版本的代码之前。还需要注意对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。显式实例化定义显式实例化可以实例化该模板的所有成员（包括内联成员函数）。它的语法如下：template declaration;   //  declaration为函数模板或类模板的模板声明//  例子template class Blob&lt;int&gt;;与显式实例化声明类似，这里的declaration中的模板参数必须已经被替换成模板实参。我们用一个例子来说明显式实例化的用法：假设我们有一个类模板Blob，它可能在多个文件中用到且编译。//  头文件 template.hpptemplate&lt;typename T&gt;class Blob{public:    T data;};//  文件1 test1.cpp#include \"template.hpp\"Blob&lt;int&gt; t1;Blob&lt;int&gt; t2;//  文件2 test2.cpp#include \"template.hpp\"Blob&lt;int&gt; t3;Blob&lt;int&gt; t4;你看，在文件1和文件2中都实例化了Blob&lt;int&gt;，造成了额外开销。当我们使用显式实例化时，代码会改写成这样://  头文件 template.hpptemplate&lt;typename T&gt;class Blob{public:    Blob(T t);    T data;};//  定义文件 template.cpp#include \"template.hpp\"template&lt;typename T&gt;Blob&lt;T&gt;::Blob(T t){    data = t;}template class Blob&lt;int&gt;; // 显式实例化定义，告诉编译器，在这里生成实例化代码 //  主文件 main.cpp#include \"template.hpp\"extern template class Blob&lt;int&gt;; // 显式实例化声明，告诉编译器，不需要生成实例化代码 int main(){    Blob&lt;int&gt; Blob(3);  //OK, 使用在template.cpp中的定义}当程序运行到主文件Blob Blob(3);时，由于上面使用了extern的声明，这里并没有生成实例化代码，实例化的定义在程序的其他地方。当程序运行到定义文件时，我们给出了构造函数的类外定义（一般在这里给出类的完整定义），然后使用了显式实例化定义。程序会在此处对Blob\\进行实例化操作。  这样，无论有多少个文件使用相同的模板进行实例化，最终实例化过程只会在定义文件template.cpp进行，极大地减少额外开销。  目前多文件模板实例化的模式有两种：      Borland模式Borland模式通过在编译器中加入与公共块等效的代码来解决模板实例化问题。在编译时，每个文件独立编译，遇到模板或者模板的实例化都不加选择地直接编译。在链接的时候将所有目标文件中的模板定义和实例化都收集起来，根据需要只保留一个。这种方法实现简单，但因为模板代码被重复编译，增加了编译时间。在这种模式下，我们编写代码应该尽量让模板的所有定义都放入头文件中，以确保模板能够被顺利地实例化。要支持此模式，编译器厂商必须更换支持此模式的链接器。    Cfront模式AT&amp;T编译器支持此模式，每个文件编译时，如果遇到模板定义和实例化都不直接编译，而是将其存储在模板存储库中（template repository）。模板存储库是一个自动维护的存储模板实例的地方。在链接时，链接器再根据实际需要编译出模板的实例化代码。这种方法效率高，但实现复杂。在这种模式下，我们应该尽量将非内联成员模板的定义分离到一个单独的文件中，进行单独编译。    在一个链接器支持Borland模式的编译目标（编译后的可执行文件）上，g++使用Borland模式解决实例化问题。比如ELF（Linux/GNU), Mac OS X, Microsoft windows，否则，g++不支持上述两种模式。除此之外，显式实例化和普通的实例化还有一些区别：普通的实例化会实例化该类，然后只有当某个成员函数使用时，才会实例化该成员函数。而显式实例化定义不同，编译器会实例化该类的所有成员，即使这个成员我们不会使用。所以这要求所用的类型必须能用于模板的所有成员函数，否则程序会报错。模板参数在智能指针上的应用我们知道智能指针unique_ptr可以绑定删除器，而且用户必须在定义unique_ptr时以显式模板实参的形式提供删除器的类型。所以删除器的类型是unique_ptr类的类型的一部分。也就是说，unique_ptr有两个模板参数，一个是管理的指针，另一个就是删除器的类型。这些类型在我们编译时就知道了（用户显式提供）。经过编译后，管理的指针直接调用用户提供的删除器执行操作，无额外的运行时开销。del(p); // del为实例化的删除器，p为管理的指针让我们来看看shared_ptr。shared_ptr允许用户重载默认删除器，我们可以随时改变删除器的类型。所以我们可以确定shared_ptr不能将删除器直接保存为一个成员，因为删除器的类型运行时才知道，而类的类型在运行时是不可改变的。所以调用删除器时，我们需要一次跳转操作，跳转到del保存的地址来执行对应代码。del ? del(p) : delete p;你可能觉得他们之间效率好像没什么区别，但是你别忘了，因为unique_ptr的删除器在编译期间就知道了，它可以编译成内联函数的形式，省略一次跳转操作。而shared_ptr的删除器必须经历一次间接的跳转操作。所以，通过编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过运行时绑定删除器，shared_ptr使用户重载删除器更方便。总结      模板参数会隐藏外层作用域中声明的相同的名字    在模板内不能重用模板参数名，在模板参数列表中也不能重用模板参数名    当我们希望通知编译器一个名字表示类型时，前面加上关键字typename    在新标准中，我们可以为函数模板和类模板提供默认实参    一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，称为成员模板    在新标准中，我们可以显式实例化声明和定义，它的作用是避免多个文件中实例化相同模板带来的额外开销    通过编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销    通过运行时绑定删除器，shared_ptr使用户重载删除器更方便  Reference[1] «C++ Primer»[2] C++11中模板隐式实例化与显式实例化的定义详解分析"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(2)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_2/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-02-24 11:22:00 +0800",
    





    
    "snippet": "定义模板  本节介绍关于类模板的内容，类模板与函数模板的不同之处在于，编译器不能推断出类模板的模板参数类型，必须显式指定。我们介绍了类模板的定义格式。同时要记住，类模板的每一个实例都是独立的，相互之间没有特殊的访问权限。类模板中的成员函数可能也是模板类型，它只有使用时才会实例化。接着我们还介绍了类模板在作用域内可以省略模板类名。而且我们还介绍了类模板和友元。在新标准中，c++还提供给我们模板...",
    "content": "定义模板  本节介绍关于类模板的内容，类模板与函数模板的不同之处在于，编译器不能推断出类模板的模板参数类型，必须显式指定。我们介绍了类模板的定义格式。同时要记住，类模板的每一个实例都是独立的，相互之间没有特殊的访问权限。类模板中的成员函数可能也是模板类型，它只有使用时才会实例化。接着我们还介绍了类模板在作用域内可以省略模板类名。而且我们还介绍了类模板和友元。在新标准中，c++还提供给我们模板类型别名的用法，让我们可以更方便地使用类模板。最后我们介绍了类模板中的static成员，同样的，不同实例的static成员是互相独立的，但相同实例的对象共享static成员。类模板与函数模板类似，类模板(class template)也是用来生成类的蓝图的。但是与函数模板不同，编译器不能推断出类模板的模板参数类型，我们必须在模板名后的尖括号中提供额外信息。就像下面这样：vector&lt;int&gt; vec;  //  提供int类型信息map&lt;string, double&gt; m;  //  提供string和double类型信息定义类模板与函数模板类似，类模板的定义以关键字template开始，接着跟着模板参数列表。我们可以将模板参数代替用户提供的类型或值，就像下面这样：template &lt;typename T&gt; class Blob{public:    typedef T value_type;    typedef typename std::vector&lt;T&gt;::size_type size_type;    //  构造函数    Blob();    Blob(std::initializer_list&lt;T&gt; il);    //  Blob中元素数目    size_type size() const { return  data-&gt;size(); }    bool empty() const { return  data-&gt;empty(); }    //  添加或删除元素    void push_back(const T&amp; t) { data-&gt;push_back(t); }    void pop_back();    //  元素访问    T&amp; back();    T&amp; operator[](size_type i);private:    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;    //  检查索引i是否越界    void check(size_type i,const std::string&amp; msg) const;};实例化类模板当我们使用类模板时，需要提供额外信息，这些额外信息被称为显式模板实参(explicit template argument)。它们被绑定到模板参数中，然后编译器使用这些模板参数实例化出特定的类。比如我们模板实参传入int，就会生成int版本的Blob（Blob&lt;int&gt;），就像下面这样：template &lt;&gt; class Blob&lt;int&gt;{public:    typedef int value_type;    typedef typename std::vector&lt;int&gt;::size_type size_type;    //  构造函数    Blob();    Blob(std::initializer_list&lt;int&gt; il);    ...private:    std::shared_ptr&lt;std::vector&lt;int&gt;&gt; data;    ...};一个类模板的每个实例都形成一个独立的类，它们彼此之间没有任何关联，也没有特殊访问的权限。比如Blob&lt;string&gt;类和Blob&lt;double&gt;类是两个不同且独立的类，不能互相访问对象私有成员。在模板域中引用模板类型模板的名字不是一个类型名，如果我们在模板中要使用其他模板类型，就需要将原来的模板参数类型T作为内部模板类型的实参。就像上面Blob模板类的例子，Blob是一个模板类，在它的作用域中还使用了模板类shared_ptr和vector，所以要将T作为它们的模板实参。std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;类模板的成员函数类模板中的成员函数可以在类模板内部定义，也可以在类模板外部定义。在类内部定义成员函数会被隐式声明为内联函数。定义在类模板外的成员函数要以template关键字开始，后接模板参数列表，而且要与类模板的模板参数相同，就像下面这样：template &lt;typename T&gt;   //  这里的T为模板实参ret-type Blob&lt;T&gt;::member-name(param-list);  //  注意这里的T是模板形参，形参要和实参相同实现check和元素访问成员根据上面的格式，我们来实现Blob模板类中未给出定义的几个成员函数，我们先实现check函数：template &lt;typename T&gt;void Blob&lt;T&gt;::check(size_type i, const std::string&amp; msg) const{    if(i &gt;= data-&gt;data()){        throw std::out_of_range(msg);    }}实现back函数：template &lt;typename T&gt;T&amp; Blob&lt;T&gt;::back(){    check(0,\"back on empty Blob\");    return data-&gt;back();}实现下标重载运算符函数：template &lt;typename T&gt;T&amp; Blob&lt;T&gt;::operator[](size_type i){    check(i,\"subscript out of range\");    return (*data)[i];}实现pop_back函数：template &lt;typename T&gt;void Blob&lt;T&gt;::pop_back(){    check(0,\"pop_back on empty Blob\");    data-&gt;pop_back();}Blob构造函数类模板的构造函数实现和成员函数的实现是一样的。我们先来实现它的无参构造函数：template &lt;typename T&gt;Blob&lt;T&gt;::Blob():data(std::make_shared&lt;std::vector&lt;T&gt;&gt;()){ }实现有参构造函数：template &lt;typename T&gt;Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il):data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)){ }使用有参构造函数：Blob&lt;string&gt; articles = {\"a\",\"an\",\"the\"};这里的构造函数参数是initializer_list&lt;string&gt;，列表中每个字符串常量都会被隐式转换为一个string。类模板成员函数的实例化默认情况下，一个已经实例化的类模板，其成员函数只有调用时才会进行实例化（有些成员函数没被调用，就不会实例化生成代码）。这里需要注意，这一特性使得即使某种类型不完全符合模板操作的要求，但是只要不符合要求的成员函数没有被调用，我们仍可以实例化该类。在类代码内简化模板类名的使用在类模板自己的作用域中，我们可以直接使用模板名而省略实参，就像下面这样：template&lt;typename T&gt; class BlobPtr{public:    ...    BlobPtr&amp; operator++();  //  这里完整形式是BlobPtr&lt;T&gt;&amp; operator++();    BlobPtr&amp; operator--();  //  这里完整形式是BlobPtr&lt;T&gt;&amp; operator--();    ...};在类模板外使用类模板名如果我们在类模板外定义成员函数，同样在作用域内可以省略实参，但作用域外比较指明实参：template &lt;typename T&gt; BlobPtr&lt;T&gt;&amp; operator++(){   //  由于返回值不在类的作用域内，所以要指明模板类型    BlobPtr ret=*this;  //  这里完整形式是BlobPtr&lt;T&gt; ret=*this;    return ret;}类模板与友元类模板中可能存在一些友元变量或函数，我们将三种情况进行讨论：  类模板与另一个模板之间存在友好关系这种情况我们必须先声明模板，就像下面这样：template &lt;typename T&gt; class BlobPtr;template &lt;typename T&gt; class Blob;template &lt;typename T&gt; bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);//  上面的BlobPtr和operator==()必须先声明，因为下面的Blob类定义中需要用到这两个声明//  同理operator==()函数参数中有Blob类型变量，所以Blob也必须先做声明template &lt;typename&gt; class Blob{    friend class BlobPtr&lt;T&gt;;    //  声明相同类型T的友元模板类    friend bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;); //  声明相同类型T的友元模板函数};当我们带入模板类型实参时，模板类的实参会作为友元的模板类型。Blob&lt;char&gt; ca;  //  BlobPtr&lt;char&gt;和operator==&lt;char&gt;都是本对象的友元Blob&lt;string&gt; ia;  //  BlobPtr&lt;string&gt;和operator==&lt;string&gt;都是本对象的友元这里需要注意的是，BlobPtr可以访问ca的非public变量，但是不能访问ia的成员变量。因为同一类型的实例才是该类型的类模板的友元，其他类型的友元类(或友元函数)没有特殊访问权限。  非模板类与模板类存在友好关系这种情况我们要先声明类模板，以便在非模板类中使用它，就像下面这样：template &lt;typename T&gt; class Pal;template &lt;typename T&gt; class Pal2;class C{    //  C是一个普通的非模板类    friend class Pal&lt;C&gt;;    //  只有用C类实例化的Pal类才是友元    template &lt;typename T&gt; friend class Pal2;    //  Pal2所有实例都是C的友元};  类模板的通用的友好关系在第1点钟，我们说明了只有同个类型T的模板函数和模板类才是友元，就比如例子中BlobPtr和operator==才是Blob的友元，而BlobPtr和operator==不是友元。这是特定类型的情况，那如果我们想让类模板中所有类型的实例，都成为该类的友元呢？template &lt;typename T&gt; class C2{    //  C2是以T实例化的类模板    friend class C3;    //  C3是非模板类，它的所有实例是C2的友元    template &lt;typename X&gt; friend class Pal2;    //  Pal2所有实例都是C2的友元    //  作为比较，我们说明了一个特定类型的友元    friend class Pal&lt;T&gt;;    //  只有相同类型的实例化才是C2的友元};所以，只要我们在类模板中加上模板声明，就可以让Pal2的所有实例都成为C2&lt;T&gt;的友元，但是请注意，内部的模板声明要使用X，不能和类模板本身使用相同的模板参数。模板类型别名众所周知，我们可以用关键字typedef来实现别名，就像下面这样：typedef Blob&lt;string&gt; StrBlob; 但是上面的别名实现方式有一个问题，因为模板不是一个类型，意味着我们只能给实例起别名，而不能给模板起别名。也就是说我们起别名的时候必须实例化，如果存在多个实例那就要起多个别名，这明显不是我们想要的起别名方式。typedef Blob&lt;T&gt; BlobPtr;    //  错误，Blob&lt;T&gt;不是一个类型所幸，新标准中提供了类模板定义别名的方式：template &lt;typename T&gt; using twin = pair&lt;T,T&gt;;twin&lt;string&gt; authors;   //  完整形式是pair&lt;string,string&gt; authors;你看，这样起别名的好处是我们只用带入一个模板参数T，而原来的pair&lt;T,T&gt;则需要带入两个相同的模板参数T。除此之外，当我们使用模板别名的时候，还可以固定其中一个或多个模板参数，就像下面这样：template &lt;typename T&gt; using pairNo = pair&lt;T,int&gt;;pairNo&lt;string&gt; books;   //  完整形式是pair&lt;string,int&gt; books;pairNo&lt;Student&gt; kids;   //  完整形式是pair&lt;Student,int&gt; kids;pairNo的用户只需要指定pair的第一个参数，而第二个参数则是默认的，在我们编写代码的过程中，这种起别名方式会给我们带来许多方便，增加代码的可阅读性。类模板的static成员类模板中还可以声明static成员，就像下面这样：template &lt;typename T&gt; class Foo{public:    static std::size_t count() { return ctr; }    ...private:    static std::size_t ctr;    ...};这里和普通类的static成员有一点区别：对于每一个Foo实例，即对给定任意类型X，都有一个Foo&lt;X&gt;::ctr和一个Foo&lt;X&gt;::count()成员。所有的Foo&lt;X&gt;类型的对象共享相同的ctr和count()成员，但是对于其他Foo&lt;T&gt;类型的对象，它们的静态成员是独立的。Foo&lt;string&gt; fs; //  fs的静态成员和f1,f2,f3的静态成员没有联系Foo&lt;int&gt; f1,f2,f3;  //  f1,f2,f3共享同一个静态成员除此之外，static成员也可以定义为模板：template &lt;typename T&gt; static std::size_t ctr;最后，类模板中的static成员和普通类的static成员的访问方式相同。同样地，一个static成员只有在使用时才会被实例化和初始化。Foo&lt;int&gt; fi;auto ct=Foo&lt;int&gt;::count();  //  通过类访问ct=fi.count();  //  通过实例化对象访问ct=Foo::count();   //   错误，不知道使用哪个实例的count()函数总结      类模板是生成类的蓝图，但是与函数模板不同，类模板的模板参数类型必须显式提供    一个类模板的每个实例都形成一个独立的类    类模板的成员函数必须具有和类模板相同的模板参数    默认情况下，对于一个实例化的类模板，成员函数只有在使用时才会被实例化    在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参    如果一个类模板包含非模板友元，则友元可以访问所有的模板实例    如果一个类模板包含模板友元，则友元可以访问所有模板实例，也可以只能访问特定实例    新标准允许我们为类模板定义一个类型别名    类模板可以声明static成员，而且static成员函数只有在使用时才会被实例化  Reference[1] «C++ Primer»"
  },
  
  {
    "title": "读书笔记 —— C++ 模板与泛型编程(1)",
    "url": "/posts/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B_1/",
    "categories": "Reading Notes, C++ Primer",
    "tags": "C++, Reading Notes, template",
    "date": "2023-02-23 19:27:00 +0800",
    





    
    "snippet": "定义模板  模板是C++泛型编程的基础。可以说模板是一份蓝图，只要我们提供足够的信息，模板就会转换为特定的类或函数。这一节我们把目光聚焦于函数模板。函数模板中，模板参数分为两类，分别是类型模板参数和非类型模板参数。我们在设计函数模板还需要注意减少对实参类型的要求，做到类型无关和可移植性。最后介绍模板的编译过程，以及模板实例化过程中出现错误报告。函数模板模板出现的契机很简单，如果我们有一个比较...",
    "content": "定义模板  模板是C++泛型编程的基础。可以说模板是一份蓝图，只要我们提供足够的信息，模板就会转换为特定的类或函数。这一节我们把目光聚焦于函数模板。函数模板中，模板参数分为两类，分别是类型模板参数和非类型模板参数。我们在设计函数模板还需要注意减少对实参类型的要求，做到类型无关和可移植性。最后介绍模板的编译过程，以及模板实例化过程中出现错误报告。函数模板模板出现的契机很简单，如果我们有一个比较函数，但是这个函数可能传入的类型不同，就像这样：int compare(const string&amp; v1, const string&amp; v2){    if(v1&lt;v2) return -1;    if(v2&lt;v1) return 1;    else return 0;}int compare(const double&amp; v1, const double&amp; v2){    if(v1&lt;v2) return -1;    if(v2&lt;v1) return 1;    else return 0;}虽然我们可以用重载实现多个compare函数，但是这样代码十分冗余，容易出错，而且对于用户自定义的类型要手动添加新的重载函数。为了解决这种不方便的情况，我们提出了模板，就像这样：template&lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2){    if(v1&lt;v2) return -1;    if(v2&lt;v1) return 1;    else return 0;}这就是函数模板(function template)，可以理解为是一个公式，只要我们传入特定的类型，就能生成指定类型的函数版本。关键词template后面跟着的是模板参数列表(template parameter list)，格式为/&lt;typename T1, typename T2,…&gt;，这个列表不能为空。在使用模板时，我们显式或隐式地指定模板实参(template argument)。实例化函数模板当我们调用一个函数模板的时候，编译器（通常）用函数实参来为我们推断模板实参。就像这样：//  编译器根据函数实参推断T为intcout&lt;&lt;compare(1,0)&lt;&lt;endl;编译器用推断的模板参数创建一个特定版本的函数的过程，称之为实例化(instantiate)。就像下面这样：//  实例化出 int compare(const int&amp;,const int&amp;);cout&lt;&lt;compare(1,0)&lt;&lt;endl;vector&lt;int&gt; vec1{1,2,3},vec2{4,5,6};//  实例化出 vector&lt;int&gt; compare(const vector&lt;int&gt;&amp;,const vector&lt;int&gt;&amp;);cout&lt;&lt;compare(vec1,vec2)&lt;&lt;endl;这些编译器生成的特定版本通常成为模板的实例(instantiation)。模板类型参数在compare函数中，T成为模板类型参数(type parameter)。我们可以将类型参数看作类型说明符，当作一种已知类型去使用它，即可以指定返回值类型或者参数类型，也可以在函数体中声明变量或者进行类型转换。类型参数参数前面必须使用关键词typename或者class，这两者含义相同（内置类型如int也可以使用class）。typename是模板广泛使用后才引入C++的，class是旧版的写法。//  正确，可以同时使用typename和classtemplate&lt;typename T,class U&gt;//  错误，U前面必须加上typename或classtemplate&lt;typename T,U&gt;非类型模板参数除了类型参数，模板还可以定义非类型参数。顾名思义，非类型参数就是一个值而非一种类型。此时我们不能再使用关键词typename或class，而是用特定的类型名来指定非类型参数。就像下面这样：template&lt;unsigned int N, unsigned int M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]) // (&amp;p1)[N]表示读取字符数组{    return strcmp(p1,p2);}//  调用代码compare(\"hi\",\"mom\");当模板实例化时，非类型参数可以由用户提供或者编译器推断得出，这些值必须是常量表达式。例如上面例子，N和M的值由调用代码的字符数组大小推断而出，这里N和M的值为3和4（字符数组结束符’\\0’占一位）。当然也可以由自己决定，就像下面这样：template&lt;class T,size_t N = 10&gt; //  自己决定N的值为10一个非类型参数可以是这两种情形：  整型。要求实参必须是常量表达式。  指向对象或函数类型的指针或引用。要求实参必须具有静态的生存期（不能是非static的普通局部变量或者动态对象）  nullptr或者0template&lt;class Type, void function(arg*)&gt;  // 非类型参数指向函数的指针inline和constexpr的函数模板函数模板可以声明为inline和constexpr，只要放在模板参数列表之后，返回类型之前即可：//  正确template &lt;typename T&gt; inline T min(const T&amp;,const T&amp;);//  错误，inline说明符位置不对inline template &lt;typename T&gt; T min(const T&amp;,const T&amp;);编写类型无关代码在编写泛型代码时，我们需要注意两个小细节：  模板中的函数参数用const的引用用const的引用，一是为了提高效率（引用效率高于赋值），二是保证函数可以用于不能拷贝的类型（有些类没有定义拷贝函数）。  确保模板中的函数参数都支持运算符我们看compare函数的两种写法：//  写法1if(v1&lt;v2) return -1;if(v2&lt;v1) return 1;//  写法2if(v1&lt;v2) return -1;if(v1&gt;v2) return 1;看起来第二种更自然一点，但是万一该类型支持&lt;运算符，不支持&gt;运算符，那代码不就出错了吗？第一种写法都使用&lt;运算符，可以降低这种事情发生的概率。当然，我们可以用less来定义我们的函数，它的好处是传入两个不相关的指针时（因为less限定了只能传入一种类型T），不会发生未定义行为。template&lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2){    if(less&lt;T&gt;()(v1,v2)) return -1;    if(less&lt;T&gt;()(v2,v1)) return 1;    else return 0;}模板编译当编译器遇到一个模板定义的时候，它并不生成实际代码，只有当我们实例化出模板的一个特定版本的时候，编译器才会生成代码。也就是说当我们使用模板的时候，才会生成代码。　　那模板的声明和定义是放在头文件呢？还是放在源文件中呢？当我们生成一个实例化版本时，编译器要求在实例化之前，需要掌握函数模板或类模板成员函数的定义。所以我们既要把模板的声明放在头文件中，也要把模板的定义放在头文件中。这里要注意，当我们实例化模板时，意味着要将模板实现出来，模板中所有涉及的函数声明、类型声明、类型关联的运算符的声明必须是可见的。换句话说，用户除了要包含模板的头文件，还要包含用来实例化模板的任何类型或函数的头文件。  函数和类的声明和定义      当我们调用普通函数时，编译器只需要掌握普通函数的声明即可。那我们可以把普通函数的声明放在头文件，把普通函数的定义放在源文件中。    当我们使用某个类的对象时，编译器则必须掌握类定义，但是类中成员函数的定义则不做要求。所以我们可以把类定义放在同文件中，把类的成员函数的定义放在源文件中。  模板编译时的错误报告刚刚我们讲了模板只有在实例化的时候才会生成代码，这一特性影响了错误何时被检测到，我们分为三个阶段。  编译模板本身时。这个阶段编译器只能检测一些语法错误，例如忘记分号或者变量名拼写错误。  遇到模板使用时。这个阶段编译器会检查实参数目是否正确，参数类型是否匹配。  模板实例化时。这个阶段编译器会发现类型相关的错误，比如类型不支持某个操作符。总结      函数模板可以根据模板类型的不同，生成特定类型的函数版本    编译器用推断的模板参数创建一个特定版本的函数的过程，称之为实例化    模板的类型参数不能为空，且必须使用关键字typename或class    模板的非类型参数的模板实参必须是常量表达式或者栈变量    模板程序应该尽量减少对实参类型的要求    函数模板和类模板成员函数的定义通常放在头文件中    大部分模板错误只有实例化时才能发现，所以调用者要保证传递给模板的实参支持模板内的操作  Reference[1] «C++ Primer»[2] std::less"
  },
  
  {
    "title": "读书笔记 —— Effective C++(9)",
    "url": "/posts/Effective-C++_9/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2023-02-22 14:55:00 +0800",
    





    
    "snippet": "  本节我们从类实现的角度来给出一些建议。在类的实现中，我们可以在变量使用之前的容易地方进行定义，但是不妥的定义位置可能会导致多余的运行成本，这个实现的小细节可能被很多人所忽略。此外，类实现时我们可能会用到一些转型，转型的表示方式有很多，但你会发现新式转型比旧式更加好用。转型不只是简单的换个解释方式，编译器会增加一些额外的语句转换变量。这导致了转型过程很容易出现错误，而且有一些转型特别费时，...",
    "content": "  本节我们从类实现的角度来给出一些建议。在类的实现中，我们可以在变量使用之前的容易地方进行定义，但是不妥的定义位置可能会导致多余的运行成本，这个实现的小细节可能被很多人所忽略。此外，类实现时我们可能会用到一些转型，转型的表示方式有很多，但你会发现新式转型比旧式更加好用。转型不只是简单的换个解释方式，编译器会增加一些额外的语句转换变量。这导致了转型过程很容易出现错误，而且有一些转型特别费时，我们应该用其他方法尽量避免转型。最后讲到类实现过程中的返回值问题，我们再一次声明了返回引用、指针和迭代器是很不安全的。但是为了提高效率，很多情况下我们得选择返回引用（比如数据储存在外部结构且数据量很大的情况）。这种情况我们可以用const修饰返回值，以此来达到可读不可写的目的。延后变量定义的时间避免无意义的成本当程序的控制流到达一个变量定义的时候（假设这个变量带有构造函数和析构函数），就能进入构造函数，产生构造成本。当这个变量离开其作用域的时候，就会产生析构成本。所以有些情况下，应该延后变量定义的时间，防止变量未被使用，就会耗费了构造和析构的成本。我们来通过下面这个例子说明这种情况：现在我们有一个加密函数，功能是对用户输入的密码进行加密。string encryptPassword(const string&amp; password){    string encrypted;    //  如果密码长度过短，我们抛出错误    if(password.length &lt; MinimumPasswordLength){        throw logic_error(\"password is too short!\");    }    encrypted=password;    encrypt(encrypted); //  执行加密    return encrypted;}我们可以看到，如果我们输入的密码过短，就会进入if分支中，从而抛出错误，下面的加密过程不会再进行。但是，上面实现中，我们先声明了变量encrypted，哪怕它并未被使用，我们也耗费了构造和析构变量encrypted的成本。这些成本完全是没有必要的。所以我们做出了如下修改：string encryptPassword(const string&amp; password){    //  如果密码长度过短，我们抛出错误    if(password.length &lt; MinimumPasswordLength){        throw logic_error(\"password is too short!\");    }    string encrypted;    encrypted=password;    encrypt(encrypted); //  执行加密    return encrypted;}现在这个函数少了不必要的构造和析构成本了。但是，它还不是完美的。还记得前面提到过尽量用初始化代替赋值吗？变量encrypted先调用了default构造函数，然后调用了赋值函数。如果我们直接使用copy构造函数，就可以免去无意义的default构造函数的成本，就像下面这样：string encryptPassword(const string&amp; password){    //  如果密码长度过短，我们抛出错误    if(password.length &lt; MinimumPasswordLength){        throw logic_error(\"password is too short!\");    }    string encrypted(password); //  copy构造函数    encrypt(encrypted); //  执行加密    return encrypted;}所以我们延迟变量定义的时间，应该尽可能延迟到该变量能够确定实参，这样不仅可以避免构造和析构无意义的对象，还能避免无意义的default构造行为。循环上面的建议可以让我们在很多地方受用，但我们很快发现了一个特殊情况：循环。我们先看下面两个循环体：//  循环1Widget w;for (int i=0;i&lt;n;i++){    w=arr[i];    ...}//  循环2for (int i=0;i&lt;n;i++){    Widget w=arr[i];    ...}现在我们来分析一下它们的成本：循环1： 1次构造函数 + 1次析构函数 + n次赋值操作循环2： n次构造函数 + n次析构函数它们的成本谁大谁小只能具体情况具体分析。如果赋值成本低于构造+析构成本，那循环1更加高效。尤其是n很大的时候，循环1的效率更明显。如果赋值成本高于构造+析构成本，循环2会更好。此外循环1中变量w的作用域更大，可能会与后续的变量产生冲突，降低代码的可阅读性和易维护性。所以除非赋值成本低于构造+析构成本，且代码对效率要求很高的时候，应该采用循环2的做法。总结      延后变量定义的时间，尽可能延迟到该变量能够确定实参    除非赋值成本低于构造+析构成本，且代码对效率要求很高的时候，循环2的做法会更好  减少转型转型是程序中危险却又必不可少的一个特性，如果可以，我们应该尽可能避免转型。在探讨减少转型之前，我们先来回顾一下转型。转型形式转型通常由三种不同的形式：  (T)expression;   //  将expression转型为T  T(expression);   //  将expression转型为T  c++提供的新式转型，分为四种:                  const_cast&lt;T&gt;(expression);通常用来将对象的常量性转除        dynamic_cast&lt;T&gt;(expression);主要用来实现“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法用旧式转型语法实现的动作，也是唯一可能耗费重大运行成本的转型动作        reinterpret_cast&lt;T&gt;(expression);reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位        static_cast&lt;T&gt;(expression);强迫隐式转换            新式转型比旧式转型更受欢迎，原因有以下两点：  相比旧式转型，新式转型在代码中更容易被辨认  新式转型作用范围变窄，编译器更可能诊断出错误转型动作有些程序员可能决定转型实际上什么也没做，只是让编译器将某种类型视为另一种类型，这是不对的。类型转换往往会令编译器产生一些代码，由这些代码来执行转型动作。我们来看下面两个例子：//  例子1int x,y;...double d = static_cast&lt;double&gt;(x)/y;上面将int类型转换为double类型，由于int类型和double类型底层的描述是不一样的，所以肯定产生一些代码完成转换操作，而不能单纯地将底层比特位换种方式解释。//  例子2class B1 {...};class B2 {...};class D : public B1, public B2 {...};int main(){\tD aD;\tD* pD = &amp;aD;\tB1* pB1 = &amp;aD;\tB2* pB2 = &amp;aD;\tcout &lt;&lt; *pD &lt;&lt; endl;\tcout &lt;&lt; *pB1 &lt;&lt; endl;\tcout &lt;&lt; *pB2 &lt;&lt; endl;\treturn 0;}//  输出结果：009DFE10009DFE10009DFE14上面这个例子可以看到，同一个指针，发生了隐式转换后的值可能是不相同的。原因是为了能正确得到Base指针值，编译器运气期间给指针加上了一个偏移量(offset)。所以单一对象可能拥有一个以上的地址。请注意，由于对象的结构布局和地址计算方式根据编译器的不同而不同，意味着更换平台后，“根据对象布局进行类型转换”这种做法不一定行得通。错误转型假设我们有个Window类和SpecialWindow类，这两个类是继承关系，且它们都有onResize()函数。如果我们需要在SpecialWindow的onResize()函数中调用Window的onResize()函数，下面做法是错误的：class Window{public:    virtual void onResize() { ... }    ...};class SpecialWindow:public Window {public:    virtual void onResize () {        static_cast&lt;Window&gt;(*this).onResize();  //  转型，然后调用基类的onResize函数        ... //  子类onResize函数的专属行为    }    ...}乍看之下没有什么问题，但是static_cast(*this)将this转型后，会返回一个this的副本，即当前对象base class成分的副本。接着我们在这个副本上调用Window::onResize()函数，然后在原来的对象上调用SpecialWindow::onResize()函数。如果这两个onResize()函数都涉及修改，就会造成base class成分的修改没有失效，而derive class成分的修改失效了。这种行为是不正确的，可能会造成bug。那怎么解决呢？很简单，调用base class版本的onResize()函数就可以了：class SpecialWindow:public Window {public:    virtual void onResize () {        Window::onResize();  //  调用Window::onResize()，作用在this上        ...    }    ...}错误的行为就像你想欺骗编译器将this视为一个base对象，而你的目的应该是调用当前对象的base版本的onResize()函数，所以拿掉转型才是正确之道。你可能注意到dynamic_cast用于继承类之间的转型，那是不是就能解决上述问题了呢？我们来看下面这个例子，你手上有base class的指针，但你想调用derive class中的操作函数，你可能自然而然地想用转型来实现。class Window{ ... };class SpecialWindow:public Window {public:    void blink();   //  只有SpecialWindow类才有blink()函数    ...}typedef vector&lt;shared_ptr&lt;Window&gt;&gt; VPW; //  用容器和智能指针管理VPW winPtrs;...for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); iter++ ){    if(SpecialWindow *psw=dynamic_cast&lt;SpecialWindow*&gt;(iter-&gt;get())){        pws-&gt;blink();   //  错误做法    }}这样做虽然程序并不会报错，但问题在于dynamic_cast实现的速度非常慢。因为dynamic_cast在向下转换的时候会进行安全检查，如果是多层继承或者多重继承，每一次继承都要执行检查，成本很高。所以我们应该尽量避免使用转型去完成上述操作。  dynamic_cast      dynamic_cast运行时会检查类型安全（转换失败返回NULL）    dynamic_cast在将父类cast到子类时，父类必须要有虚函数，否则编译器会报错    在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的    在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全    dynamic_cast利用c++的RTTI机制确保转换的正确性，RTTI指c++的运行时类型识别信息，这个信息是该类虚函数表中存放的typeinfo的指针，里面记录了该类的类型信息和继承关系。在进行动态类型转换时，先取虚函数表中的第-1个元素得到type_info类，然后判断是否是你要转换的类型以及在继承关系是否合法，最后再进行转型操作  由于效率低下，我们一般避免使用这种方法，替换方法有两种：  使用类型安全容器，即容器中只存储一种类型，避免通过Base接口处理对象typedef vector&lt;shared_ptr&lt;SpecialWindow&gt;&gt; VPSW; //  用容器和智能指针管理VPSW winPtrs;...for(VPSW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); iter++ ){    (*iter)-&gt;blink();    ...}当然这种如果有多种派生类，我们需要多个容器，这种方法并不方便。  在base class中提供virtual函数，这样就可以在不用转型的情况下，使用base class的接口操作derive class的函数。class Window{public:    virtual void blink(){ }    ...};class SpecialWindow:public Window {public:    virtual void blink();     ...}typedef vector&lt;shared_ptr&lt;Window&gt;&gt; VPW; //  用容器和智能指针管理VPW winPtrs;...for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); iter++ ){    (*iter)-&gt;blink();   //  错误做法    ...}绝对避免的转型在上面的例子中，如果derive class有多种类型，那对应的转型代码可能写成这个样子：typedef vector&lt;shared_ptr&lt;Window&gt;&gt; VPW; //  用容器和智能指针管理VPW winPtrs;...for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); iter++ ){    if(SpecialWindow1 *psw1=dynamic_cast&lt;SpecialWindow1&gt;(iter-&gt;get())){...}    else if(SpecialWindow2 *psw2=dynamic_cast&lt;SpecialWindow2&gt;(iter-&gt;get())){...}    else if(SpecialWindow3 *psw3=dynamic_cast&lt;SpecialWindow3&gt;(iter-&gt;get())){...}    ...}这种行为称为 “连串(cascading)dynamic_cast” 。我们要杜绝这种做法，因为：  dynamic_cast效率低，这样生成的代码又大又慢  如果产生或减少分支，上面的代码需要重新检查一遍  这样的代码可以采用基于virtual的函数调用取而代之总结      尽量避免转型，如果设计中有转型动作，尝试用其他解决方法替代它    如果转型是必要的，将他用某个函数包装起来，避免客户将转型放入自己的代码中    尽量用新式转型，因为新式转型更方便纠错和调试  避免返回handle指向对象内部成员这里的handle指的是引用，指针和迭代器，通过这些对象，我们可以修改对象内部的私有对象。首先让我们来看一个例子：我们用一个类表示矩形（左上角点和右下角点表示）//  表示点的类class Point {public:\tPoint(int x, int y);\tvoid setX(int x);\tvoid setY(int y);    ...private:\tint x, y;};//  表示矩形的结构体struct RectData {\tPoint ulhc;\tPoint lrhc;};//  用智能指针管理结构体class Rectangle {private:\tshared_ptr&lt;RectData&gt; pData;public:\tPoint&amp; upperLeft() const { return pData-&gt;ulhc; }\tPoint&amp; lowerLeft() const { return pData-&gt;lrhc; }    ...};upperLeft()和lowerLeft()函数表示返回左上角的点和右下角的点，但是这两个方法返回了引用，给了我们一个修改内部数据的机会：Point coord1(0, 0);Point coord2(100, 100);const Rectangle rec(coord1,coord2);//  (0,0),(100,100)rec.upperLeft().setX(50);//  (50,0),(100,100)upperLeft()和lowerLeft()应该是一个只读函数，矩阵对象rec也是声明为可读的，却发生了修改行为，这显然不对。我们可以从中看出：  成员变量的封装性可以被返回引用的函数改变。  如果const成员函数传出一个引用，后者所指数据与对象自身相关联，那这个函数调用者可以修改这笔数据。而我们前面提到的handle(引用，指针和迭代器)，都可以降低对象的封装性，使const成员函数发生对象状态的改变。但是有些情况我们可能不得不采用引用，像上面这个例子，类中的数据存储在外部结构体中，返回的对象可能特别大，对于一些效率要求比较高的程序而已，我们得想一个两全其美的解决方法。解决方法解决方法也很简单，只要在返回类型上加上const限制即可：class Rectangle {private:\tshared_ptr&lt;RectData&gt; pData;public:\tconst Point&amp; upperLeft() const { return pData-&gt;ulhc; }\tconst Point&amp; lowerLeft() const { return pData-&gt;lrhc; }    ...};修改之后，返回的Point点只可读，不可写。其他情形上面我们讲了返回对象的handle可能修改对象内部的私有数据，但还有一种很严重的情况：返回的handle可能指向一个不存在的对象。我们先来看下面这个例子：//  这是一个GUI类class GUIObject { ... };//  传入GUI对象，返回一个表示GUI外框的矩阵对象const Rectangle boundingBox(const GUIObject&amp; obj);接着我们这么使用这个函数：GUIObject* pgo;...const Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());我们来分析一下这段代码，boundingBox(*pgo)返回了一个临时对象，我们称为tmp，tmp调用了upperLeft()方法得到了Point对象。当语句结束后，tmp会被析构，也间接导致了Point对象也被析构，所以pUpperLeft会指向一个不存在的对象。这就是所谓的dangling handles（空悬、虚吊）。这也是函数返回handle可能造成的后果之一。最后我们强调，并不是说成员函数一定不能返回handle，比如我们通过[]获取vector元素的时候，是允许我们进行修改的。但这种情况毕竟是少数，我们在实现类的时候，对于返回handle的情况应该仔细斟酌。总结      避免返回handle(包括引用)指向对象内部成员  Reference[1] «Effective C++»[2] «C++ Primer»[3] dynamic_cast介绍[4] C++标准转换运算符之 reinterpret_cast"
  },
  
  {
    "title": "读书笔记 —— Effective C++(8)",
    "url": "/posts/Effective-C++_8/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2023-02-14 16:51:00 +0800",
    





    
    "snippet": "  上节我们讨论很多类设计过程的细节，这一节中，我们将尝试写一个swap函数。我们先写出它的普通版本。普通版本通过拷贝实现，某些情况下效率低下。所以我们决定用复制指针来代替拷贝整个对象，提出第二个特化版本。最后针对模板类型，我们提出自定义命名空间中专属版本。经典版本swap相信大家并不陌生，经典的swap函数写法如下所示：namespace std {    template&lt;type...",
    "content": "  上节我们讨论很多类设计过程的细节，这一节中，我们将尝试写一个swap函数。我们先写出它的普通版本。普通版本通过拷贝实现，某些情况下效率低下。所以我们决定用复制指针来代替拷贝整个对象，提出第二个特化版本。最后针对模板类型，我们提出自定义命名空间中专属版本。经典版本swap相信大家并不陌生，经典的swap函数写法如下所示：namespace std {    template&lt;typename T&gt;    void swap(T&amp; a,T&amp; b)    {        T temp(a);        a = b;        b = temp;    }}经典的版本只要类型T支持copy构造函数和copy赋值操作，就能实现swap操作。接下来我们要对这个swap版本进行改造，首先我们发现生成一个临时对象，再进行赋值，如果对象过大，赋值和构造的成本会很高，所以我们决定用指针来代替构造对象。特化版本pimpl(pointer to implementation)，意思是用指针指向一个对象，内含真正的数据，很多类设计时都会采用这样的思想。假如我们有一个类Widget，它的pimpl实现就会像下面这个样子：//  具体数据class WidgetImpl{public:    ...private:    int a,b,c;    vector&lt;double&gt; v;    ...};class Widget{public:    Widget(const Widget&amp; rhs);    Widget&amp; operator=(const Widget&amp; rhs){        ...        *pImpl = *(rhs.pImpl);    }private:    WidgetImpl* pImpl;};要实现Widget对象的置换，其他我们只要置换pImpl指针就可以了。但是default的swap算法并不知道这一点，而是复制了三次Widget，还复制了三次WidgetImpl，非常缺乏效率。所以针对Widget类，我们可以写出一个特化版本：namespace std {    template&lt;&gt;    void swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)    {        swap(a.pImpl,b.pImpl);    }}特化版本的swap算法只对Widget类生效，它交换了Widget对象的之间，避免了整个Widget类的赋值和构造，极大提升了效率。  这里有一点要注意：通常我们是不允许改变std命名空间内的任何东西，但允许为标准的template(如swap)创建特例化版本。当我们运行上面那个函数的时候，发现它竟然不能通过编译！因为Widget对象的pImpl成员是私有的，不能直接交换它们。我们有两个解决方法：  将特例化版本声明为类的友元  在类在实现一个swap，然后特例化版本调用类的swap函数第二个方法的实现如下所示：//  Widget类中声明一个swap方法class Widget{public:    ...    void swap(Widget&amp; other){        using std::swap;    //  这个声明很有必要，在下面做解释        swap(pImpl, other.pImpl);  //  交换指针    }};//  特例化版本调用类中的swap方法namespace std{    template&lt;&gt;    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b){        a.swap(b);    }}第二个方法的好处：  不但保证了程序能够通过编译  与STL容器保持一致性，即我们可以采用a.swap(b)的写法，也可以采用swap(a,b)的写法Widget模板版本Widget可以设计为一个模板，而不单纯是一个类，这样我们可以模板化Widget中的数据类型。我们将Widget声明为模板：template &lt;typename T&gt; class WidgetImpl { ... };template &lt;typename T&gt; class Widget { ... };然后我们修改对应的swap函数，使它能调用Widget模板：namespace std{    template&lt;typename T&gt;    void swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b){        a.swap(b);    }}但是当我们写完代码，发现它又不能通过编译了！我们探究原因，发现函数模板原本的写法:template&lt;typename T&gt; void swap(T&amp; a, T&amp; b);然后我们想将参数类型T特例化为Widget&lt;T&gt;类型。于是变成这样：template&lt;typename T&gt; void swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b);这种写法叫偏特例化(partially specialize)，将参数类型T特例化为某个子类型Widget&lt;T&gt;。但是C++只允许对类模板偏特例化，不允许对函数模板偏特例化。所以这段代码不能通过。既然不能偏特化，那我们只能重载一个函数来处理参数类型为Widget/的调用。因为Widget/类型相比类型T更加特例化，根据模板重载的匹配规则，会优先选择模板参数类型为Widget/的那个版本。  函数模板重载实现如下：namespace std{    template&lt;typename T&gt;    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b){  //  swap后面没有&lt;...&gt;        a.swap(b);    }}当我们觉得万无一失了，发现还是编译不过。原来std是个特殊的命名空间，不允许我们添加任何东西，即不能添加新的template。这是因为std的内容由C++委员会决定，标准委员会禁止我们添加已经声明好的东西。既然不能添加到std命名空间中，我们就添加到自定义的命名空间中。当遇到Widget&lt;T&gt;类型的对象想调用swap函数，只要想办法让它调用我们自己的命名空间中的那个版本就好了。首先我们先在自定义命名空间中，定义这个重载函数：namespace WidgetStuff{    ...    template &lt;typename T&gt; class Widget { ... };    ...    template &lt;typename T&gt;   //  这里不属于std命名空间    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&amp;&gt; b){        a.swap(b);    }}现在只剩最后一个问题了，如果遇到Widget&lt;T&gt;类型的对象想调用swap函数，我们怎么让它选择正确的版本呢？所幸，C++的名称查找法则（argument-dependent lookup）帮助我们解决这个问题。  ADL会先查找Widget所在的命名空间内是否有专属的swap函数  如果没有，则编译器会使用std命名空间中特例化的swap函数  如果没有对应的特例化版本，最后编译器会选择std命名空间中的通用版本这里有两点需要注意：  以下调用方式是错误的：std::swap(obj1,obj2);   //  会强制调用std中的swap版本（包括特例化版本和通用版本）  如果没有声明使用std的命名空间，即using namespace std，要加上using std::swap语句。    //  using namespace std;    //  如果没有这句声明using std::swap;    //  这个必须加上swap(obj1,obj2);      如果没有加上using std::swap语句，编译器会在WidgetStuff命名空间中查找swap函数，而不是在std命名空间中查找。如果WidgetStuff命名空间中的swap函数不符合要求，则会出现错误。所以using std::swap语句的作用是令std命名空间中的swap方法在当前作用域生效。总结      如果我们提供了一个member swap，也应该提供一个non-member swap来调用前者，对于class，我们还应该特化std::swap    调用swap时应该使用using声明式，即using std::swap    不要在std命名空间中添加任何新的东西  Reference[1] «Effective C++»[2] «C++ Primer»"
  },
  
  {
    "title": "Effective C++_7",
    "url": "/posts/Effective-C++_7/",
    "categories": "",
    "tags": "",
    "date": "2023-02-14 00:00:00 +0800",
    





    
    "snippet": "title: 读书笔记 —— Effective C++(7)authors: fanventorydate: 2023-02-14 16:51:00 +0800categories: [Reading Notes,Effective C++]tags: [C++, Reading Notes]—  本节我们专注于类内成员的一些设计细节。首先我们论证为什么不用public修饰成员变量，而是将...",
    "content": "title: 读书笔记 —— Effective C++(7)authors: fanventorydate: 2023-02-14 16:51:00 +0800categories: [Reading Notes,Effective C++]tags: [C++, Reading Notes]—  本节我们专注于类内成员的一些设计细节。首先我们论证为什么不用public修饰成员变量，而是将成员变量声明为private。其中最重要的一点是这样做可以保证类的封装性，为我们以后修改或扩展代码带来方便。接下来我们讨论了为什么要用non-member函数替换member函数。其中很重要的一点原因也是因为保证类的封装性，可见封装性的重要性。接着我们展示了non-member函数的实现。最后我们还是将目光放在non-member函数，发现在一些参数需要类型转换的函数中，non-member函数是我们唯一的选择。成员变量声明为private我们学习C++时，一般都会把成员变量声明为private，你知道这是为什么吗？为什么成员变量选择private，而不是public和protected类型？接下来我们从两方面探讨用private修饰成员变量的好处以及必要性： 首先我们论证为什么不用public修饰成员变量，然后我们再论证为什么不用protected修饰成员变量，最后我们得出结论，成员变量要声明为private类型。为什么不用public为什么不用public，我们给出四点理由：  语法一致性如果成员变量是public，意味着当我们使用点操作符(比如person.age)的时候，你会不清楚这里的age是成员变量还是成员函数，如果是函数，我们需要写成person.age()，在后面加上括号。虽然现在的IDE可以智能提示哪些是成员变量，哪些是成员函数，但是总有一些需要用到原始编辑器的地方（比如生产环境中使用vim）。这时我们查看类的定义去判断它是成员变量还是成员函数，这显得非常不方便。相反，如果成员变量都用private修饰，那我们只能通过成员函数去访问这些变量，可以省下很多时间，这就是语法的一致性。  控制成员变量的读写权限上面这个理由可能不能令你满意，那我们来看看其他好处。令变量声明为private，意味着我们可以控制成员变量的读写权限。举个例子，我们有三个成员变量a,b,c。其中a变量是可读可写的，b变量是只读的，c变量的只写的。如果我们用public修饰变量a，b，c，思考一下要怎么控制这三者的访问权限呢？我猜你想了半天，最后告诉我好像C++没有这样的关键词修饰读写权限，也就是说实现不了这样的功能。确实，public将所有的变量访问和修改权限放开了，导致我们不能精确地控制成员变量的读写权限。反过来，只要我们将所有成员变量改为private，收回访问和修改的权限，就能通过成员函数来控制读写权限。就像下面这样：class Access{public:    ...    int getReadWrite() const { return a; } // 读a    void setReadWrite(int value) { a = value; } // 写a    int getReadOnly() const { return b; } // 只读b    void setReadOnly(int value) { c变量的只写的 = value; } // 只写cprivate:    int a;  //  可读可写    int b;  //  只读    int c;  //  只写};  封装第三个建议成员变量不要使用public的原因是：private能够完成类的封装。封装是什么意思呢？让我们来想象一个场景：我们现在有一个自动测速程序，当汽车通过时，其速度会被记录。自动测试程序类中有一个计算平均速度的函数：class SpeedDataCollection{public:    void addValue(int speed);   //  记录速度    double averageSoFar() const;    //  返回平均速度    ...};现在averageSoFar()方法有两种实现：  每次记录速度，就自动计算最新的平均速度，然后存放在一个队列中。  记录速度到一个队列中，当我们需要计算平均速度的时候，才调用该方法计算平均值。这两种方法各有优劣，第一种节省了计算时间，当我们需要查询平均速度的时候，可以在O(1)时间能查出，适合查询比较频繁的场合。当然，缺点就是每次计算的平均速度都需要用一个队列存储，空间损耗比较大。第二种方法则相反，空间损耗比较小，调用averageSoFar()方法的适合才计算平均值，但是它的时间花销比较大，适合于数据量较小或者查询次数比较少的场合。这两种方法有各自适用的场合，在我们程序刚开始运行的适合，数据量较小，内存比较吃紧，可能会采用第二种方法。但当我们程序运行了很长一段时间，临时计算平均值所带来的时间开销以及无法忍受了，而且随着机器硬件的扩容，我们可能会转换第一种实现方法。这时候封装的好处就体现出来了，我们只需要修改类内对应函数的逻辑实现，就可以完成方法的转换。试想一下，如果我们的成员变量（比如该例子中记录速度的列表）声明为public，那客户可能外部代码中使用了记录速度的列表，当我们修改averageSoFar()的实现时，可能对应的数据结构也发生了改变，导致外部代码的那一部分也要发生修改，增加了程序的耦合性。所以成员变量声明为private可以增强代码的封装性，而封装性越强越有利于后续代码的扩展和修改。  保证约束，提供弹性将成员变量声明private意味着将变量隐藏在函数接口后面，这样我们可以通过函数接口实现一些约束条件，比如判断int类型的变量是否为负数。而反过来，将成员变量声明public，用户则可以直接调用该变量，使我们的约束条件失效。由于用private声明成员变量时，只有成员函数才能影响变量，所以我们的约束条件总能得到维护，还保留了日后修改这些条件的权利。除此之外，将成员变量声明private还可以让程序实现更具弹性。比如：  读写成员变量的时候，可以生成日志或通知其他对象  读写成员变量的时候，可以验证函数前提或事后状态，根据状态动态修改变量值  在多线程环境中同步控制环境变量为什么不用protected为什么不用protected？和上面所述不用public声明成员变量一样，上面的几点理由同样适用于protected数据：  语法一致性  控制成员变量的读写权限  封装  保证约束，提供弹性看到封装可能我们会有个疑问？我们知道protected修饰的变量只能被派生类访问，不能被其他外部类访问，那protected的封装性是否大于public呢？答案是：并非如此。封装性与移出该成员变量时被破坏的代码数量成反比。假设我们有一个public成员变量，并取消了它，所有直接使用它的成员函数以及外部代码都会被破坏。那我们假设有一个protected成员变量，同样取消了它，所有使用它的派生类都会被破坏。这两者对代码数量的破坏都是不可预估的，他们都不具备封装性。如果我们在编写代码的时候，使用了public成员变量或protected成员变量，就会很难改变这个变量涉及的一切代码，因为你需要大量的工作进行重写，重新测试，重写编写文档，重新编译。总结      成员变量应该声明为private，这有利于实现语法一致性，控制成员变量的读写权限，保证约束条件，为class实现提供弹性    protected并不比public更具封装性  用non-member函数替换member函数什么是member函数？什么是member函数？什么是non-member函数？我们先来看一个例子：我们有个class表示浏览器，其中有这三个函数，分别是清理缓存，清理访问过的URL历史记录，清理所有的cookies:class WebBrower{public:    ...    void clearCache();      //  清理缓存    void clearHistory();    //  清理访问过的URL历史记录    void removeCookies();   //  清理所有的cookies    ...};现在我们考虑用一个函数集成这三种功能，即清理系统所有缓存信息，我们有以下两种做法：  第一种，我们可以再写一个成员函数，该成员函数调用这三个清理函数。这种就是member函数（成员函数）。class WebBrower{public:    ...    void clearEverything(){        this-&gt;clearCache();        this-&gt;clearHistory();        this-&gt;removeCookies();    };    ...};  第二种，我们可以用一个外部函数通过对象调用这三个清理函数。这种就是non-member函数（非成员函数）。    void clearEverything(WebBrower&amp; wb){ wb.clearCache(); wb.clearHistory(); wb.removeCookies();}      这两种方法实现的功能一样，看起来也没太大区别，那有没有想过哪种方法会更好呢？我们先给出结论，用non-member函数替换member函数更好。现在我们从封装性的角度进行探讨：为什么non-member函数更好？封装性是把类中的一些数据隐藏，让客户看不见。前面我们说过，越多的东西被封装，我们改变这些东西的能力就越大，我们改变时影响的东西就越有限。那反过来，我们封装的数据是固定的，我们编写的成员函数越多，意味着封装的数据有更多的途径能被改变。那我们修改封装数据的时候，需要修改的成员函数就越多，这就意味着封装性越差。所以我们得出一个结论，越多的函数可以访问封装数据，封装性就越低。从这个角度讲，当然是non-member函数更好啦，它减少了一个可以修改封装数据的入口！这里有几个小细节需要我们注意：  封装的不止privat数据，还包括private函数、enums、typedefs等等  friend函数也可以访问private数据，所以我们也要用non-friend函数去替代friend函数  这个建议并不是说集成函数一定不是非成员函数，它也可以是其他class的member函数，因为这不会影响原来类的封装性怎么实现non-member函数？在C++中，一个比较自然的做法就是将clearEverything声明为一个non-member函数，并放置在WebBrower类所在的同一个namespace中。namespace WebBrowerStuff{    class WebBrower{        ...    };    void clearEverything(WebBrower&amp; wb);}我们将clearEverything()函数放到namespace中，可以带来许多好处：  namespace和class不同，前者可以跨越多个源码文件，但后者不能  clearEverything()函数只是一个提供便利的函数，它是可有可无的（可以通过调用三个清理函数实现），所以它并没用对WebBrower类有什么特殊访问的权力，它不应该成为一个member函数  将clearEverything()函数放到namespace中有利于扩展，降低编译依存性我们举个例子，现实生活中WebBrower类有大量的便利函数，有些是关于书签的，有些是关于cookie的。假设我们当前场景需要完成一些关于书签的工作，其他关于cookie的便利函数并不是我们想要的。这时候我们可以将不同的函数分离到不同的头文件。还记得namespace可以跨越多个源码文件吗？这些函数哪怕分离到不同的头文件，它们依然在同一个namespace下面。//  头文件webBrower.h 存放webBrower类和一些核心函数namespace WebBrowerStuff{    class WebBrower{...};    ... //  核心函数，所有客户都需要的}//  头文件webBrowerBookmarks.h 存放书签相关的便利函数namespace WebBrowerStuff{    ... //  存放书签相关的便利函数}//  头文件webBrowerCookies.h 存放cookie相关的便利函数namespace WebBrowerStuff{    ... //  存放cookie相关的便利函数}  在c++标准程序库中也是采用同样的做法，每个头文件（如,)声明std的某些机能，当我们想要某些功能时，只要引入相关的头文件即可。这允许客户只对他们所用的那一小部分系统形成编译相依。将多个便利函数分离到不同的头文件，使我们可以轻松地扩展功能。如果需要增加播放器相关的便利函数，只要在WebBrowerStuff命名空间下面建立一个新的头文件，然后完成函数声明即可。这是class所不具备的，因为class必须整体定义，不能被分割成多个片段。这样看，用non-member函数相比member函数还有利于扩展的优点。或许你会有一个小小的疑问，class也有扩展能力呀！那就是通过继承派生出新的类，从而获得新的功能。确实，class也有扩展能力，但它的扩展能力也有缺陷：  派生类无法访问基类中被封装的成员，也没有为类提供新的变化，这样的拓展并不符合继承思想的初衷  并非所有的class都是被设计为基类的总结      用non-member函数替换member函数。这样做可以增加封装性，扩展性  non-member函数解决参数类型转换问题我们用有理数乘法来举一个例子，说明non-member函数解决参数类型需要转换的问题。现在我们有一个有理数类Rational：class Rational{public:    Rational(int numerator = 0, int denominator = 1);   //  这里不使用explicit，                                                        //      允许int隐式转换为Rational类型    int getNumerator() const;    int getDenominator() const;    const Rational operator* (const Rational&amp; rhs) const;    ...private:    int numerator;    int denominator;};这个类实现了一个简单的相乘功能，可以将两个有理数相乘。这时候我们提出一个需求，让有理数和整数相乘（这很合理），让我们来看看运行结果：Rational r1(1,8);Rational result = r1 * 2; // okresult = 2 * r1; // error我们发现第二个乘法式子报错了，这和我们的逻辑不符，乘法应该满足交换律才对！我们先来探讨一下为什么第一个式子可以正常运行，而第二个式子不行。我们把这两个式子的函数调用展开：Rational result = r1.operator*(2); // okresult = 2.operator*(r1); // error我们可以看到，第一个式子中，r1调用了重载乘法运算符函数，实参为2。实参传入后发生了隐式类型转换，相对于这个这样：Rational tmp(2);    //  这里的2按顺序初始化给了numerator变量Rational result = r1.operator*(tmp); // ok而第二个式子中，整型数2调用了重载运算符operator，2怎么可能有重载这个运算符嘛，当然报错了。为了解决这个问题，我们想到2 * r1这种写法，编译器会尝试寻找对应的non-member operator函数，将函数转换成这种形式：result=operator*(2,r1);然后2可以隐式转化为Rational对象，那问题就简单了，只要我们编写一个non-member operator函数就可以了。我们在global作用域或者命名空间中插入non-member operator函数：namespace RationalStuff{\tclass Rational{...};    //  non-member operator*函数\tconst Rational operator* (const Rational&amp; lhs,const Rational&amp; rhs) {\t\treturn Rational(lhs.getNumerator() * rhs.getNumerator(), lhs.getDenominator() * rhs.getDenominator());\t}}然后我们再来编译运行上面的代码：Rational r1(1,8);Rational result = r1 * 2; // okresult = 2 * r1; // ok问题就顺利解决了！但是还有一个小疑问：operator*声明成一个friend函数呢？首先声明为friend函数是可行的，但我们并不支持这种做法，因为friend函数会破坏类的封装性（哪怕只破坏了一点点）。friend函数设计的初衷是使得普通函数直接访问类的私有数据，避免了类成员函数的频繁调用，从而节约处理器开销，提高程序的效率。但在现在cpu速度越来越快的今天，这点开销已经微乎其微了。相反，破坏封装性带来的危害更大。很多C++程序员认为如果一个与某个class相关的函数不该成为member函数，那就设计为friend函数，这是不对的。我们应该能不用friend函数就不用friend函数。总结      如果你需要为某个函数的所有参数进行类型转换，这个函数必须是non-member    我们应该能不用friend函数就不用friend函数  Reference[1] «Effective C++»[2] «C++ Primer»[3] C++中的friend函数详细解析（二）"
  },
  
  {
    "title": "读书笔记 —— Effective C++(6)",
    "url": "/posts/Effective-C++_6/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2023-02-09 16:16:00 +0800",
    





    
    "snippet": "  本节我们把目光专注于设计。首先我们先讨论接口的设计，一个好的接口应该容易正确被使用，不易被误用，所以在接口的设计中我们需要避免用户造成各种各样的错误，最大程度地保证用户正确使用接口。接下来我们来讨论类的设计，针对类的设计我们提出了一些问题。当我们设计类的过程中，可以对着这些问题一一斟酌。让接口容易正确被使用，不易被误用程序中各种各样的接口，就比如c++中，我们有function接口，cl...",
    "content": "  本节我们把目光专注于设计。首先我们先讨论接口的设计，一个好的接口应该容易正确被使用，不易被误用，所以在接口的设计中我们需要避免用户造成各种各样的错误，最大程度地保证用户正确使用接口。接下来我们来讨论类的设计，针对类的设计我们提出了一些问题。当我们设计类的过程中，可以对着这些问题一一斟酌。让接口容易正确被使用，不易被误用程序中各种各样的接口，就比如c++中，我们有function接口，class接口，template接口等等。每一个接口的设计都需要细微谨慎，因为这些接口是我们与用户交互的渠道之一，我们总是希望用户能以正确的方式使用我们的接口，使程序能够正确运行。但是现实往往并不如人意，用户总能以各种方式错误使用接口，使程序出现各种各样的bug。所以接下来我们介绍一些编写接口过程中容易犯错的地方，并提出一些建议来完善接口设计。  接口的参数顺序可能传递错误让我们先来看一个例子，我们需要设计一个日期类：class Date{    public:        Date(int month,int day,int year);    ...};第一眼可能觉得这个接口没啥问题，我们想要生成一个日期类，只要传入相应的参数就可以了。比如圣诞节是今年12月25号，那对应代码是：Date d(12,25,2023);但人是容易犯错的，万一用户忘记了接口参数的含义，以一个错误的顺序传入参数，看看会发生什么？Date d(25,12,2023); // 出现了25月份，很明显是错误的为了防止用户遗忘接口参数的含义，我们可以导入新类型。就像下面这样：struct Month{    explicit Month(int m):val(m){}    int val;};struct Day{    explicit Day(int d):val(d){}    int val;};struct Year{    explicit Year(int y):val(y){}    int val;};class Date{    public:        Date(const Month&amp; m,const Day&amp; d,const Year&amp; y);    ...};这样用户在使用这个日期类的时候，需要这样子编写代码：Data d(12,25,2023);  //  错误，类型不正确Data d(Day(25),Month(12),Year(2023));  //  错误，类型不正确Data d(Month(12),Day(25),Year(2023));  //  ok，类型正确当然，将Day，Month，Year封装成class，并进行加工完善，要比封装成struct更好。这里我们想说明引入新类型在很多场景中能避免错误，特别是这类参数顺序错误。  无效参数继续看上面的例子，用户在输入时，可能手误按到了2旁边的3，结果输入了这么一个日期：Data d(Month(13),Day(25),Year(2023)); //  很明显是12月而不是13月这个问题最好的解决方法就是约束对象的值，一个简单的方法就是在构造函数中加入判断语句，避免出现不合理的参数。不过这里我们还可以用另一种方法解决：就是用函数动态生成对象，从而达到限制输入值的目的，就像下面这样：class Month{    public:        static Month Jan() { return Month(1); }        static Month Feb() { return Month(2); }        ...        static Month Dec() { return Month(12); }    private:        explicit Month(int m);  //  将构造函数私有，从而禁止生成新的月份};Data d(Month::Dec(), Day(30), Year(2023));  接口不一致性在Java中，数组可以使用length属性获取长度，string也可以使用length类型获取长度，而对于List则要用size()方法获取长度；.NET中也引用，Arrays的长度属性是Length，而ArrayLists的长度属性则是count。这些接口的不一致性可能看起来没那么碍事，但这些不一致的地方多多少少会对开发人员和用户造成困扰和摩擦。所以我们设计接口的时候，最好要保持一致，不但接口内的相同属性保持一致，接口的前后版本之间也需要保持一致。  用户遗漏某个操作如果一个接口要求用户必须完成某个操作，则这个操作可能会忘记执行。我们举个例子来说明：现在我们有一个动态生成Investment对象的方法，为避免资源泄漏，要求我们在代码末尾将他delete掉：//  声明Invectment* createInvestment();//  使用{    Invectment* pInv=createInvestment();    ...    delete pInv;    //  接口要求及时delete掉资源，但用户可能忘记了}这种情况最好的解决方法是用到我们之前提到的智能指针。我们可以将对象值存储在shared_ptr中，然后返回shared_ptr类型，将delete的责任交给智能指针。shared_ptr&lt;Invectment&gt; createInvestment();这种做法也可以防止用户进行了多次delete。  用户不正确删除还是接着上面createInvestment()的例子，创建出来的对象有时候可能会提供一个接口（比如叫getRidOfInvestment）进行删除，但是用户却自作主张delete掉了，使系统造成不确定行为。比如我们用接口打开了一个数据库链接，但我们需要关闭时应该调用其close()方法，但用户却用了delete语句，造成了数据库连接一直存在，而没有被正确关闭。Invectment* pInv=createInvestment();...delete pInv;    //  错误操作getRidOfInvestment(pInv);   //  正确操作这种情况下我们受到智能指针的启发，只要给智能指针传递一个删除器，就能让智能指针在代码区块的末尾自动调用我们规定的删除函数。所以我们的代码可以这样修改：shared_ptr&lt;Invectment&gt; createInvestment(){    shared_ptr&lt;Invectment&gt; retVal(new Invectment(),getRidOfInvestment);    return retVal;}同时，shared_ptr还有一个好处就是可以解决cross-DLL问题，这个问题指对象在动态链接库DLL中new出来，但是在另一个DLL中被delete掉，由于在第一个DLL中new出来的地址，在另一个DLL中并不是同一个地址块，就会造成系统不确定行为。但是如果我们使用了shared_ptr，new出来的对象就会追踪到原来的DLL中，然后在原来的DLL释放内存。  解决跨DLL问题最好的方法就是设置为虚函数，因为设置成虚函数之后，类中会保存一个虚函数指针，这个指针是指向调用方法的指针，这样该对象释放时，虚析构函数就会沿着该指针找到原来DLL的代码区域，完成释放操作。std::shared_ptr的源代码中处理delete的函数就是个虚函数。总结      好的接口应该被正确使用，不容易被误用    防止接口误用有建立新类型，约束对象值，保持接口一致性，消除客户的资源管理责任等方法    shared_ptr可以防范跨DLL问题  class设计类的设计是一个很重要的话题，一个好的类应该语法直观，实现高效。所以在类的设计中，我们提出以下一些问题，这些问题将协助你完成类的设计。当我们在设计类时，围绕着这些问题细细思索，就能避免生成一些不良的类。1. 对象应该如何被创建和销毁？设计类的构造函数、析构函数以及内存分配函数和释放函数至关重要。2. 类的初始化和赋值应该有什么差别？类的初始化和赋值是不同的，所以设计过程中构造函数的正确实现可以使类更高效。3. 类的合法值类的成员函数、成员变量可能涉及一些约束条件。4. 继承的类是否需要配合？如果类继承了某些类，这些类中可能存在一些约束，也可能存在一些虚函数，这些都是你要遵守且配合的。5. 类的转换问题生成的类可能会面临一些隐式转换，则需要我们重载操作符函数。亦或者这个类不能隐式转换，那我们需要手动编写显式转换函数，同时禁用类型转换操作符和某些构造函数。6. 操作符和函数类型是否合理？生成的类需要声明哪些函数，其他哪些是menber函数，哪些是普通函数。7. 成员变量的选取成员变量哪个是public，哪些是private？同时还要考虑成员变量中存在class或friend的情况。8. 类是否有一般性？有时候可能因为针对类型的不同，生成了一组类，这时候你应该生成class template而不是定义一个新类。9. 新类的必要性新类是为了在此基础上加上一些新的功能的话，那是否有生成的必要？是修改原有类更好呢？还是增加新类更好呢？总结      类的设计至关重要，这些问题将协助你完成类的设计  参数设计我们知道函数参数分为实参和形参，在我们传入参数时，程序开辟新的内存空间，复制新参，生成一个新的临时副本在函数体内进行运算。有时候这个复制的过程可能会造成巨大的成本花销，就像下面这个例子：// Person类class Person{    public:        Person();        virtual ~Person();        ...    private:        string name;        string address;};// 继承Person类的Student类class Student{    public:        Student();        ~Student();        ...    private:        string schoolName;        string schoolAddress;};// 现在我们定义一个简单的函数，并将Student对象作为参数传入函数中bool validateStudent(Student s); // 验证学生身份函数Student plato;validateStudent(plato);当validateStudent(plato);被调用时，我们来看看发生了什么？  首先，Student的构造函数会被调用  接着，Student类中有两个string类型的成员变量，所以会调用两次string类的构造函数  其次，由于Student类继承了Person类，所以Person类的构造函数也会被调用  最后，Person类中也有两个string类型的成员变量，也调用了两次string类的构造函数所以最后一次调用函数，导致程序调用了一次Student构造函数，一次Person构造函数，四次string构造函数。而当我们函数返回的时候，需要调用对应次数的析构函数。如果我们的类更大，成员变量更多，一次传参的成本是相当大的。为了解决这个问题，我们想到了C++中的引用（reference）。我们把validateStudent函数修改成这样：bool validateStudent(const Student &amp;s); // 这里const是为了禁止修改Student对象的内容这样传递的方式效率会高很多，因为程序没有调用过一次构造函数和析构函数。接下来我们讨论引用传参中的三个细节：  引用传参是否一定比传值传参要好？答案肯定是不一定。首先先引用是以指针来实现的，当我们传入参数是一些内置类型（比如int），用传值传参会更加高效（节省了寻址时间）。其次，STL的迭代器以及函数对象，传值传参也比引用传参要高效，因为习惯上他们都被设计成以值来传参。  这时候又有人问了，采用引用传参是因为成本低，那占用空间比较小的类或结构体我是不是用传值传参就好了？答案也是否定的。有三点理由：  第一，类的成员变量小不代表构造函数的代价小。许多对象看起来内含的东西不多，只有一些指针，但复制他们却要复制对象内指针所指的每一样东西（包括大多数STL容器）。  第二，某些编译器对内置类型和用户自定义类型的态度不同，纵使他们底层是一样的。比如某些编译器会把double类型放入缓存器中，但如果某个类也是只有一个double变量，它却拒绝放入缓存器中。反过来如果我们用引用的方式，编译器一定会把对应指针放入缓存器中，加快读取速度。  第三，作为一个用户自定义类型，大小是可以变化的。一个类虽然目前不大，但以后内部实现可能发生改变。比如某些标准库的string类型比其他版本大7倍。  传值传参可能会引起切割问题首先我们来解释一下什么是切割问题（slicing problem）?我们的派生类传入函数，而函数参数定义是基类时，只有基类的构造函数被调用，也就是说对象在函数中不会表现派生类的特性。下面我们举一个例子来说明：我们有一个窗口系统，用来在屏幕上显示窗口。// 基类class Window{    public:        ...        string name() const;  //  返回窗口名称        virtual void display() const;  //  显示窗口及内容};// 派生类class WindowWithScrollBars:public Window{    public:        ...        virtual void display() const;  //  显示高级的条形窗口};接下来我们编写一个函数用来打印窗口名字，并显示窗口：void printNameAndDisplay(Window w){    cout&lt;&lt;w.name()&lt;&lt;endl;    w.display();}接着我们调用这个函数：WindowWithScrollBars wwsb;printNameAndDisplay(wwsb);结果这个对象被复制成一个基类对象Window，它显示的原始的Window窗口，而不是继承后华丽高级的条形窗口。也就是说，函数内调用的是Window::name和Window::display。当我们修改一下函数，改用引用传值后，这个问题就能迎刃而解了。我们传进来的窗口是什么类型，对应的参数w就会表现成什么类型。void printNameAndDisplay(const Window&amp; w){    cout&lt;&lt;w.name()&lt;&lt;endl;    w.display();}总结      尽量用引用传参代替传值传参，因为前者更高效，还可以避免切割问题    对于内置类型，STL的迭代器和函数对象，传值传参更加高效  设计返回值阅读了上面的内容，你可能会想那返回值是不是也能改成引用了。我们知道返回值在返回的时候，也是生成一个副本，然后函数内的变量会被销毁。根据这个思想，我们来设计出这么一个函数：// 这个函数的功能是两个有理数相乘const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs){    Rational result(lhs.n*rhs.n,lhs.d*rhs.d);    return result;}当我们运行的时候会发现result是一个local变量，它会在函数末尾销毁，返回了一个指向销毁内存的引用，如果我们使用返回值，就会陷入无定义行为。这时候你可能觉得有什么不对，只要result不自动销毁不就好了嘛，于是你修改了一下函数：const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs){    Rational *result=new Rational(lhs.n*rhs.n,lhs.d*rhs.d);    return *result;}新的函数确实不会像第一版一样变成一个无定义指针了，但又产生了一个新的问题：既然不会自动销毁，那谁来delete掉呢？且不说delete是一件容易忘记的事情，如果我们把代码写出下面这样：Rational w,x,y,z;w=x*y*z;你会发现上面的操作符相对于operator(operator(x,y),z)。x和y运算产生的返回值指针丢失了，这意味着你永远无法delete掉，导致内存泄漏。可能你感觉还是不对，那我把local变量变成全局变量呢，这样也能避免被自动销毁？于是突发奇想把函数修改成下面这样：const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs){    static Rational result;    result=...;    return result;}当我们运行的时候，好像没什么问题。但运行到下面这行代码的时候，又出现错误了：// 这个函数的功能是判断两个Rational对象是否值相等bool operator==(const Rational&amp; lhs,const Rational&amp; rhs);Rational a,b,c,d;...if((a*b)==(c*d)){    ...}else{    ...}你会发现无论a,b,c,d的值是多少，(a*b)==(c*d)总是返回true。这是因为(ab)返回的是静态变量result，(cd)返回的也是静态变量result，它们返回的是同一个东西，所以总是返回true。接下来你可能还是想对这个方法打补丁，用一个static列表代替呢？但打完补丁，新的问题就会随之而来。  列表的大小n怎么选择呢？n太大，则这些列表的初始化需要花费代价，降低程序效率。n太小，又会回到单个static设计面临的问题。  对象在这些列表中赋值需要调用一次析构函数（销毁旧值），再调用一次构造函数（复制新值）。和我们用值返回并没有区别，反而花费了构造列表的成本。所以并没有什么捷径，设计返回值最好的写法就是返回一个新的对象。长远来看我们付出了小小的代价，但我们保证了代码的正确性。所以正确的写法应该是这样的：const Rational operator*(const Rational&amp; lhs,const Rational&amp; rhs){    return Rational(lhs.n*rhs.n,lhs.d*rhs.d);}总结      函数返回值时，正确的写法是返回一个新的对象，而不是引用  Reference[1] «Effective C++»[2] «C++ Primer»[3] 跨DLL的内存分配释放问题 Heap corruption"
  },
  
  {
    "title": "读书笔记 —— Effective C++(5)",
    "url": "/posts/Effective-C++_5/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2023-02-07 20:12:00 +0800",
    





    
    "snippet": "  上一节中我们介绍了用智能指针来管理资源，这一节我们将再次强调资源管理的重要性。我们简单介绍一些资源管理方面容易疏忽的小细节，这些小细节可能会导致你看似使用了正确的语法，但结果却造成了资源内存泄漏。首先我们可能会遇到一些无法用智能指针的情况，这时候如果还想完成自动释放功能，需要自己手写一个类来封装原来的类。这个过程中需要注意的细节是复制行为的问题，复制过程中我们该如何处理封装类呢？这个问题...",
    "content": "  上一节中我们介绍了用智能指针来管理资源，这一节我们将再次强调资源管理的重要性。我们简单介绍一些资源管理方面容易疏忽的小细节，这些小细节可能会导致你看似使用了正确的语法，但结果却造成了资源内存泄漏。首先我们可能会遇到一些无法用智能指针的情况，这时候如果还想完成自动释放功能，需要自己手写一个类来封装原来的类。这个过程中需要注意的细节是复制行为的问题，复制过程中我们该如何处理封装类呢？这个问题的细节将在接下来做仔细探讨。接着我们讲述了实际应用中需要原始指针而不是智能指针的情况，介绍了怎么将智能指针转换成原始指针。然后我们介绍new和delete对象数组时容易造成内存泄漏的情况，要记住有[]则[]，无[]则无[]。最后我们建议用智能指针封装new出来的对象时，最好独立一行编写，否则它也有小概率造成内存泄漏。资源泄漏方面的细节有很多，需要我们在实际编写代码时处处小心，积累经验，避免犯错。自定义资源管理类的复制行为我们上一节提到用智能指针来管理类，可以在类生命周期的结束自动完成释放功能，避免内存泄漏。但是智能指针在一些情况下可能不适用，比如智能指针一般用来修饰heap-bese资源，对于静态资源，我们需要它在逻辑结束的地方完成一些指定动作。这时候我们需要自定义资源管理类。我们下面通过一个例子来说明：假设我们使用C API函数完成Mutex互斥器功能，共有两个函数可以使用。void lock(Mutex* pm);void unlock(Mutex* pm);现在我们自定义一个资源管理类将其封装起来，实现区块末尾自动解锁的功能（和自动释放类似，代码结尾我们很有可能忘记解锁Mutex对象）。我们的代码可以这么实现：//  Lock类实现class Lock{    public:        explicit Lock(Mutex* pm):mutexPtr(pm){            lock(mutexPtr);        }        ~lock(){            unlock(mutexPtr);        }    private:        Mutex mutexPtr;}//  Lock类使用Mutex m;    // 声明互斥器（静态变量）...{    Lock m1(&amp;m);    ...    //  区块结尾，自动调用析构函数完成解锁动作}对于资源的管理我们已经了解很多了，实现起来也并不困难，但这其中有一些我们需要注意的地方，比如当Lock发生了复制，我们要怎么处理？这里我们总结了这四种情况：  禁止复制像上面例子这种情况，互斥器Mutex应该只能有一个，复制功能是不合逻辑的。这种情况下我们可以禁用复制。class Lock: private Uncopyable{    public:        ...}  引用计数第二种情况是我们可以对底层资源进行引用计数，每复制一次计数加1，只有计数为0才释放对象内存（和shared_ptr的复制原理相同）。我们可以借助shared_ptr来改造我们的类：class Lock{    public:        explicit Lock(Mutex* pm):mutexPtr(pm,unlock){            lock(mutexPtr.get());        }    private:        shared_ptr&lt;Mutex&gt; mutexPtr;}  复制底部资源第三种情况就是我们将底部资源进行复制。当然这种情况我们要注意“深度拷贝”，防止复制了某个引用，导致删除原来对象的时候，复制对象的私有变量为空。  转移底部资源的拥有权这种情况和auto_ptr的做法类似，复制完成后，拥有权转移到新的对象中，而原有对象会变成一个空对象。即资源会从被复制物转移到目标物。总结      自定义的资源管理类常见的复制行为有：禁止复制，施行引用计数法，复制底部资源，转移底部资源的拥有权  访问原始资源需要访问原始资源的情况用智能指针管理资源是防止内存泄漏一个很棒的做法，我们可以通过智能指针来访问对象，从而避免直接使用原始指针。那问题来了，有没有哪一种情况我们不能使用智能指针而使用原始指针的呢？答案是有的。当我们创建一个对象，想调用别人的API时，却发现别人API要求的参数是原始指针，如果我们传入智能指针，会提示参数类型不匹配并报错，就像下面这样：//  创建一个对象，并用智能指针管理它shared_ptr&lt;Investment&gt; pInv(createInvestment());//  这时第三方提供一个API，参数要求是原始指针int daysHeld(const Investment *pi);//  我们无法修改第三方的API，直接调用又是不对的，所以我们只能通过智能指针访问原始资源int day=daysHeld(pInv); //  error，参数类型匹配错误访问原始资源的方法假设我们要用智能指针访问原始资源，我们有两种途径：  显式转换智能指针提供了get()方法执行显式转换，它会返回智能指针内部的原始指针，就像下面这样：int day=daysHeld(pInv.get());  隐式转换隐式转换指智能指针通过重载操作符的方式，允许我们访问原始资源，就像下面这样：int day=daysHeld(&amp;(*pInv)); // *pInv取出Investment对象，再转换为Investment *类型//  除此之外，还可以通过隐式转换直接调用内部方法(*pInv).isTaxFree();pInv-&gt;isTaxFree();重载隐式转换有些情况可能我们需要用自己的类来管理资源，这时候我们需要对原先的资源进行封装。同样地，为了实际需要，我们要给出它的显式转换函数，就像下面这样：class fontPackage{public:    //  这两个方法作用一致    char *GetFont(){        return f;    }    operator Font*(){        return f;    }private:    Font f; // 原生字体类};//  这时我们有一个需要调用内部资源的方法void testOperatorConvert(char *pf){    doSomething();}//  使用显式转换方法fontPackage fp;testOperatorConvert(fp.GetStr());//  使用隐式转换方法testOperatorConvert(fp);当然，隐式转换方法虽然便利，却可能出错fontPackage pf1(new Font);fontPackage pf2=pf1;// 这里原意是要复制一个fontPackage对象，但是由于发生了隐式转换，pf2复制了一个Font对象  隐式类型转换，实现的基本方法就是：operator type_name();总结      APIs往往要求访问原始资源，所以要提供一个获取原始资源的方法    对原始资源的访问有显式转换和隐式转换两种，一般来说显式转换更安全，隐式转换更便利  new和delete相对应我们先来看一段代码，观察这段代码是否存在问题：string* stringArr=new string[100];...delete stringArr;乍看之下好像没什么问题，new了对象之后在代码的末尾也及时delete了。但是我要告诉你，这段代码发生了内存泄漏！在解释为什么内存泄漏前，我们先来理解一下单一对象和对象数组有什么区别：单一对象的内存结构只有一块。|内存|而对象数组，结构中往往会有一个字段标识数组大小。|100|内存内存...内存|当我们new一个对象数组时，会先分配内存，然后调用100次构造函数。同样的，当我们delete时，会调用一次或多次析构函数，然后释放内存。现在看出问题所在了吗？因为我们使用的是delete而不是delete[]，导致了对象数组只调用了一次析构函数，而后面的99个对象造成了内存泄漏。  如果我们new了一个单一对象，但是调用了delete[]释放内存，则系统会读取前几个字节视为数组长度，然后调用析构函数释放掉后面连续的内存空间，造成了不确定行为。容易忽视的情况如果我们用typedef修饰对象数组，那delete过程则极容易犯错！！就像下面这样：typedef string addressLines[4];// newstring* pal=new addressLines;// deletedelete pal; // errordelete[] pal; //ok我们极可能看到new时没有[]，所以在delete的时候没有加上[]。但看清楚，我们typedef声明的时候，他就已经是个对象数组了。为了防止这种情况，我们一般建议使用vector来实现对象数组，比如vector。总结      如果new表达式中使用了[]，则相应的delete表达式要加上[]。如果new表达式中没有使用[]，则相应的delete表达式不能加上[]  以独立语句将new对象置入智能指针中我们先从一个例子入手，现在我们手上有两个方法，一个是动态定义优先级的方法，另一个是执行方法：int priority();void processWidget(shared_ptr&lt;Widget&gt; pw,int priority);接着我们来调用执行方法:processWidget(shared_ptr&lt;Widget&gt;(new Widget),priority());上面这个方法用智能指针管理了Widget对象资源，乍看之下好像没什么问题，但是我要告诉你：这条简单的语句可能会发生内存泄漏！在调用processWidget语句之前，系统会先完成三件事：  执行new Widget语句  调用shared_ptr构造函数  执行priority方法但c++编译器可能会进行优化：对这三件事的顺序进行调整，由于new Widget是shared_ptr构造函数的参数，所以new Widget一定比shared_ptr的构造函数先执行，但priority方法可以在任意阶段执行。  我们来下面这种执行顺序：  执行new Widget语句  执行priority方法  调用shared_ptr构造函数如果执行priority方法的过程中发生了异常！那第一步new出来的Widget对象就没有被delete掉，也没有被shared_ptr封装，所以Widget对象的内存就不会被释放掉，造成内存泄漏！为了解决这个问题，最好的方法是分离语句，就像下面这样：shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw,priority());这样子，编译器对于跨语句的操作并不会重新排列，因为程序是按代码行顺序从上往下执行的（只有在同一个语句内才有重新排列的自由）。从而达到避免内存泄漏的目的。总结      以独立语句将new对象置入智能指针中，可以避免同一语句中因为异常而导致的内存泄漏  Reference[1] «Effective C++»[2] «C++ Primer»[3] C++隐式类型转换 operator T"
  },
  
  {
    "title": "读书笔记 —— Effective C++(4)",
    "url": "/posts/Effective-C++_4/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2022-12-27 15:06:00 +0800",
    





    
    "snippet": "  众所周知我们编写程序的过程中经常会遇到需要动态对象的情况，我们new出动态对象时却由于各种原因可能忘记delete。这一章节我们先简单介绍了几种程序没有delete动态对象的情况。然后针对这个问题，我们介绍了采用c++中的智能指针来管理对象，从而能使对象在生命周期结束或发生异常的情况下，自动完成delete操作。用智能指针管理资源的释放我们在平时编写代码时，经常会new一些对象，然后在代...",
    "content": "  众所周知我们编写程序的过程中经常会遇到需要动态对象的情况，我们new出动态对象时却由于各种原因可能忘记delete。这一章节我们先简单介绍了几种程序没有delete动态对象的情况。然后针对这个问题，我们介绍了采用c++中的智能指针来管理对象，从而能使对象在生命周期结束或发生异常的情况下，自动完成delete操作。用智能指针管理资源的释放我们在平时编写代码时，经常会new一些对象，然后在代码的结束部分将他们delete掉。就像下面这样：void function() {    Person *p = new Person();    p-&gt;doSomething();    delete p;}我们知道如果没有及时delete我们创建的对象，就会造成内存泄漏。当然对于入门后的程序员来说，这肯定不会轻易忘记在末尾加一句delete。但现实比我们想象中的要复杂得多，有许多情况可能会导致我们并没有delete创建的对象。下面我们列举其中的几种情况：  过早地return我们可能在delete语句之前，先执行了return语句，导致并没有及时delete我们创建的对象。就像下面这样：void function() {    Person *p = new Person();    if(...) {        return;    }    p-&gt;doSomething();    delete p;}  过早地跳过或结束循环如果我们的delete语句在循环中（这极有可能），可能由于continue或者goto或者break语句，恰好跳过了delete语句。就像下面这样：void function() {    while(...){        Person *p = new Person();        if(...) {            continue;   // 看，这后面的p并没有被delete掉        }           p-&gt;doSomething();        delete p;    }}  抛出异常如果程序运行到delete语句之前，就发生了异常，那后面的delete语句将永远不会执行，同样跳过了delete！就像下面这样：void function() {    Person *p = new Person();    ... //  发生了异常，后面的语句都不会执行    p-&gt;doSomething();    delete p;}可见，现实情况之复杂将导致我们不会尽善尽美，算无遗策地delete任何一个new出来的对象。就算我们编写代码的时候足够小心，足够谨慎，那我们修改代码的时候呢？如果别人接手了你的代码，在你的delete语句之前加了一个判断语句执行return操作，是不是就导致了delete语句在某些情况下并不会执行？为了解决这个问题，我们的思想是在程序控制流运行到区域边界的时候，由对象的析构函数自动释放这些资源（即使遇到异常的情况，我们也希望能正确释放资源）。而我们发现C++的智能指针，正好满足我们的需求！所以接下来，我们需要解决的问题是让程序自动调用析构函数释放资源，同时我们将介绍三种智能指针来解决这个问题。  RAII思想：RAII(Resource Acquisition Is Initialization)指我们上述所提到的思想观念，当我们获得一个资源的时候（比如new了一个对象，获得指向该对象的指针），然后在同一语句内将它初始化给某个管理对象（智能指针），也就是说每一笔资源在获得的同时就立刻放入管理资源中。这样，一旦对象离开作用域，就会立即被其析构函数销毁。总结      为了防止资源泄露，我们建议用智能指针来管理资源的释放  智能指针C++主要的智能指针有3种，分别是unique_ptr、shared_ptr和weak_ptr这三种智能指针都定义在memory头文件中。他们都作用都是更加安全地使用动态内存，自动释放所指对象。接下来我们将一一介绍这几种智能指针。auto_ptr在介绍unique_ptr之前，我们先来介绍auto_ptr，它和unique_ptr功能类似，是c++11以前的最原始的智能指针，但是在c++11中已经被弃用（使用的话会被警告）了。c++11中完善了auto_ptr，推出了更加安全的unique_ptr。auto_ptr是一个包含指针的对象，其析构函数会自动对所指对象调用delete。用法如下：void function() {    std::auto_ptr&lt;Person&gt; peter(new Person()); // 创建一个父亲对象，并用auto_ptr管理    peter-&gt;doSomething();    // 作用域结束，auto_ptr的析构函数自动调用delete}这里需要注意的是，不能让多个auto_ptr指向同一个对象，就像下面这样：void function() {    Person *p=new Person(); // 当然，这里违反了RAII思想原则\tstd::auto_ptr&lt;Person&gt; peter(p);\tstd::auto_ptr&lt;Person&gt; peter2(p);\tpeter-&gt;doSomething();\tpeter2-&gt;doSomething();}在上面这个例子中，作用域结束时peter会delete掉Person对象p，然后由于peter2也指向了Person对象p，会尝试delete对象p。但由于对象p已经被delete掉了，所以程序报错，不能释放一个空指针。还有一个需要注意的点是，auto_ptr是独占性的，不允许通过赋值或copy构造函数使多个auto_ptr指向同一个资源。也就是说，通过赋值或copy构造函数复制auto_ptr对象的话，会把指针指传给复制出来的对象，原有对象的指针成员随后重置为nullptr，就像下面这样：void function() {\tstd::auto_ptr&lt;Person&gt; peter(new Person());\tstd::auto_ptr&lt;Person&gt; peter2(peter); // 这里指针转移给了peter2，peter所指指针为nullptr\tpeter-&gt;doSomething(); // error,peter所指指针为nullptr\tstd::auto_ptr&lt;Person&gt; peter3 = peter2; // 这里指针转移给了peter3，peter2所指指针为nullptr\tpeter2-&gt;doSomething(); // error,peter2所指指针为nullptr    peter3-&gt;doSomething(); // ok,Person对象指针最终被转移到peter3}unique_ptr由于auto_ptr可能通过赋值或copy构造函数传递所指指针，导致程序出现空指针异常，这样不但不安全，反而使程序更容易出错。为了解决这个问题，提出了unique_ptr。unique_ptr在执行赋值或copy构造函数时，编译期就会出错，而auto_ptr则可以通过编译期。同时为了解决指针转移的问题，给出了std::move(std::unique_ptr对象)语法以及reset()+release()的方法，相比auto_ptr更加安全。unique_ptr的用法如下：void function() {\tstd::unique_ptr&lt;Person&gt; father(new Person());\tfather-&gt;doSomething();\tstd::unique_ptr&lt;Person&gt; father2 = move(father); // 转移指针,father会变成nullptr\tfather2-&gt;doSomething();    // 作用域结束，unique_ptr的析构函数自动调用delete}unique_ptr还有几个常用的内置方法：  release()release方法的作用是使unique_ptr对象放弃当前所指指针的控制权，并返回指针，然后unique_ptr对象置空。需要注意的是，释放指针后我们需要自己负责资源的释放，例子如下：unique_ptr&lt;string&gt; p(new string(\"hello\"));p.release(); // 错误，这样字符串对象会悬空，没有任何指针指向它，造成内存泄漏auto q = p.release(); // 正确，获取释放的指针，然后手动释放delete q;  reset()reset方法意如其名，就是重置unique_ptr对象指向的指针，原来所指的对象会被释放，而unique_ptr会指向新的对象。它经常和release方法结合使用，用来转移指针的所有权给另一个unique_ptr对象。具体用法如下：unique_ptr&lt;Person&gt; p1(new Person(\"zhangsan\"));p1.reset(); // 释放p1所指指针Person *pt=new Person(\"lisi\");p1.reset(pt);  // 如果传入内置指针，就让p1指向这个对象p1.reset(nullptr); // 传入空指针，这和p1.reset();效果一致unique_ptr&lt;Person&gt; p2(p1.release()); // 利用release转移指针unique_ptr&lt;Person&gt; p3(new Person(\"wangwu\"));p1.reset(p3.release()); // 利用reset+release转移指针  get()get方法的作用是返回所指的指针，该方法设计的主要目的是为了向不能使用智能指针的代码传递内置指针。但是该方法存在需要隐患，例如我们返回了指针，然后手动释放了它，那智能指针所指的对象也就失效了。或者我们返回了指针，然后智能指针释放了其对象，那我们得到的指针就是一个无效的指针，同样会导致错误。unique_ptr&lt;Person&gt; p1(new Person(\"zhangsan\"));Person *p=p1.get(); // 获取p1的内置指针这里我们总结了几点建议：  不能使用get()初始化或reset另一个智能指针  如果你使用了get()返回的指针，记住最后一个对应的智能指针销毁后，你的指针就无效了  不要混用智能指针和内置指针，因为他们可能使彼此失效虽然说unique_ptr不能拷贝，但存在一种特殊情况：我们可以拷贝或赋值一个将要被销毁的unique_ptr。这种情况一般用于方法内返回一个unique_ptr对象。具体用法如下：unique_ptr&lt;int&gt; clone(int p){    ...    // 方法内返回unique_ptr对象    return unique_ptr&lt;int&gt;(new int(p));}unique_ptr&lt;int&gt; clone(int p){    unique_ptr&lt;int&gt; ret(new int(p));    ...    // 方法内返回一个局部对象的拷贝    return ret;}  boost库的boost::scoped_ptr也是一个独占性智能指针，但是它不允许转移所有权，从始而终都只对一个资源负责，它更安全谨慎，但是应用的范围也更狭窄。shared_ptrshared_ptr和unique_ptr的区别在于，shared_ptr不是独占的，允许多个shared_ptr指向同一个对象，并用一个计数器进行管理。只有当计数器中指向该对象的引用数为0时，才会释放该对象内存。shared_ptr的用法如下：shared_ptr&lt;string&gt; p1;shared_ptr&lt;list&lt;int&gt;&gt; p2;shared_ptr&lt;string&gt; p3(p1); // p3和p1指向同一个对象，次数该对象计数为2shared_ptr&lt;string&gt; p4(\"hello\");p4 = p1; // p4指向了p1所指的对象         // 原来p4所指的对象对应的计数会递减，由于减少到0，所以会释放该对象         // 原来p1所指的对象对应的计数会递增，现在p1,p3,p4指向了该对象，计数器为3接下来我们介绍shared_ptr的几个常用操作：  make_shared(args)make_shared方法的作用是动态分配一个T类型的对象并初始化它，然后返回该对象的shared_ptr。T为想要创建对象的类型，args为初始化参数，参数类型和数量需要与类T的构造函数对应。具体用法如下：// 指向值为42的intshared_ptr&lt;int&gt; p1=make_shared&lt;int&gt;(42);// 指向值为\"9999999999\"的stringshared_ptr&lt;string&gt; p2=make_shared&lt;string&gt;(10,'9');// 指向值为0的intshared_ptr&lt;int&gt; p3=make_shared&lt;int&gt;();// 我们还可以用auto来表示结果auto p4=make_shared&lt;vector&lt;string&gt;&gt;();  unique()unique方法的作用是判断所指对象的引用计数是否为1，若为1返回true，否则返回false。它的主要用途一般是判断自己是否是唯一引用的shared_ptr，如果是才能发现修改所指指针的值，而不会影响其他使用到该指针的地方。if(!p.unique()){    p.reset(new string(*p)) // 我们不是唯一的用户，生成一个新的拷贝}*p = \"hello world!\"; // 我们是唯一的用户，所以可以改变该对象的值  use_count()use_count方法的作用是返回共享对象的引用数，可能会运行得很慢，主要用于调试。  get()get方法与unique_ptr的get方法相同，详情见上文。shared_ptr也存在一些缺陷。  shared_ptr和unique_ptr都是在析构函数中做delete操作，而不是delete[]操作。这意味着，用智能指针管理动态分配的数组将是一个馊主意，因为这会导致内存泄漏。    unique_ptr&lt;string&gt; aps(new string[10]); // 错误，会调用错误的delete形式shared_ptr&lt;int&gt; spi(new int[1024]); // 错误        如果两个shared_ptr互相引用彼此，或者环状引用，那shared_ptr关联的计数永远不可能为1，这意味着它永远不会释放内存。让我们来看下面这个例子：```c++class Person {private: string name; shared_ptr father; shared_ptr son;public: void doSomething() { cout &lt;&lt; \"doSomething\" &lt;&lt; endl; } void setFather(shared_ptr&amp; person) { this-&gt;father = person; } void setSon(shared_ptr&amp; person) { this-&gt;son = person; } ~Person() { cout &lt;&lt; \"the process die\" &lt;&lt; endl; }};int main(){\tshared_ptr bigHeadSon(new Person());\tshared_ptr smallHeadFather(new Person());\tbigHeadSon-&gt;setFather(smallHeadFather);\tsmallHeadFather-&gt;setSon(bigHeadSon);\treturn 0;}我们通过输出可以发现bigHeadSon和smallHeadFather的析构函数并没有被调用，也就是说这两个对象并没有被释放掉。  我们来仔细分析一下，bigHeadSon的成员变量father关联了smallHeadFather，smallHeadFather的成员变量son关联了bigHeadSon。这时候bigHeadSon和smallHeadFather对应的引用计数均为2。当程序运行到作用域末尾：  + bigHeadSon智能指针退出栈，此时bigHeadSon引用数为1，smallHeadFather引用数为2  + smallHeadFather智能指针退出栈，此时smallHeadFather引用数为1，bigHeadSon引用数为1+ 函数结束：所有计数都没有变0，也就是说中途没有释放任何堆对象  为了解决这个问题，我们接下来提出weak_ptr。## weak_ptrweak_ptr是一种弱共享的智能指针，也就是说它绑定到一个shared_ptr中，但并不改变shared_ptr的引用计数，当weak_ptr计数为0时，并不改变对象的生命周期。相反，如果对象的shared_ptr计数为0时，哪怕对象绑定的weak_ptr引用计数不为0，依然改变不了对象被释放的结局。  基于weak_ptr的特性，我们可以修改上面这个例子，使多个智能指针中间的互相引用变得更加合理和安全。  ```c++class Person {private:\tstring name;\tweak_ptr&lt;Person&gt; father;\tweak_ptr&lt;Person&gt; son;public:\tvoid doSomething() { cout &lt;&lt; \"doSomething\" &lt;&lt; endl; }\tvoid setFather(shared_ptr&lt;Person&gt;&amp; person) { this-&gt;father = person; }\tvoid setSon(shared_ptr&lt;Person&gt;&amp; person) { this-&gt;son = person; }\t~Person() { cout &lt;&lt; \"the process die\" &lt;&lt; endl; }};int main(){\tshared_ptr&lt;Person&gt; bigHeadSon(new Person());\tshared_ptr&lt;Person&gt; smallHeadFather(new Person());\tbigHeadSon-&gt;setFather(smallHeadFather);\tsmallHeadFather-&gt;setSon(bigHeadSon);\treturn 0;}通过输出我们可以知道，bigHeadSon和smallHeadFather被正确得释放。这个例子中，当程序运行到作用域末尾：  bigHeadSon智能指针退出栈，此时bigHeadSon的shared_ptr引用数为0，weak_ptr引用数为1  smallHeadFather智能指针退出栈，此时smallHeadFather的shared_ptr引用数为0，weak_ptr引用数为1  函数结束：虽然两个对象的weak_ptr引用数均不为0，但由于weak_ptr补控制对象的生命周期，而shared_ptr的引用数都为0，所以两个对象都会被正确得释放此外weak_ptr没有重载 * 和 -&gt; 操作符，所以并不能直接使用资源。但我们可以通过它的一些内置方法操作对象。下面我们简单介绍几个常用的成员方法：  reset()reset方法和shared_ptr的reset方法功能差不多，可以用于赋值新的引用对象，也可以将当前weak_ptr指向空指针。  use_count()use_count方法返回的是与当前weak_ptr共享对象的shared_ptr的数量，要注意这里返回的是shared_ptr的数量，而不是weak_ptr的数量。  expired()expired方法是检查当前所指的对象是否已被释放，即当前所指共享对象的shared_ptr的数量是否为0，若为0返回true，否则返回false。  lock()lock方法是返回当前所指共享对象的shared_ptr，然后通过该shared_ptr来操作对象。当然，如果该对象已被释放，即该对象的use_count为0的话，将返回一个空的shared_ptr。所以weak_ptr在没有重载 * 和 -&gt; 操作符的情况下，我们需要通过lock方法间接获得shared_ptr来使用资源。具体用法如下：void function(){　　  shared_ptr&lt;Person&gt; p1(new Person());　　   weak_ptr&lt;Person&gt; w1 = p1;　　  w1-&gt;doSomething(); //Error! 编译器出错！weak_ptr没有重载* 和 -&gt; ，无法直接当指针用　　   \t\t        shared_ptr&lt;Monster&gt; p2 = w1.lock();  p2-&gt;doSomething(); // OK! 可以通过weak_ptr的lock方法获得shared_ptr来操作对象}deleter有些情况我们需要自定义结束操作，例如我们用一个对象管理数据库连接，而我们经常会忘记关闭连接操作（这和忘记delete是一样的），那我们同样可以用智能指针来管理资源。但这个时候，当数据库连接器的生命周期结束时，我们需要做的不是销毁这个对象，而是让这个对象关闭连接。幸运的是c++中的智能指针为自定义结束操作提供了很好的灵活性，只要我们传入一个自定义函数，就可以完成自定义的结束操作。具体用法如下：void endConnection(connection *p){    close(p);   //  关闭数据库连接}void function(){　　    connection c = connect(...); // 获取数据库连接    shared_ptr&lt;connection&gt; p(&amp;c,endConnection);    ... // 执行数据库相关操作    // 当退出函数时（即使遇到异常情况），connection对象都会自动执行endConnection方法关闭连接}// 在unique_ptr中，由于模板的原因，写法有略微不同void function(){　　    connection c = connect(...); // 获取数据库连接    // decltype作用是指明函数指针类型，由于decltype返回一个函数类型，所以需要加*来表明当前传递的是一个指针    unique_ptr&lt;connection,decltype(endConnection)*&gt; p(&amp;c,endConnection);    ... // 执行数据库相关操作    // 当退出函数时（即使遇到异常情况），connection对象都会自动执行endConnection方法关闭连接}总结      不要使用std::auto_ptr，它已经过时了    当你需要一个独占资源所有权（访问权+生命控制权）的指针，请使用std::unique_ptr    当你需要一个共享资源所有权（访问权+生命控制权）的指针，请使用std::shared_ptr    当你需要一个能访问资源，但不控制其生命周期的指针，请使用std::weak_ptr    建议使用一个shared_ptr和n个weak_ptr搭配，而不是定义n个shared_ptr。  Reference[1] «Effective C++»[2] «C++ Primer»[3] C++智能指针详解"
  },
  
  {
    "title": "读书笔记 —— Effective C++(3)",
    "url": "/posts/Effective-C++_3/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2022-12-08 19:43:00 +0800",
    





    
    "snippet": "  这一节重点探讨构造函数、析构函数、以及赋值操作函数，他们与类的生命周期有关，其中有很多细节值得我们去思考。我们知道在类中如果没有显示声明构造函数、析构函数、copy构造函数、赋值重载函数，编译器则会自动生成这些函数。这些自动生成的函数在某些特殊情况下可能会出错。同时在某些特殊情况下，我们要拒绝自动生成这些函数（或者说让这些函数调用时失效）。当然自己显式定义这些函数是一个好的方法，但是有更...",
    "content": "  这一节重点探讨构造函数、析构函数、以及赋值操作函数，他们与类的生命周期有关，其中有很多细节值得我们去思考。我们知道在类中如果没有显示声明构造函数、析构函数、copy构造函数、赋值重载函数，编译器则会自动生成这些函数。这些自动生成的函数在某些特殊情况下可能会出错。同时在某些特殊情况下，我们要拒绝自动生成这些函数（或者说让这些函数调用时失效）。当然自己显式定义这些函数是一个好的方法，但是有更方便的方法吗？当我们声明基类时，构造、析构函数往往要声明virtual。virtual析构函数有一些比较有意思的用法。最后当析构函数出现异常时，我们应该吞下或者直接中止，同时把异常的处理交给程序员而不是由析构函数抛出。最后，我们要注意不要在构造、析构函数内调用virtual函数，因为你调用的不是派生类的版本。自动生成构造/析构/赋值函数C++中如果我们没有声明和定义构造函数、析构函数、copy构造函数、赋值重载函数，则编译器会为我们自动生成这些函数。例如我们实现一个空类：class empty{ };经过编译器编译后，会自动生成构造函数、析构函数、copy构造函数、赋值重载函数，就像下面这样：class empty{public:    empty() {}    empty(const empty &amp;rhs) {...}    ~empty() {}    empty&amp; operator=(const empty &amp;rhs) {...}};这些知识相信大家都十分了解，我们接下来讨论一些细节：  如果我们自定义了构造/析构/赋值函数，那编译器就不会自动生成已有的那个函数。  如果成员变量是引用或者const修饰，则编译器拒绝编译赋值动作。第1点相信大家再熟悉不过了。针对第2点，我们先来看下面一段代码：template&lt;class T&gt;class Object{public:    Object(std::string &amp;name,cosnt T&amp; value);private:    std::string &amp;name;    const T value;};考虑下面一段代码：std::string newDog(\"peter\");std::string oldDog(\"satch\");Object&lt;int&gt; P(newDog,2); // 一只叫peter的小狗，岁数为2Object&lt;int&gt; S(oldDog,1); // 一只叫satch的小狗，岁数为1P=S;    //  现在p变量会发生什么呢？我们假设赋值成功，对象P和S的成员变量name指向同一个引用，那修改P对象的name值也会影响S对象的name值。但这就不对了呀，S只是赋值给P，并不是P引用S。而且C++不允许，让声明的reference引用指向不同的对象。同样，对于const的成员变量，赋值操作会修改成员变量的值，更改const变量同样是不合法的。最后还有一种情况，如果某个基类将赋值操作函数定义为private，然后用派生类去继承它。编译器会拒绝自动生成一个赋值操作函数。这是因为当派生类的赋值操作需要调用基类的赋值操作函数，而基类的赋值操作是private，派生类并没有权限，所以编译器只能作罢。  以上三种情况，会导致编译器拒绝自动生成构造/析构/赋值函数。总结      编译器会在类缺省的情况下，自动生成构造/析构/赋值函数，但某些特殊情况例外  拒绝自动生成构造/析构/赋值函数我们假设一个场景，我们需要定义一个类来表示狗，但是按照现实逻辑，没有两条一模一样的狗，就好比如没有两个一模一样的人。按照这个逻辑，这个类并不能具备拷贝构造函数和赋值操作函数。代码逻辑如下：std::string newDog(\"peter\");std::string oldDog(\"satch\");Object&lt;int&gt; P(newDog,2); // 一只叫peter的小狗，岁数为2Object&lt;int&gt; S(oldDog,1); // 一只叫satch的小狗，岁数为1Object&lt;int&gt; R(P); // No，peter狗是唯一的P=S;  // No，peter和satch是两条不一样的狗你可能会想，我们修改这两个函数的定义为空不就好了。但是这样做，编译可以通过，但在程序运行时会报错，这是我们不希望发生的，我们希望在编译阶段就发现错误，这是不能赋值的！为了解决这个问题，我们提出几种方法：  我们发现编译器产出的函数都是public，那意味着我们只要把拷贝构造函数和赋值操作函数声明为private，就可以在程序编译P=S；时报错。但是这个做法不是绝对安全的，因为member函数和friend函数也可以调用private函数。  针对这个点，我们发现只要声明函数而不去定义，那在编译器的连接阶段，P=S；这样的语句就会抛出连接错误。这样就可以解决member函数和friend函数调用问题。template&lt;class T&gt;class Object{public:    Object(std::string &amp;name,cosnt T&amp; value);private:    std::string &amp;name;    const T value;    Object(const Object&amp;); // 这里参数名是可以省略的，因为我们并不需要使用它    Object&amp; operator=(const Object&amp;);};  我们注意到上面讲到有一种情况下也会阻止编译器自动生成函数，那就是基类定义了构造/析构/赋值函数，且类型为private的时候。基于这个思路，只要我们定义一个uncopyable类，然后继承它，就能解决问题了。代码逻辑如下：    class uncopyable{protected: uncopyable() { } ~uncopyable() { }private: uncopyable(const uncopyable&amp;); uncopyable&amp; operator=(const uncopyable&amp;);};//  继承uncopyable类class Object: private uncopyable{ ...};        Boost也提供了类似的版本，名为noncopyable。总结      如果要阻止编译器生成构造/析构/赋值函数，可以采用声明为private类型，且不定义，或者继承uncopyable类的方法。  多态基类声明为virtual析构函数我们知道C++中存在多态，可以让我们通过基类指针指向派生类，从而实现工厂模式。代码逻辑如下：class TimeKeeper{public:    TimeKeeper();    ~TimeKeeper();};class AtomicClock: public TimeKeeper {...}; //  原子钟class WaterClock: public TimeKeeper {...}; //  水钟class WristWatch: public TimeKeeper {...}; //  腕表//  通过base class指针，指向derived class对象TimeKeeper *ptk=getTimeKeeper();    //  动态分配对象，可以是原子钟、水钟或者腕表... //  运用钟delete ptk; //  释放资源但上面代码存在一个错误，基类没有声明virtual析构函数，导致我们执行delete ptk;时，base部分被释放了，但derived部分没有被销毁，从而造成资源泄漏。所以我们需要在base class中将析构函数声明为virtual。此时它会销毁整个对象，而不是base的局部部分。代码修改如下：virtual ~TimeKeeper();构造函数为什么不能是virtual函数？因为virtual函数的执行依赖于virtual函数表，而virtual函数表的初始化是在构造函数中完成，所以构造函数无法声明为virtual函数。也就是说，构造函数中构造出virtual函数表，然后类中各个virtual成员函数根据virtual函数表执行。先有构造函数，再有virtual函数表。为什么默认的析构函数不是virtual函数？回答这个问题前，首先思考一下，所有析构函数都需要声明为virtual吗？我们先看一个例子：class Point{public:    Point(int xCoord,int yCoord);    ~Point();private:    int x,y;};这是一个二维空间坐标点类，它有两个成员变量（x和y），而一个int型变量占32bits，所以一个Point对象应该占64bits。在一些跨语言应用中，还可以当初64-bit量传递给其他语言，比如C语言。但是如果声明为virtual成员函数，则对象必须携带某些信息，用来执行运行期间该virtual函数调用哪一个版本。这些信息通常由vptr（virtual table pointer）指针指出。vptr指向一个函数指针数组，称为vtbl（virtual table）；每一个类都有一个对应的vtbl。当对象调用某一个virtual函数时，实际被调用的函数取决于该对象的vptr指针所指的vtbl。简单来说，如果Point class含有virtual函数，则它的存储空间不止64bits。因为一个指针也是32bits，所以为Point增加一个vptr会使存储空间中间50%~100%。造成的结果是，Point对象不能一次塞入64-bits的寄存器，也不能传递给其他语言（因为其他语言很可能没有vtpr结构）。所以，某些情况下不声明为virtual函数是不对的，而某些情况下无端端声明为virtual函数也是不对的。我们建议是，针对第一种情况，当class中至少存在一个virtual函数时，才为它声明virtual析构函数；针对第二种情况，如果该类不作为base class使用时，不应该声明为virtual函数。所以回到上面的问题，为什么默认的析构函数不是virtual函数？因为virtual函数指针和virtual函数表时需要消耗空间，而在类程序中又不一定被继承，所以默认的析构函数不是虚函数。  类的空间存储：      空的类是会占用类内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。    类的普通成员变量占用类内存空间，并且遵守字节对齐原则。    类的static静态变量不占用类内存空间，原因是编译器将其放在全局变量区。    类的普通成员函数不占用类内存空间。    类的虚函数占用4个字节（32位系统）或8个字节（64位系统），用来指定虚函数的虚拟函数表的入口地址。一个类的虚函数指针是不变的，和虚函数的个数以及基类是否有虚函数没有关系的。    C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区和堆区，少数放在静态/全局区以及文字常量区)，实例化不同对象时，只给数据分配空间，而函数不占用类内存空间（包括友元函数、内联函数）。  总结      如果该类不作为base class使用时，不应该声明为virtual函数    当class中至少存在一个virtual函数时，才为它声明virtual析构函数  纯虚析构函数拥有纯虚（pure virtual）函数的类，为抽象类。抽象类不能实例化对象。抽象类的子类会自动继承该纯虚函数，如果子类中任然没有实现该方法，那么该子类任然为纯虚函数。声明代码如下：//声明格式：virtual 函数类型 函数名（ 参数列表 ） =0; 可以没有函数体的实现virtual int fun(int n,int m)=0;如果我们想将类声明为抽象类，但手上没有纯虚函数，此时我们可以将析构函数声明为纯虚函数。代码逻辑如下：class AWOV{public:    virtual ~AWOV() = 0 ;};AWOV::~AWOV() { }   //  当然，你必须为纯虚析构函数提供一份定义最外层的派生类会先调用析构函数，然后逐级调用析构函数，一直到里层的基类析构函数。编译器会在派生类的析构函数中创建一个对基类调用析构函数的动作。所以这里必须为纯虚析构函数提供一份定义，否则AWOV找不到对应的析构函数定义，连接器会报错。总结      如果想将类声明为抽象类，但成员函数没有纯虚函数时，可以将析构函数声明为纯虚函数，但是需要为纯虚析构函数提供一份定义  析构函数异常假设一个场景，我们有以下的类。class Widget{public:    ...    ~Widget() {...} //  假设可能会产生异常};void doSomething(){    std::vector&lt;Widget&gt; v;    ...}   //  程序运行到此处，v应该被自动销毁我们现在执行doSomething函数，假设在执行过程中发生了异常，那系统要调用析构函数释放资源。但是这个时候，如果Widget析构函数也出现了异常。就会导致一个问题，前一个异常还没有处理完成，析构函数中的异常将怎么处理呢？对于C++而言，两个同时存在异常太多了，程序会不知道怎么处理它们。前一个异常的处理，需要析构函数释放资源；但是现在析构函数也异常了，如果抛出的话，上一层栈也是异常状态。那该怎么办呢？总的来说，它们会导致程序出现不明确的行为，或者导致程序过早结束。建议C++中，析构函数不要抛出异常，因为容易导致程序过早结束或出现不明确行为。现实例子我们现在封装一个数据库操作类，由于打开数据库后，需要及时close掉数据库连接，否则会导致不必要的资源浪费（连接持续存在，但是我们已经不用了）。为了方便，我们可以将close方法写在数据库操作类的析构函数中。代码逻辑如下：class DBConn{public:    ...    ~DBConn(){        db.close();    }private:    DBConnnection db;};客户使用该类的时候，代码逻辑如下：{   //  在某个代码块内调用数据库    DBConn dbc(DBConnnection.create());    ...}   //  区块结束时，DBConn对象会自动调用析构函数，执行clase()方法解决方法根据上面数据库的例子，我们给出两个解决方法：  结束程序如果析构函数抛出异常，既然这个对象后面不会再使用了，那我们就结束掉程序（因为当前对象或变量正在注销，意味着它们不会在后面的代码出现，也就是不会对后面的行为产生影响），阻止异常从析构函数中传播出去，防止程序出现不明确行为。代码逻辑如下：    DBConn::~DBConn{ try{     db.close(); }catch (...){     ... //  记录错误情况     std::abort();   //  调用abort方法结束程序 }}        吞下异常吞下异常是指记录下异常情况（必要的日志输出），然后忽略该异常，让异常不再向上传播。虽然一般而言吞下异常是个坏主意，但是比起程序过早结束和出现不明确行为，吞下异常让程序继续清理内存，防止内存泄漏。代码逻辑如下：    DBConn::~DBConn{ try{     db.close(); }catch (...){     ... //  记录错误情况 }}        让客户处理以上两个方法都无法对异常做出反应，最好的方法还是让客户自己处理异常，而把上面两种方法作为第二重保险（如果处理不了该异常，则结束或者吞下它）。代码逻辑如下：class DBConn{public:    ...    void close(){   //  自定义函数，处理各种可能的情况        //  这里可以在数据库关闭前做各种检查，并执行对应措施，预防出现异常的情况出现        ...        db.close();        closed = true;    }    ~DBConn(){        if(!closed){    //  追踪关闭状态，防止客户忘记调用close方法            try{                db.close();            }catch (...){                ... //  记录错误情况                ... //  结束或吞下异常            }        }    }private:    DBConnnection db;    bool closed;};总结      析构函数中不要抛出异常，因为可能导致程序过早结束或出现不明确行为    提供一个普通函数（并非在析构函数中）对异常做出处理，而析构函数中出现异常应该直接结束程序或者吞下异常  不要在构造/析构函数中调用virtual函数我们先看一个例子，假设我们有有个股票交易类，该类表示每一笔交易，当交易创建的时候需要写入日志进行审计。代码逻辑如下：class Transaction{public:    Transaction();    virtual void logTransaction() cosnt = 0 ; //  日志记录};Transaction::Transaction(){    ...    logTransaction();}当然，交易类型可能有多种，对于不同的交易类型，需要记录的信息也有所差别。代码逻辑如下：Class BuyTransaction: public Transaction{public:    virtual void logTransaction() const;    //  买入交易记录    ...}Class SellTransaction: public Transaction{public:    virtual void logTransaction() const;    //  卖出交易记录    ...}现在我们执行以下代码：BuyTransaction b;我们很快发现了问题，Transaction构造函数在最后一行调用logTransaction方法，但这时候被调用的Transaciton的版本，而不是BuyTransaction的版本。本例中，由于logTransaction方法是纯虚函数，还会抛出连接器错误。也就是说，基类构造函数调用期间，virtual函数不是virtu函数，不会下降到derived class的阶层。我们有两个原因解释这个现象：  base class的构造函数先于derived class的构造函数调用。这个时候derived class很多成员变量尚未初始化，C++为了防止一些不安全的行为（如使用未初始化的变量），不能使用derived class的成员函数。  在base class构造函数运行期间，所有的运行期类型信息（virtual函数，dynamic_cast，typeid等等）会被编译器解析为base class类型。也就是说，在derived class构造函数调用之前，并不是成为derived对象，而是视为base对象。同样的道理也适用于析构函数，由于derived class的析构函数先于base class的析构函数调用。所以在base class析构函数调用时，derived class的成员变量是未定义值，C++视它们为不存在。base class析构函数后的对象成为一个base对象，C++的virtu函数部分也对应base class的定义。编译器能监测构造/析构过程中是否调用virtual函数吗？可能你有个疑问，那禁止在构造/析构函数中调用virtual函数不就好了吗？这对编译器很容易实现吧？回答这个问题之前，我们先来看下面一段代码：class Transaction{public:    Transaction();    virtual void logTransaction() cosnt = 0 ; //  日志记录private:    void init();};Transaction::Transaction(){    init();}void Transaction::init(){    ...    logTransaction();}如果我们有多个构造函数，我们可能会提取重复部分（即init方法）。如果virtual函数存在于init方法中，而编译器检测构造函数并没有发现调用virtual函数，很有可能就让这段有问题的代码通过了。所以编译器监测构造/析构过程中是否调用virtual函数并不容易。解决方法这个场景下我们知道构造函数中肯定无法调用derived class的virtual函数了，所以解决方法就是将virtual函数转化为non-virtual函数。同时我们可以在derived class构造之前，通过初值列将必要的构造信息向上传递给base class的构造函数，从而实现不同类型的日志记录。代码逻辑如下：class Transaction{public:    explicit Transaction(const std::string&amp; logInfo);    void logTransaction(const std::string&amp; logInfo); //  non-virtual函数    ...};Transaction::Transaction(const std::string&amp; logInfo){    ...    logTransaction(logInfo)}class BuyTransaction:public Transaction{public:    BuyTransaction(params):Transaction(createLogString(params)){...}    ...private:    //  这里可以先将params参数操作后再传递给base class构造函数，增强灵活性和可读性    static std::string createLogString(params);};注意，createLogString修饰为static，可以防止构造函数初始化过程中，该方法不会指向BuyTransaction对象内尚未初始化的成员变量。这很重要，因为base class构造和析构函数期间，这些成员变量处于未定义状态，不能下降传递给derived class。总结      不要在构造/析构函数中调用virtual函数，因为这类调用不能下降到derived class层  Reference[1] «Effective C++»[2] 虚函数（virtual）[3] C++中类所占的内存大小以及成员函数的存储位置"
  },
  
  {
    "title": "读书笔记 —— Effective C++(2)",
    "url": "/posts/Effective-C++_2/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2022-12-03 11:05:00 +0800",
    





    
    "snippet": "  众所周知，对象使用之前应该先被初始化，针对自定义类的初始化，我们通过赋值和初始化的差别，给出了构造函数初始化过程的建议写法。而对于跨编译单元，non-local static对象的初始化顺序不能明确确定，所幸我们通过一些简单的技巧可以解决这个问题。对象使用之前已被初始化建议众所周知，对象使用之前最好先初始化，这是因为C++读未初始化的变量时，会读入一些随机的bits，导致程序产生莫名的错...",
    "content": "  众所周知，对象使用之前应该先被初始化，针对自定义类的初始化，我们通过赋值和初始化的差别，给出了构造函数初始化过程的建议写法。而对于跨编译单元，non-local static对象的初始化顺序不能明确确定，所幸我们通过一些简单的技巧可以解决这个问题。对象使用之前已被初始化建议众所周知，对象使用之前最好先初始化，这是因为C++读未初始化的变量时，会读入一些随机的bits，导致程序产生莫名的错误。关于初始化的重要性，我们不需要做过多阐述，我们将初始化的变量类型分为两类，以对照的方式深入研究初始化过程中的一些细节。  C++内置类型初始化，如int，double，int*等  C++自定义类的对象初始化，通过构造函数完成初始化总结      永远在使用对象之前先将它初始化    确保每一个构造函数都将每一个成员初始化  初始化与赋值我们先来看下面一段代码：class PhoneNumber{...};class ABEntry{public:    ABEntry(const std::string&amp; name,const std::string&amp; address,            const std::list&lt;PhoneNumber&gt; &amp;phones);private:    std::string theName;    std::string theAddress;    std::list&lt;PhoneNumber&gt; thePhones;    int numTimesConsulted;};ABEntry::ABEntry(const std::string&amp; name,const std::string&amp; address,                 const std::list&lt;PhoneNumber&gt; &amp;phones){    theName=name;    theAddress=address;    thePhones=phones;    numTimesConsulted=0;}问题：上面的构造函数是完成初始化吗？你可以会想：当然，构造函数不就是来完成对象初始化的吗？实际上，这个构造函数并不真的是对象初始化，而是赋值！那初始化和赋值有什么区别呢？我们从更底层的程序运行机制来探讨这个问题：首先，string和list类型并不是C++的基本类型，而是一个类。而类的初始化过程是在构造函数中完成的。所以上述ABEntry类的构造过程是这样的：  首先ABEntry调用构造函数  name、address、phones变量调用各自的default（无参）构造函数创建成员对象  在构造函数体中，对刚刚创建的对象完成赋值操作  C++ 规定对象的成员变量（如name、address）的初始化动作发生在进入构造函数本体（即ABEntry）之前。既然赋值和初始化得到的结果是一样的，那我们有必要深究他们之间的区别？有的！成员对象default构造函数完成之后，立即赋予新值，那default构造函数所做的一切就没有意义了。也就是说，初始化的效率要高于赋值。当我们构造一个及其复杂的对象时，这些小的细节能带来巨大的速度优化！  对了，我们注意到numTimesConsulted是int类型，它是内置的基本类型，它没有构造函数，那它赋值和初始化在效率上有差别吗？既然没有构造函数，也就是说，其初始化和赋值的成本几乎是相同的。那既然这种构造函数的写法不是初始化，那自定义类的初始化过程该怎么写呢？ABEntry::ABEntry(const std::string&amp; name,const std::string&amp; address,                 const std::list&lt;PhoneNumber&gt; &amp;phones)                 :theName(name),theAddress(address),thePhones(phones),numTimesConsulted(0){ }  虽然我们上面说内置类型的初始化和赋值过程是相同的，但为了统一和美观，我们把numTimesConsulted变量也采用初始化的写法当然如果我们想要构造一个无参构造函数，也可以采用初始化的写法，只用参数指定为空即可。ABEntry::ABEntry():theName(),theAddress(),thePhones(),numTimesConsulted(0){ }  《Effective C++》中建议在构造函数中，即使某些成员变量不需要传参，也把它们全部列出来。这样做的好处是可以一目了然看出什么成员变量需要赋予初始值，而什么变量不需要赋初值，而且不会遗漏需要初始化，但又没有赋初值的变量。特殊情况如果成员变量是const或者references，它们就一定要用初值初始化，而不能被赋值。为了避免记住成员变量什么时候一定要初始化，什么时候不需要，一个简单的做法是：总是采用初始化写法！这样不仅安全，而且相比赋值更高效！消除重复如果我们有多个构造函数，某些构造函数的初始化过程是一样的，就会导致不受欢迎的重复和无聊的复制。这种情况下我们可以做出一些折中，把一些内置类型（因为它们的初始化成本和赋值成本相同）的初始化抽离出来，单独形成一个函数，然后供所有的构造函数调用。当然，对于程序而言，最高效的做法还是把所有成员变量采用初值列的方式初始化。总结  内置类型初始化和赋值成本相同，而自定义类型初始化比赋值更高效  如果成员变量是const或者references，一定要用初值初始化，不能被赋值  建议把所有成员变量都采用初值列的方式初始化，这种做法安全且高效初始化顺序类在初始化时，先初始化base classes（基类），再初始化derived classes（派生类）。在同一个类中的成员变量，按照声明顺序进行初始化。这里给出一个建议，初值列中最好以声明的顺序列出各个成员，这样的写法有两个好处：  统一，一目了然，减少阅读者的迷惑  防止一些隐晦的错误，比如两个成员变量的初始化顺序有要求（初始化时array需要指定大小，指定大小的成员变量需要先完成初始化）同一个文件的初始化过程我们已经了解清楚了，只要我们按照建议，就能将出错的概率降到最小。但是不同文件的情况呢？  一个编译单元指产出单一目标文件，即一个.cpp文件加上它的头文件。接下来我们深入探讨不同编译单元的初始化顺序。在这之前，我们先介绍一个概念——non-local static对象，因为它是多文件编译时，最容易出问题的一类对象。non-local static对象首先先明确一点，non-local static不是指static关键字定义的对象。这里是static是全局的意思，即内存在data段和bss段中的对象。既然是全局变量，至少可以排除那些内存是在堆中和栈中的对象了，因为它们会随着函数的出栈等改变当前作用域的情况，结束自己的生命周期。non-local static对象在整个程序的生命周期内都是存在的，除非程序结束否则会一直存在。如果是在函数内部定义的static对象，那么这种static对象被称为local static对象，除此之外的都是non-local static对象，包括以下几种：  global对象  定义于namespace的对象  class作用域内使用static关键字声明的对象  file作用域内使用static关键字声明的对象问题因为C++对定义于不同编译单元内的non-local static对象的初始化次序并无明确定义，所以存在这样一种情况：如果编译单元A的non-local static对象初始化过程中，调用了另一个编译单元B的non-local static对象，而编译单元的non-local static对象可能还没完成初始化。下面我们用一个例子说明这个问题：我们假设构建一个FileSystem的类，这个类封装了操作网络文件的各种方法，让你使用起来像在操作单机文件。假设该类中有一个readDist方法，读取本机的磁盘数量，该数量在构造函数中初始化。FileSystem.cpp文件#include &lt;iostream&gt;#include \"common.h\"FileSystem fs; // 操作文件类同时我们构建一个Directory的类，这个类调用FileSystem的方法，创建一个临时目录。Directory.cpp文件#include &lt;iostream&gt;#include \"common.h\"Directory dt; // 目录类，用于创建一个临时目录程序入口main方法，这里我们主要观察FileSystem和Directory类的初始化顺序，所以main方法的内容并不重要。main.cpp文件#include &lt;iostream&gt;#include \"common.h\"using namespace std;int main(){    cout &lt;&lt; \"example\" &lt;&lt; endl;    return 0;}common.h文件包括了FileSystem和Directory类的具体实现，并把FileSystem类接口暴露出来。common.h文件#ifndef _LIB_H_#define _LIB_H_#include &lt;iostream&gt;using namespace std;class FileSystem;extern FileSystem fs;class FileSystem{public:    FileSystem()    {        value = 100; // 假设初始化值为100        cout &lt;&lt; \"fs construct\" &lt;&lt; endl;    }    void readDist()    {        cout &lt;&lt; \"fs readDist: \" &lt;&lt; \"value=\" &lt;&lt; value &lt;&lt; endl;    }private:    int value;};class Directory{    public:        Directory()        {            cout &lt;&lt; \"Temp Directory construct\" &lt;&lt; endl;            fs.readDist();        }};#endif接下来我们来编译这三个类，编译过程如下：//  编译文件g++ -c -o Directory.o Directory.cpp g++ -c -o FileSystem.o FileSystem.cpp g++ -c -o main.o main.cppg++ Directory.o FileSystem.o main.o ./a.outfs constructTemp Directory constructfs readDist: value=100exampleg++ FileSystem.o Directory.o main.o ./a.outTemp Directory constructfs readDist: value=0fs constructexample从实验结果我们可以看到，第二次运行程序的时候，value的值为0，说明在FileSystem类初始化之前，它就被调用了。在实际工程中，未初始化先调用很容易引起意想不到的错误，所以我们得确保FileSystem类被调用之前先初始化。那怎么能够确定它调用之前初始化呢？答案是：无法确定。因为确定它们的初始化顺序非常非常困难，甚至会无解。特别在隐式模板具体化（implicit template instantiations）编译得到的non-local static对象不但不可能得到正确的初始化顺序，甚至不值得去找“正确顺序”的特殊情况。  隐式模板具体化指类或函数模板只有当使用模板时，编译器才根据模板定义生成相应类型的实例。而non-local static对象在调用之前，不知道初始化成什么模板类型，导致无法先完成初始化动作。解决方案既然如此，那这个问题无解了吗？不，我们给出一个简单的解决方案：将这些non-local static对象放置在自己的专属函数中（对象在此函数声明为static），然后返回一个reference指向该对象。当用户需要这些对象时，调用该函数，而不是直接使用该对象。换句话说non-local static对象被替换为local static对象。也就是我们熟悉的，单例模式。改造后的代码如下：FileSystem.cpp文件FileSystem&amp; getFileSystem(){    static FileSystem fs;    return fs;}common.h文件#ifndef _LIB_H_#define _LIB_H_#include &lt;iostream&gt;using namespace std;class FileSystem;FileSystem&amp; getFileSystem();class FileSystem{public:    FileSystem():value(100) // static不能用赋值方式初始化    {        // value = 100; // 假设初始化值为100        cout &lt;&lt; \"fs construct\" &lt;&lt; endl;    }    void readDist()    {        cout &lt;&lt; \"fs readDist: \" &lt;&lt; \"value=\" &lt;&lt; value &lt;&lt; endl;    }private:    int value;};class Directory{    public:        Directory()        {            cout &lt;&lt; \"Temp Directory construct\" &lt;&lt; endl;            getFileSystem().readDist(); //改成通过返回来获取fs的引用        }};#endif这样修改成功的原因在于，C++保证local static对象会在该函数首次被调用期间，才完成初始化。如果没调用，则不会出发构造函数。特殊情况当然这种方法也有麻烦，即内含static对象在多线程系统中有不确定性。无论是non-local static还是local static对象，由于多线程顺序是不确定的，导致存在初始化顺序不确定的情况。我们给出了一种简单的处理方法，在程序开始运行时，先采用单线程的方法手动调用所有的单例构造函数，这可以消除与初始化有关的竞速形势（race conditions）。当然，这需要我们手动确定初始化顺序，对开发者而言依然是个麻烦事。总结      为避免“跨编译单元的初始化顺序”问题，建议用单例模式将所有的non-local static对象替换为local static对象  Reference[1] «Effective C++»[2] non-local static对象初始化顺序[3] 模板显式、隐式实例化和（偏）特化、具体化的详细分析"
  },
  
  {
    "title": "读书笔记 —— Effective C++(1)",
    "url": "/posts/Effective-C++_1/",
    "categories": "Reading Notes, Effective C++",
    "tags": "C++, Reading Notes",
    "date": "2022-11-30 10:53:00 +0800",
    





    
    "snippet": "  我们建议程序编写中用const代替#define定义常量，用inline函数代替#define宏定义函数，并讨论了这样做的必要性。最后再介绍了const修饰成员函数，说明了const修饰在成员函数上的含义，并为相同的const函数重载提出一个去除重复的解决方案。用const代替#define定义常量建议我们平时定义一个常量可能会采取这样的方式：#define Pi 3.14书中建议我们应...",
    "content": "  我们建议程序编写中用const代替#define定义常量，用inline函数代替#define宏定义函数，并讨论了这样做的必要性。最后再介绍了const修饰成员函数，说明了const修饰在成员函数上的含义，并为相同的const函数重载提出一个去除重复的解决方案。用const代替#define定义常量建议我们平时定义一个常量可能会采取这样的方式：#define Pi 3.14书中建议我们应该采取这样的写法const double Pi 3.14;我们通过两者之间的区别来给出理由。      #define，宏定义，是一条预编译指令。编译器会在预编译阶段将它从移出并替换为指定内容，这意味着Pi不会进入记号表(symbol table)，而被单纯的替换、移走。而const则会在编译运行阶段进行编译。  采用#define定义常量容易导致编译时引起意想不到的结果，例如你获得一个报错消息，但这个消息提到了3.14而不是Pi。更甚的是，这个宏被你定义在某个头文件，甚至你不知道3.14从何而来，从而花费时间去追踪。所以我们给出的第一个理由是，采用const定义常量更容易在编译过程中追踪报错内容。        #define定义的常量在程序中会替代为立即数，每一个立即数都会在寄存器中有一份拷贝。而const定义的变量在内存中分配一个寄存器，使用时只引用这一份拷贝。这就导致了#define定义常量的做法产生了多个3.14，而改为const定义常量则不会出现这种情况。所以我们给出的第二个理由是，采用const定义常量更有益于提高空间利用率，在一些长字符串常量的情况下，提升效果会更加明显。        #define的作用域是从#define开始到#undef（如果没有#undef那就是到文件末尾）。而const定义的变量根据定义所在的位置有明确的作用域。试想一个场景，当我们需要创建一个class的类内变量时，#define无法做到。它不能实现只在类内替换，也不能支持任何封装性，也就是说没有所谓的private #define这种用法，而const定义类内变量没有任何问题。所以我们给出的第三个理由是，采用const定义常量作用域更明确，更支持类语法，且不会造成命名污染。        #define定义的常量不需要指定类型，也不会做类型检查。而const定义常量需要指定类型，而且在编译阶段会做类型检查。#define中被替换的常数可能在程序运行过程中出现类型错误，产生bug。所以我们给出的第四个理由是，采用const定义常量作用域更能保证类型安全。  一些特殊情况  常量指针和指针常量          常量指针：        定义：指针是变量，而指向的地址是常量，而地址所指的值是变量。常量指针指向的对象不能通过这个指针来修改，但可以通过原来的声明修改（见下面例子）。  表示形式：    int const* p1;  const int* p1;        例子:    const int *p1 = &amp;a; a = 200; // OK,可以通过原来的声明修改*p1 = 13; // Error,*p1是const int的，常量指针不可修改其指向地址p1 = &amp;b; // OK,指针还可以指向别处，因为指针只是个变量        指针常量：  定义：指针是常量，而指向的地址是变量，而地址所指的值也是变量。指针指向的值不可以改变，然而指针所指向的地址的值可以修改（见下面例子）。  表示形式：    int* const p1;        例子:    int* const p2 = &amp;a; a = 200; // OK,可以通过原来的声明修改*p2 = 900; // OK,指针是常量,但是指向的地址所对应的值是变量，可以修改p2 = &amp;b; // Error,因为p2是const*指针，因此不能改变p2指向的地址              补充：        如果需要在头文件中，定义一些指向常量的常量指针，需要加两次const（如下）    const int* const p3 = &amp;a;const char* const name=\"Fanventory\";        当然，更好的写法是使用string对象（如下）    const std::string name(\"Fanventory\");        定义class类内常量如果需要在class类内声明一个常量，，由于常量的作用域限制在class内，必须确保该常量至多只有一份实体，也就是说我们必须声明为static。    class GamePlayer{private: static const int NumTurns=5; int scores[NumTurns];};        class类内常量完成in-class初值设定在某些旧式编译器中，class中如果存在数组，编译期间必须得知道数组大小，上述的scores[NumTurns];可能会报错。我们可以采用“the enum hack”的补偿做法。具体实现如下：    class GamePlayer{private: enum { NumTurns=5 }; // 令NumTurns成为一个记号名称 int scores[NumTurns];};        enum与const也有区别，const常量的地址是合法的，而取enum的地址是不合法的，也如取#define定义的常量地址也是不合法的。总结      const定义的常量更容易在编译过程中追踪报错内容。    const定义的常量空间利用率更高。    const定义的常量作用域更明确，更支持类语法，且不会造成命名污染。    const定义的常量更能保证类型安全。  用inline函数代替#define宏定义函数建议我们在平时写代码时，可能会遇到以下的写法：#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))这种宏(macros)看起来像是函数，且不会由于函数调用而带来额外开销。但它也有很多缺点，比如以下场景：int a=5,b=0;CALL_WITH_MAX(++a,b); // 累加了一次CALL_WITH_MAX(++a,b+10); // 累加了两次后一次调用累加了两次，这明显是不对的。那有没有方法既能享受类似宏带来的效率，又能使函数的行为可预料，且参数类型能够安全检查呢？我们可以使用template inline函数：template&lt;typename T&gt;inline void CALL_WITH_MAX(const T&amp; a, const T&amp; b){    f(a &gt; b ? a : b);}该方法定义的CALL_WITH_MAX是一个真正的函数，遵守作用域和访问规则。甚至可以写出一个类内的private inline函数，而#define却无法完成此事。当然，#define的需求依然存在，但为了程序的安全性和正确性，我们应该更谨慎地使用他们。总结      对于形似函数的宏，最好改用inline函数代替。  cosnt成员函数const可以作用在类内的成员函数上，这样做有两个好处：  清楚地知道哪个函数可以改动对象内容，而哪个函数不行  如上面用const代替#define定义常量所说，以reference-to-const方式传参，可以提高编程效率在展开说明const修饰成员函数之前，我们先提出一个冷知识：          两个成员函数如果只是常量性(constness)不同，它们是可以被重载的（例子如下）      class TextBlock{public:    ...    const char&amp; operator[] (std::size_t position) const // 重载    { return text[position];}    char&amp; operator[] (std::size_t position) // 重载    { return text[position];}private:    std::string text;};下面我们来运行这两个重载方法，并观察其区别TextBlock tb(\"Hello\");const TextBlock ctb(\"world\");std::cout&lt;&lt;tb[0]; // ok，读non-const TextBlocktb[0]='x'; // ok，写non-const TextBlockstd::cout&lt;&lt;ctb[0]; // ok，读const TextBlockctb[0]='x'; // no，写const TextBlock；重载方法的返回值用const修饰，并不可改介绍这个冷知识，是为了接下来我们通过const成员函数和non-const成员函数的对比，来阐述const修饰成员函数的含义。const成员函数的含义const修饰成员函数意味着什么？曾经有两种流行的概念：bitwise constness（或physical constness）和logical constness。  bitwise constness根据const的定义，bitwise constness阵营的人认为，成员函数只有在不改变对象中的任何成员变量时，才可以说是const，即const成员函数不可以更改对象内任何non-static成员变量。这个概念简单易懂，但存在一些BUG。我们看下面的一个例子：    class CTextBlock{public: ... char&amp; operator[] (std::size_t position) const // bitwise声明 { return text[position];}private: char* pText;};      这个函数并没有修改对象中的任何值，但它却返回了一个reference，指向对象的内部值。编译器认为它是bitwise constness的。但如果我们很快发现，通过返回的reference，我们可以修改类中的值：const CTextBlock cctb(\"Hello\");char *pc=&amp;cctb[0];*pc='J'; // 此时cctb的内容变成了Jello这显然是错误的，因为我们声明了一个const对象，又只调用const方法，但最终我们还是能改变它的值。基于这种情况，出现了另一派：logical constness。  logical constnesslogical constness这一派认为，一个const成员函数可以修改它所处理对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。我们举一个例子来说明：    class CTextBlock{public: ... std::size_t length() const;private: char* pText; std::size_t textLength; // 最近一次计算的文本块长度 bool lengthIsValid; // 目前长度是否有效};std::size_t CTextBlock::length() const{ if(!lengthIsValid){     textLength = std::strlen(pText);     lengthIsValid = true; } return lengthIsValid;}      这个例子中，我们修改了textLength和lengthIsValid的值，但客户端并不知情，对客户端可见的内容仍然是不可修改的。根据logical constness的定义，我们认为它是const的。但我们很快又发现，根据bitwise constness的观点，const成员函数内不能修改对象内non-static成员变量的值，而textLength和lengthIsValid却被修改了，这不符合bitwise constness，当然也通不过编译器。为了解决这个问题，我们给这两个变量添加mutable（可变的），释放bitwise constness的约束，这样问题就迎刃而解了。具体代码如下：class CTextBlock{public:    ...    std::size_t length() const;private:    char* pText;    mutable std::size_t textLength; // 最近一次计算的文本块长度    mutable bool lengthIsValid; // 目前长度是否有效};std::size_t CTextBlock::length() const{    if(!lengthIsValid){        textLength = std::strlen(pText);        lengthIsValid = true;    }    return lengthIsValid;}避免cosnt和non-const重载成员函数中的重复现实需求中，我们重载[]操作符的方法可能更加复杂，可能会涉及到一些诸如边界检验（bound checking）、日志访问消息（logged access info）、数据完善性检验（verify data integrity）等功能。如果我们把这些代码都放入const和non-const的重载成员函数中，代码将会有很多的重复内容。这会使得代码臃肿，难以维护，还会增加编译时间。就像下面代码这样：class TextBlock{public:    ...    const char&amp; operator[] (std::size_t position) const // 重载    {         ...     // 边界检验        ...     // 日志数据访问        ...     // 检验数据完善性        return text[position];    }    char&amp; operator[] (std::size_t position) // 重载    {         ...     // 边界检验        ...     // 日志数据访问        ...     // 检验数据完善性        return text[position];    }private:    std::string text;};为了解决这个问题，我们可以使用常量性转型（casting away constness）。  注意：我们需要谨慎对待转型，因为不安全的转型将会给程序带来错误。我们的想法是这样的，首先实现const operator[]的方法。然后当我们需要non-const operator[]的方法时，将对象转化为const类型，然后调用const operator[]的方法，最后再消除返回值中const的约束。  注意：如果我们没有将对象转化为const类型，那它就会递归调用non-const operator[]的方法，直到系统栈崩溃。我们实现的代码如下：class TextBlock{public:    ...    const char&amp; operator[] (std::size_t position) const // 重载    {         ...     // 边界检验        ...     // 日志数据访问        ...     // 检验数据完善性        return text[position];    }    char&amp; operator[] (std::size_t position) // 重载    {         // const_cast&lt;&gt;(a)的作用是将a的值消除cosnt        // static_cast&lt;&gt;(b)的作用是将b转换为某种类型        // 通过*this完成对象调用自身的const operator[]方法        return const_cast&lt;char&amp;&gt;(            static_cast&lt;const TextBlock&amp;&gt;(*this)[position]        );    }private:    std::string text;};最后我们来探讨一个问题，在上述代码中我们实现了const operator[]的方法，然后在non-const operator[]的方法中调用它，那反过来行不行呢？答案是不行的！因为在const operator[]方法中调用non-const operator[]的方法，那我们就违反了const的定义——不能在const函数中改动non-static成员变量的值。而反过来，non-const operator[]方法没有这样的限制，所以调用一个const成员函数并没有什么风险。所以我们在这里强调，要谨慎使用转型，要保证我们的转型代码是安全的。总结      编译器强制执行bitwise constness    const和non-const成员函数有相同的实现时，可以令non-const版本调用const版本来避免重复  Reference[1] «Effective C++»[2] 用const代替#define定义常量[3] 常量指针、指针常量的区别"
  }
  
]

